<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MapWinGeoProc</name>
    </assembly>
    <members>
        <member name="T:MapWinGeoProc.Topology.ShapeCategories">
            <summary>
            A grouping that categorizies the shape types
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.ShapeCategories.Point">
            <summary>
            Point, PointM, or PointZ
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.ShapeCategories.MultiPoint">
            <summary>
            MultiPoint, MultiPointM, or MultiPointZ
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.ShapeCategories.Line">
            <summary>
            LineString, LineStringM, or LineStringZ
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.ShapeCategories.Polygon">
            <summary>
            Polygon, PolygonM, or PolygonZ
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.ShapeCategories.Invalid">
            <summary>
            NullShape or MultiPatch (Not Supported)
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Topology.LineString">
            <summary>
            A polyline (under construction)
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineString.#ctor">
            <summary>
            initialises a polyline with no points.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineString.#ctor(MapWinGIS.Shape)">
            <summary>
            Creates a new instance of the polyline class
            </summary>
            <param name="mwShape">A MapWinGIS.Shape to derive the polyline from</param>
            <remarks>Assumes shape is one part.  To Split Multipart shapes, use Split.</remarks>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineString.Invalidate">
            <summary>
            Many properties are derived from the points.  Generally, these are calculated
            once and cached.  Most changes that can be made externally will automatically
            cause an invalidation to occur, so adding points, for instance, will force
            the perimeter to be recalculated.  This forces such an invalidation so that the
            next time derived properties are queried, they will be recalculated.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineString.Add_Point(MapWinGeoProc.Topology.Point)">
            <summary>
            Adds a point to the list of points and adjusts the extents
            Invalidates derived properties so that they will be recalculated when
            queried.
            </summary>
            <param name="newPoint">A Point to add to the Polygon</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineString.Add_Point(MapWinGIS.Point)">
            <summary>
            Adds a MapWinGIS.Point to the list of points and adjusts the extents
            Invalidates derived properties so that they will be recalculated when
            queried.
            </summary>
            <param name="mwPoint">A MapWinGIS.Point to append to the list</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineString.Insert_Point(System.Int32,MapWinGeoProc.Topology.Point)">
            <summary>
            Inserts a point in the list.  Remember that this list does not need to
            end with the first point.  Invalidates derived properties so that they
            will be recalculated when queried.
            </summary>
            <param name="Index">The index specifying where to insert the point</param>
            <param name="newPoint">The Point you want to insert into this polyline</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineString.Insert_Point(System.Int32,MapWinGIS.Point)">
            <summary>
            Inserts a point in the list.  Remember that this list does not need to
            end with the first point.  Invalidates derived properties so that they
            will be recalculated when queried.
            </summary>
            <param name="Index">The index specifying where to insert the point</param>
            <param name="mwPoint">The MapWinGIS.Point you want to insert into this Polygon</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineString.Add_LineSegment(MapWinGeoProc.Topology.LineSegment)">
            <summary>
            Appends the the givin line segment to the end of the polyline.
            We assume that if the first point in the segment is the same as the
            endpoint of the polygon, we don't need to add the first point.
            </summary>
            <param name="newLineSegment">LineSegment, the line segment to append</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineString.Insert_LineSegment(System.Int32,MapWinGeoProc.Topology.LineSegment)">
            <summary>
            Inserts a segment into a polyline.
            This will check the points of the segment and only add the points if they are 
            not identical to what will become the adjacent points.
            </summary>
            <param name="Index">the position to add the segment in the list of points</param>
            <param name="newLineSegment">The LineSegment to insert</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineString.ToLineSegments">
            <summary>
            Will create a list of segment objects for the entire polygon
            </summary>
            <returns>A List of LineSegments representing the entire polygon</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineString.LineSegmentsWithin(MapWinGeoProc.Topology.Envelope)">
            <summary>
            Returns a list of segments from the Polyline that are within the
            submitted extents.
            </summary>
            <param name="Ext">Envelope to check for an intersection with.</param>
            <returns>Returns a list of possible Envelope within range.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineString.mwShape_To_LineStrings(MapWinGIS.Shape)">
            <summary>
            If a Shape has multiple parts, this will create a separate polyline for each part.
            </summary>
            <param name="mwShape">A MapWinGIS.Shape that should be a LineString shape type</param>
            <returns>A List of Polylines derived from the various shapes</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineString.LineStrings_To_mwShape(System.Collections.Generic.List{MapWinGeoProc.Topology.LineString})">
            <summary>
            Converts a list of polylines into a single multi-part shape
            </summary>
            <param name="Polylines"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineString.LineSegmentsWithinDistanceOf(MapWinGeoProc.Topology.Point,System.Double)">
            <summary>
            Creates a list of segments from this polyline that are within the specified distance to a point
            </summary>
            <param name="Point">The point that represents the test location</param>
            <param name="Distance">Double, the maximum distance for selection</param>
            <returns>A List of LineSegments that are within Distance of the specified Point.</returns>
        </member>
        <member name="P:MapWinGeoProc.Topology.LineString.Center">
            <summary>
            Returns a Point representing the midpoint between all the extents.
            This is not the same as the centroid, which is wieghted by the
            enclosed area.  Setting this will translate your entire polyline,
            so be careful.  The center will automatically correct itself if points are added.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology.LineString.Envelope">
            <summary>
            The extents that form a bounding box around the polyline.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology.LineString.Length">
            <summary>
            Gets a double specifying the length along the polyline
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology.LineString.MaxRadius">
            <summary>
            Gets a double specifying the maximum distance any segment gets from the center
            where the center is defined as the middle of the extents.  Since it is not
            possible for the segments to be further away than the endpoints, the max radius
            must be defined by one of the vertecies.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology.LineString.NetDistance">
            <summary>
            Gets a double representing the distance of the first point to the last point
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology.LineString.Points">
            <summary>
            A list of points within this polygon.  The last point is NOT the same
            as the first, so when adding points just add the last one.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Topology2D.Point">
            <summary>
            In the event that we don't have MapWinGIS, this provides a useful point class with double values
            This will store 3D X, Y and Z values, but has no vector functions.  For that, use the vector class.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Topology2D.Geometry">
            <summary>
            This represents the root Geometry class for 2D space
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Geometry.#ctor">
            <summary>
            Creates a new instance of the geometry class
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Geometry.AsText">
            <summary>
            Exports this geometric object to a specific Well-known text representation of the geometry
            </summary>
            <returns>String, text representation of this geometry</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Geometry.AsBinary">
            <summary>
            Exports this geometric object to a specific well-known binary representation of geometry
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Geometry.Boundary">
            <summary>
            Returns the closure of the combinatorial boundary of this geometric object.  Because the
            result of this function is a closure, and hence topologically closed, the resulting boundary
            can be represented using representational geometry primitives.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Geometry.Equals(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Returns true if theis geometric object is spatially equal to another geometry
            </summary>
            <param name="geom">The specific case to test against this object.</param>
            <returns>Boolean, true if the two geometries are equal</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Geometry.Disjoint(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Returns true if this geometric object is spatially disjoint from another geometry.
            </summary>
            <param name="geom">The specific case to test against this object.</param>
            <returns>Boolean, true if the two geometries are disjoint</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Geometry.Intersects(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Returns true if this geometric object intersects the specified object spatially.
            </summary>
            <param name="geom">The specific instance to test against this object.</param>
            <returns>Boolean, true if the two geometries intersect</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Geometry.Touches(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Returns true if this geometric object spatially touches the specified object.
            </summary>
            <param name="geom">The specific instance to test against this object.</param>
            <returns>Boolean, true if the two geometries touch</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Geometry.Crosses(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Returns true if this geometric object spatially crosses the specified object.
            </summary>
            <param name="geom">The specific instance to test against this object.</param>
            <returns>Boolean, true if the two geometries cross</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Geometry.Within(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Returns true if this geometric object is spatially within the specified object.
            </summary>
            <param name="geom">The specific instance to test against this object.</param>
            <returns>Boolean, true if this geometry is within the specified geometry</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Geometry.Contains(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Returns true if this geometric object is contained by the specified object.
            </summary>
            <param name="geom">The specific instance to test against this object.</param>
            <returns>Boolean, true if the specified geometry contains this geometry</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Geometry.Overlaps(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Returns true if this geometric object spatially crosses the specific object.
            </summary>
            <param name="geom">The specific instance to test against this object.</param>
            <returns>Boolean, true if the two geometries cross</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Geometry.Relate(MapWinGeoProc.Topology2D.Geometry,System.String)">
            <summary>
            Returns true if this geometric object is spatially related to the specified geometry
            by testing for intersections between the interior, boundary and exterior of the two
            geometric objects as specified by the values in the intersectionPatternMatrix
            </summary>
            <param name="geom">The specific instance to test against this object.</param>
            <param name="IntersectionPatternMatrix">The IntersectionPatternMatrix</param>
            <returns>Boolean, true if the two geometries cross</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Geometry.Distance(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Returns the shortest distance between any two Points in the two geometric objects as 
            calculated in the spatial reference system of this geometric object.
            {Note, these points may be interpolated, rather than existing as a vertex}
            </summary>
            <param name="geom">The specific instance to test against this object.</param>
            <returns>Double, the distance between two points.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Geometry.Buffer(System.Double)">
            <summary>
            Returns a geometric object that represents all Points whose distance from
            this geometrric object is less than or equal to distance.  Calculations are in the
            spatial reference system of this geometric object.
            </summary>
            <param name="Distance">The double value representing the buffer distance to use.</param>
            <returns><c>Topology2D.Geometry</c></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Geometry.ConvexHull">
            <summary>
            returns a geometric object that represents the convex hull of this geometric object
            </summary>
            <returns><c>Topology2D.Geometry</c></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Geometry.Intersection(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Returns a geometric object that represetns the intersection of this geometric object
            with the specified geometric object.
            </summary>
            <param name="geom">The geometric object to intersect with this geometric object</param>
            <returns><c>Geometry</c> representing the intersection</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Geometry.Union(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Returns a geometric object that represents the union of this geometric object with 
            the specified geometry.
            </summary>
            <param name="geom">The specific geometry to form a union with this object</param>
            <returns><c>Geometry</c> representing the union of this object with the geom</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Geometry.Difference(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Returns a geometric object that represetns the difference between this object and 
            the specified geometry.
            </summary>
            <param name="geom">A geometric object to compare with this object.</param>
            <returns><c>Topology2D.Geometry</c> representing the difference.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Geometry.SymDifference(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Returns a geometric ojbect that represents the point set symetric difference of this geometric
            object with another geometry.
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Geometry.ShortestPathTo(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Returns null if the two geometries intersect.  Otherwise, returns a segment representing the
            shortest path between the two geometries.
            </summary>
            <param name="geom">The geometries to test</param>
            <returns>LineSegment or null in the case of intersection</returns>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.Geometry.Dimension">
            <summary>
            The inherent dimension of this geometric object, which must be less than or equal to the 
            coordinate dimension.
            </summary>
            <returns>Integer</returns>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.Geometry.GeometryType">
            <summary>
            returns the name of the instantiable subtype of Geometry of which this geometric object is a
            instantiable member.  The name of the subtype of Geobetry is returned as a string.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.Geometry.SRID">
            <summary>
            Returns the Spatial Reference System ID for this geometric object
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.Geometry.Envelope">
            <summary>
            The minimum bounding box for this geometry, returned as envelope.
            </summary>
            <returns>Topology2D.Envelope</returns>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.Geometry.IsEmpty">
            <summary>
            If this geometric object is the empty geometry, this returns true.  If true, then this
            geometric object represents the empty point set 0 for the coordinate space.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.Geometry.IsSimple">
            <summary>
            Returns true if this geometric object has no anomalous geometric points, such as self
            intersection or self tangency.  The description of each instantiable geometric class will
            include the specific conditions that cause an instance of that class to be classified as
            not simple.
            </summary>
            <returns>Boolean, true as long as the shape is simple.</returns>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.Point.X">
            <summary>
            The X coordinate of the point
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.Point.Y">
            <summary>
            The Y coordinate of the point
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.#ctor">
            <summary>
            Creates a new blank instance of the Point class
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.#ctor(MapWinGeoProc.Topology2D.Coordinate)">
            <summary>
            Creates a point (which is a fully fleshed out geometry) from a coordinate
            which only has a basic pair of values.
            </summary>
            <param name="Coord">Point with the same X and Y as the coordinate</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.#ctor(System.Object)">
            <summary>
            Creates a new instance of the Point class
            </summary>
            <param name="MapWinGIS_Point">MapWinGIS.Point to convert into a Point</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.#ctor(System.Double,System.Double)">
            <summary>
            Creates a new instance of the Point class with the values specified
            </summary>
            <param name="x">Double, The coordinate in the X direction</param>
            <param name="y">Double, The coordinate in the Y direction</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.#ctor(MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Creates a new 3D point using the Vector U
            </summary>
            <param name="U">Vector where the X, Y, and Z values are translated into point coordinates</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.Contains(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            This doesn't exist because a point by definition cannot contain anything.
            Calling this for points will always produce a value of false because 
            points cannot contain anything.
            </summary>
            <param name="geom">Any specific type of geometry</param>
            <returns>Boolean, Always False</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.Crosses(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            This doesn't exist because a point by definition cannot exist both on 
            the interior and exterior of any geometry.  Calling this for points will
            always produce a value of false because points cannot cross anything.
            </summary>
            <param name="geom">Geometry</param>
            <returns>Boolean, Always False</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.Disjoint(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Tests whether or not this point is disjoint with the specified geometry.
            </summary>
            <param name="geom">Any type of geometry, like Point LineSegment, Polygon etc.</param>
            <returns>Boolean, true if the interior or borders of the geometry don't come in contact with point.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.Equals(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            This function has been overriden to compare the Points in the mathematical sense.
            If the components of the vector are equal, then this will return true.
            </summary>
            <param name="geom">A geometry object to compare with this object</param>
            <returns>Boolean, true if the X and Y components are equal.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.Intersects(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Checks to see if this point intersects with the specified geometry.
            </summary>
            <param name="geom">The geometry to compare with this point</param>
            <returns>Boolean, true if the interior or boundary of the specified geometry intersects with this point</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.Overlaps(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Points cannot satisfy the critera for overlap, so this is always false.
            </summary>
            <param name="geom">Any geomtery</param>
            <returns>Boolean, Always False.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.Touches(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Determines if this point touches the specified point.
            </summary>
            <param name="geom">Any geometry</param>
            <returns>Boolean, True if this point touches the geometry, false otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.Within(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Determines if this point is inside another geometry.  This will return false 
            unless the other geometry is closed, like a Polygon or an Envelope.  This
            will not return true if the point lies on the border of the shape.
            </summary>
            <param name="geom">Any object derived from the geometry class.</param>
            <returns>Boolean, True if this point is found only on the interior of the specified shape.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.AsText">
            <summary>
            Not implemneted
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.AsBinary">
            <summary>
            Not implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.Boundary">
            <summary>
            Returns a Point equivalent to this point
            </summary>
            <returns>For points this is just the same point</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.Relate(MapWinGeoProc.Topology2D.Geometry,System.String)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <param name="IntersectionPatternMatrix"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.Buffer(System.Double)">
            <summary>
            Returns a Polygon with the buffer distance with an assumed value of 8 for the number of points.
            </summary>
            <param name="Distance">The Radius representing the buffer distance around the point.</param>
            <returns>A Geometry.  Returns a Polygon unless Distance = 0, in which case it returns a copy of this point.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.Buffer(System.Double,System.Int32)">
            <summary>
            Returns a polygonal circle of Radius around this point.
            </summary>
            <param name="Distance">The distance in map units of the radius of the buffer</param>
            <param name="numPoints">Controls the number of points used to create the circle. 
            More points will be smoother.  Requires at least 3 points to be a valid polygon.</param>
            <returns>Topology2D.Polygon representing a circle of radius r.
            Or a copy of this Topology2D.Point if the Radius is 0</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.ConvexHull">
            <summary>
            This is undefined for points, so this will return a null value.
            </summary>
            <returns>null</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.Difference(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented 
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.Distance(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Finds the shortest distance between this point and the specified geometry.
            </summary>
            <param name="geom">Any geometry that you wish to find the shortest path to.</param>
            <returns>Double, the distance of the shortest path between this object and the specified geometry.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.Intersection(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            This can either be null, if there is no intersection, or this point, if
            there is an intersection.
            </summary>
            <param name="geom">Any geometry.</param>
            <returns>A Point showing the location of the intersection.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.SymDifference(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            The symetrical difference has no meaning for points, so this will always return null.
            </summary>
            <param name="geom">Any geometry</param>
            <returns>Null</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.ToString">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.ToCoordinate">
            <summary>
            Creates a new Coordinate from this point
            </summary>
            <returns>A Coordinate</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.Union(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.Copy">
            <summary>
            Returns a new instance of the Topology2D.Point class with the same values as this object.
            </summary>
            <returns>Point with identical properties.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.Equals(System.Object)">
            <summary>
            This is for the generic object case
            </summary>
            <param name="obV">Any object to compare with this object, but if the object isn't a point they will not be equal</param>
            <returns>Boolean, true if the object is a point and the two points have the same location.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.GetHashCode">
            <summary>
            Returns a hash code, whatever that is.
            </summary>
            <returns>A hash code.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.ClosestPointOn(MapWinGeoProc.Topology2D.LineSegment)">
            <summary>
            Returns a Point corresponding to the closest point on LineSegment Seg to this point
            </summary>
            <param name="Seg">Returns the closest point on Seg to this point</param>
            <returns>A Point representing the closest location on Seg to this point</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.IsWithinADistanceOf(MapWinGeoProc.Topology2D.Point,System.Double)">
            <summary>
            Tests a point to determine if it is within the specified distance to this 
            point.
            </summary>
            <param name="Pnt">A Point to test against this point.</param>
            <param name="Dist">The distance to check against inclusive.</param>
            <returns>Boolean, true if the point is within the specified distance.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.IsWithinADistanceOf(MapWinGeoProc.Topology2D.LineSegment,System.Double)">
            <summary>
            Tests a segment to determine if it is within the specified distance to this point.
            </summary>
            <param name="Seg">A segment to test agianst this point.</param>
            <param name="Dist">The distance to return.</param>
            <returns>Returns true if any part of the specified segment is closer than Distance.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.To_mwPoint">
            <summary>
            Creates a MapWinGIS.Point from this point.
            </summary>
            <returns>A MapWinGIS.Point with the same X, Y and Z values</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.ToVector">
            <summary>
            Converts the point into a vector by assuming that the tail of the vector is the 
            origin (0,0,0)
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.TouchesTheBoundaryOf(MapWinGeoProc.Topology2D.Polygon)">
            <summary>
            Indicates that the point specifically lies on the boundary of the polygon,
            and is not contained by the polygon.  This only applies to area features,
            for line or point features use Intersect.
            </summary>
            <param name="Pgn">the Polygon to test the boundaries of.</param>
            <returns>True if the point lies exactly on the boundary of the polygon.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.TouchesTheBoundaryOf(MapWinGeoProc.Topology2D.Envelope)">
            <summary>
            Checks to see if this point lies on the boundaries of the extents specified.
            </summary>
            <param name="Ext">The extents to compare with.</param>
            <returns>True if the point lies anywhere on the boundaries of the extents.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.ShortestPathTo(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Determines the shortest path to the specified geometry.  Returns a line segment with
            this Point as the startpoint and the closest point on the specified geometry as the
            endpoint.  Will return null if this point intersects with the specified geometry.
            </summary>
            <param name="geom">Line Segment</param>
            <returns>The shortest LineSegment from this point to the specified geometry.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.op_Equality(MapWinGeoProc.Topology2D.Point,System.Object)">
            <summary>
            Returns true if X and Y coordinates are equal
            </summary>
            <param name="U">A Point to compare</param>
            <param name="objV">Any object to compare with the point</param>
            <returns>Boolean, true if the vectors are the same</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Point.op_Inequality(MapWinGeoProc.Topology2D.Point,System.Object)">
            <summary>
            Returns true if X and Y coordinates are different
            </summary>
            <param name="U">A Point to compare</param>
            <param name="objV">An object to compare</param>
            <returns>Boolean, true if the vectors are the different</returns>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.Point.Dimension">
            <summary>
            Points are 0 dimensional.  This may help determine the dimensionality if you don't 
            know what type of geometry you are working with.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Toolbox.Toolbox">
            <summary>
            Instead of a plugin interface being required, this extends the ocx capabilities
            to allow some activities that normally would only work through a plugin
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Toolbox.Toolbox.#ctor(AxMapWinGIS.AxMap)">
            <summary>
            Creates a new toolbox that is tuned to a specific ActiveX Map
            </summary>
            <param name="Map">This specifies an ActiveX Map for the tools to work on.</param>
        </member>
        <member name="M:MapWinGeoProc.Toolbox.Toolbox.Buffer">
            <summary>
            This is specifically designed
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Toolbox.Toolbox.Union">
            <summary>
            Launches a GeoProcDialog with Union Options for a Non-Static instance
            </summary>
        </member>
        <member name="T:Iesi.Collections.Generic.ListWrapper`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Iesi.Collections.Generic.EnumerableWrapper`1">
            <summary>
            A Simple Wrapper for wrapping an regular Enumerable as a generic Enumberable
            </summary>
            <typeparam name="T"></typeparam>
            <exception cref="T:System.InvalidCastException">
            If the wrapped has any item that is not of Type T, InvalidCastException could be thrown at any time
            </exception>
        </member>
        <member name="M:Iesi.Collections.Generic.EnumerableWrapper`1.#ctor(System.Collections.IEnumerable)">
            <summary>
            
            </summary>
            <param name="innerEnumerable"></param>
        </member>
        <member name="M:Iesi.Collections.Generic.EnumerableWrapper`1.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.EnumerableWrapper`1.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.EnumerableWrapper`1.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ListWrapper`1.#ctor(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="toWrapp"></param>
        </member>
        <member name="M:Iesi.Collections.Generic.ListWrapper`1.IndexOf(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ListWrapper`1.Insert(System.Int32,`0)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:Iesi.Collections.Generic.ListWrapper`1.RemoveAt(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Iesi.Collections.Generic.ListWrapper`1.Add(`0)">
            <summary>
            Add a new item to the collection
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Iesi.Collections.Generic.ListWrapper`1.Clear">
            <summary>
            Clear the items in this list
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.ListWrapper`1.Contains(`0)">
            <summary>
            Determine if an item is contained in the list
            </summary>
            <param name="item">The item to find</param>
            <returns>Boolean, true if the item is already a member of the list</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ListWrapper`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies an array of items to this list
            </summary>
            <param name="array">An array of items to add</param>
            <param name="arrayIndex">an array Index</param>
        </member>
        <member name="M:Iesi.Collections.Generic.ListWrapper`1.Remove(`0)">
            <summary>
            Removes an item from the list
            </summary>
            <param name="item">the item to remove</param>
            <returns>Boolean, true if the item was removed</returns>
        </member>
        <member name="P:Iesi.Collections.Generic.ListWrapper`1.Item(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:Iesi.Collections.Generic.ListWrapper`1.Count">
            <summary>
            Number of members in the list
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.ListWrapper`1.IsReadOnly">
            <summary>
            Boolean, true if the inner list is read only
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Planargraph.Edge">
            <summary>
            Represents an undirected edge of a {PlanarGraph}. An undirected edge
            in fact simply acts as a central point of reference for two opposite
            <c>DirectedEdge</c>s.
            Usually a client using a <c>PlanarGraph</c> will subclass <c>Edge</c>
            to add its own application-specific data and methods.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Planargraph.GraphComponent">
            <summary>
            The base class for all graph component classes.
            Maintains flags of use in generic graph algorithms.
            Provides two flags:
            marked - typically this is used to indicate a state that persists
            for the course of the graph's lifetime.  For instance, it can be
            used to indicate that a component has been logically deleted from the graph.
            visited - this is used to indicate that a component has been processed
            or visited by an single graph algorithm.  For instance, a breadth-first traversal of the
            graph might use this to indicate that a node has already been traversed.
            The visited flag may be set and cleared many times during the lifetime of a graph.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.GraphComponent.SetVisited(System.Collections.IEnumerator,System.Boolean)">
            <summary>
            Sets the <see cref="P:MapWinGeoProc.NTS.Topology.Planargraph.GraphComponent.Visited"/> state 
            for all <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.GraphComponent"/>s in an <see cref="T:System.Collections.IEnumerator"/>.
            </summary>
            <param name="i">A <see cref="T:System.Collections.IEnumerator"/> to scan.</param>
            <param name="visited">The state to set the <see cref="P:MapWinGeoProc.NTS.Topology.Planargraph.GraphComponent.Visited"/> flag to.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.GraphComponent.SetMarked(System.Collections.IEnumerator,System.Boolean)">
            <summary>
            Sets the <see cref="P:MapWinGeoProc.NTS.Topology.Planargraph.GraphComponent.Marked"/> state 
            for all <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.GraphComponent"/>s in an <see cref="T:System.Collections.IEnumerator"/>.
            </summary>
            <param name="i">A <see cref="T:System.Collections.IEnumerator"/> to scan.</param>
            <param name="marked">The state to set the <see cref="P:MapWinGeoProc.NTS.Topology.Planargraph.GraphComponent.Marked"/> flag to.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.GraphComponent.GetComponentWithVisitedState(System.Collections.IEnumerator,System.Boolean)">
            <summary>
            Finds the first <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.GraphComponent"/> 
            in a <see cref="T:System.Collections.IEnumerator"/> set
            which has the specified <see cref="P:MapWinGeoProc.NTS.Topology.Planargraph.GraphComponent.Visited"/> state.
            </summary>
            <param name="i">A <see cref="T:System.Collections.IEnumerator"/> to scan.</param>
            <param name="visitedState">The <see cref="P:MapWinGeoProc.NTS.Topology.Planargraph.GraphComponent.Visited"/> state to test.</param>
            <returns>The first <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.GraphComponent"/> found, or <c>null</c> if none found.</returns>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Planargraph.GraphComponent.isMarked">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Planargraph.GraphComponent.isVisited">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.GraphComponent.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GraphComponent"/> class.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.GraphComponent.IsVisited">
            <summary>
            Tests if a component has been visited during the course of a graph algorithm.
            </summary>              
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.GraphComponent.Visited">
            <summary> 
            Gets/Sets the visited flag for this component.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.GraphComponent.IsMarked">
            <summary>
            Tests if a component has been marked at some point during the processing
            involving this graph.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.GraphComponent.Marked">
            <summary>
            Gets/Sets the marked flag for this component.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.GraphComponent.IsRemoved">
            <summary>
            Tests whether this component has been removed from its containing graph.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Planargraph.Edge.dirEdge">
            <summary>
            The two DirectedEdges associated with this Edge. 
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Edge.#ctor">
            <summary>
            Constructs an Edge whose DirectedEdges are not yet set. Be sure to call
            <c>SetDirectedEdges(DirectedEdge, DirectedEdge)</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Edge.#ctor(MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge,MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge)">
            <summary>
            Constructs an Edge initialized with the given DirectedEdges, and for each
            DirectedEdge: sets the Edge, sets the symmetric DirectedEdge, and adds
            this Edge to its from-Node.
            </summary>
            <param name="de0"></param>
            <param name="de1"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Edge.SetDirectedEdges(MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge,MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge)">
            <summary>
            Initializes this Edge's two DirectedEdges, and for each DirectedEdge: sets the
            Edge, sets the symmetric DirectedEdge, and adds this Edge to its from-Node.
            </summary>
            <param name="de0"></param>
            <param name="de1"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Edge.GetDirEdge(System.Int32)">
            <summary> 
            Returns one of the DirectedEdges associated with this Edge.
            </summary>
            <param name="i">0 or 1.</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Edge.GetDirEdge(MapWinGeoProc.NTS.Topology.Planargraph.Node)">
            <summary>
            Returns the DirectedEdge that starts from the given node, or null if the
            node is not one of the two nodes associated with this Edge.
            </summary>
            <param name="fromNode"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Edge.GetOppositeNode(MapWinGeoProc.NTS.Topology.Planargraph.Node)">
            <summary> 
            If <c>node</c> is one of the two nodes associated with this Edge,
            returns the other node; otherwise returns null.
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Edge.Remove">
            <summary>
            Removes this edge from its containing graph.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.Edge.IsRemoved">
            <summary>
            Tests whether this component has been removed from its containing graph.
            </summary>
            <value></value>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Predicate.SegmentIntersectionTester">
            <summary>
            Tests if any line segments in two sets of CoordinateSequences intersect.
            Optimized for small geometry size.
            Short-circuited to return as soon an intersection is found.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.SegmentIntersectionTester.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.SegmentIntersectionTester.HasIntersectionWithLineStrings(MapWindow.Interfaces.Geometries.ICoordinateSequence,System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="seq"></param>
            <param name="lines"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.SegmentIntersectionTester.HasIntersection(MapWindow.Interfaces.Geometries.ICoordinateSequence,MapWindow.Interfaces.Geometries.ICoordinateSequence)">
            <summary>
            
            </summary>
            <param name="seq0"></param>
            <param name="seq1"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Overlay.PointBuilder">
            <summary>
            Constructs <c>Point</c>s from the nodes of an overlay graph.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.PointBuilder.#ctor(MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp,MapWindow.Interfaces.Geometries.IGeometryFactory,MapWinGeoProc.NTS.Topology.Algorithm.PointLocator)">
            <summary>
            
            </summary>
            <param name="op"></param>
            <param name="geometryFactory"></param>
            <param name="ptLocator"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.PointBuilder.Build(MapWinGeoProc.NTS.Topology.Operation.Overlay.SpatialFunctions)">
            <summary>
            
            </summary>
            <param name="opCode"></param>
            <returns>
            A list of the Points in the result of the specified overlay operation.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.PointBuilder.CollectNodes(MapWinGeoProc.NTS.Topology.Operation.Overlay.SpatialFunctions)">
            <summary>
            
            </summary>
            <param name="opCode"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.PointBuilder.SimplifyPoints(System.Collections.IList)">
            <summary>
            This method simplifies the resultant Geometry by finding and eliminating
            "covered" points.
            A point is covered if it is contained in another element Geometry
            with higher dimension (e.g. a point might be contained in a polygon,
            in which case the point can be eliminated from the resultant).
            </summary>
            <param name="resultNodeList"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.Snapround.SimpleSnapRounder">
            <summary>
            Uses Snap Rounding to compute a rounded,
            fully noded arrangement from a set of <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s.
            Implements the Snap Rounding technique described in Hobby, Guibas and Marimont, and Goodrich et al.
            Snap Rounding assumes that all vertices lie on a uniform grid
            (hence the precision model of the input must be fixed precision,
            and all the input vertices must be rounded to that precision).
            <para>
            This implementation uses simple iteration over the line segments.
            This implementation appears to be fully robust using an integer precision model.
            It will function with non-integer precision models, but the
            results are not 100% guaranteed to be correctly noded.
            </para>
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.INoder">
            <summary>
            Computes all intersections between segments in a set of <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s.
            Intersections found are represented as <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentNode"/>s and added to the
            <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s in which they occur.
            As a final step in the noding a new set of segment strings split at the nodes may be returned.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.INoder.ComputeNodes(System.Collections.IList)">
            <summary>
            Computes the noding for a collection of <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s.
            Some Noders may add all these nodes to the input <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s;
            others may only add some or none at all.
            </summary>
            <param name="segStrings"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.INoder.GetNodedSubstrings">
            <summary>
            Returns a <see cref="T:System.Collections.IList"/> of fully noded <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s.
            The <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s have the same context as their parent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.SimpleSnapRounder.#ctor(MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel)">
            <summary>
            Initializes a new instance of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.Snapround.SimpleSnapRounder"/> class.
            </summary>
            <param name="pm">The <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel"/> to use.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.SimpleSnapRounder.GetNodedSubstrings">
            <summary>
            Returns a <see cref="T:System.Collections.IList"/> of fully noded <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s.
            The <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s have the same context as their parent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.SimpleSnapRounder.ComputeNodes(System.Collections.IList)">
            <summary>
            Computes the noding for a collection of <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s.
            Some Noders may add all these nodes to the input <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s;
            others may only add some or none at all.
            </summary>
            <param name="inputSegmentStrings"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.SimpleSnapRounder.CheckCorrectness(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="inputSegmentStrings"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.SimpleSnapRounder.SnapRound(System.Collections.IList,MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector)">
            <summary>
            
            </summary>
            <param name="segStrings"></param>
            <param name="li"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.SimpleSnapRounder.FindInteriorIntersections(System.Collections.IList,MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector)">
            <summary>
            Computes all interior intersections in the collection of <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s,
            and returns their <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/>s.
            Does NOT node the segStrings.
            </summary>
            <param name="segStrings"></param>
            <param name="li"></param>
            <returns>A list of <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/>s for the intersections.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.SimpleSnapRounder.ComputeSnaps(System.Collections.IList,System.Collections.IList)">
            <summary>
            Computes nodes introduced as a result of snapping segments to snap points (hot pixels).
            </summary>
            <param name="segStrings"></param>
            <param name="snapPts"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.SimpleSnapRounder.ComputeSnaps(MapWinGeoProc.NTS.Topology.Noding.SegmentString,System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="ss"></param>
            <param name="snapPts"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.SimpleSnapRounder.ComputeVertexSnaps(System.Collections.IList)">
            <summary>
            Computes nodes introduced as a result of
            snapping segments to vertices of other segments.
            </summary>
            <param name="edges"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.SimpleSnapRounder.ComputeVertexSnaps(MapWinGeoProc.NTS.Topology.Noding.SegmentString,MapWinGeoProc.NTS.Topology.Noding.SegmentString)">
            <summary>
            Performs a brute-force comparison of every segment in each <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>.
            This has n^2 performance.
            </summary>
            <param name="e0"></param>
            <param name="e1"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.SimpleSnapRounder.AddSnappedNode(MapWinGeoProc.NTS.Topology.Noding.Snapround.HotPixel,MapWinGeoProc.NTS.Topology.Noding.SegmentString,System.Int32)">
            <summary>
            Adds a new node (equal to the snap pt) to the segment
            if the segment passes through the hot pixel.
            </summary>
            <param name="hotPix"></param>
            <param name="segStr"></param>
            <param name="segIndex"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.WKBWriter">
            <summary>
            Writes a Well-Known Binary byte data representation of a <c>Geometry</c>.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.IO.WKBWriter.InitCount">
            <summary>
            Standard byte size for each complex point.
            Each complex point (LineString, Polygon, ...) contains:
                1 byte for ByteOrder and
                4 bytes for WKBType.      
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.#ctor">
            <summary>
            Initializes writer with LittleIndian byte order.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.#ctor(MapWinGeoProc.NTS.Topology.IO.ByteOrder)">
            <summary>
            Initializes writer with the specified byte order.
            </summary>
            <param name="encodingType">Encoding type</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.Write(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Writes a WKB representation of a given point.
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.Write(MapWindow.Interfaces.Geometries.IGeometry,System.IO.Stream)">
            <summary>
            Writes a WKB representation of a given point.
            </summary>
            <param name="geometry"></param>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.Write(MapWindow.Interfaces.Geometries.IGeometry,System.IO.BinaryWriter)">
            <summary>
            
            </summary>
            <param name="geometry"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.WriteByteOrder(System.IO.BinaryWriter)">
            <summary>
            Writes LittleIndian ByteOrder.
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.Write(MapWindow.Interfaces.Geometries.IPoint,System.IO.BinaryWriter)">
            <summary>
            
            </summary>
            <param name="point"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.Write(MapWinGeoProc.NTS.Topology.Geometries.LineString,System.IO.BinaryWriter)">
            <summary>
            
            </summary>
            <param name="lineString"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.Write(MapWindow.Interfaces.Geometries.IPolygon,System.IO.BinaryWriter)">
            <summary>
            
            </summary>
            <param name="polygon"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.Write(MapWindow.Interfaces.Geometries.IMultiPoint,System.IO.BinaryWriter)">
            <summary>
            
            </summary>
            <param name="multiPoint"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.Write(MapWindow.Interfaces.Geometries.IMultiLineString,System.IO.BinaryWriter)">
            <summary>
            
            </summary>
            <param name="multiLineString"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.Write(MapWindow.Interfaces.Geometries.IMultiPolygon,System.IO.BinaryWriter)">
            <summary>
            
            </summary>
            <param name="multiPolygon"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.Write(MapWindow.Interfaces.Geometries.IGeometryCollection,System.IO.BinaryWriter)">
            <summary>
            
            </summary>
            <param name="geomCollection"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.Write(MapWindow.Interfaces.Geometries.ICoordinate,System.IO.BinaryWriter)">
            <summary>
            
            </summary>
            <param name="coordinate"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.Write(MapWindow.Interfaces.Geometries.ILinearRing,System.IO.BinaryWriter)">
            <summary>
            
            </summary>
            <param name="ring"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.GetBytes(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Sets corrent length for Byte Stream.
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.SetByteStream(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Sets corrent length for Byte Stream.
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.SetByteStream(MapWindow.Interfaces.Geometries.IGeometryCollection)">
            <summary>
            
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.SetByteStream(MapWindow.Interfaces.Geometries.IMultiPolygon)">
            <summary>
            
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.SetByteStream(MapWindow.Interfaces.Geometries.IMultiLineString)">
            <summary>
            
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.SetByteStream(MapWindow.Interfaces.Geometries.IMultiPoint)">
            <summary>
            
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.SetByteStream(MapWindow.Interfaces.Geometries.IPolygon)">
            <summary>
            
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.SetByteStream(MapWindow.Interfaces.Geometries.ILineString)">
            <summary>
            
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBWriter.SetByteStream(MapWindow.Interfaces.Geometries.IPoint)">
            <summary>
            
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.ShapeWriter">
            <summary>
            Contains methods for writing a single <c>Geometry</c> in binary ESRI shapefile format.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.IO.ShapeWriter.InitCount">
            <summary>
            Standard byte size for each complex point.
            Each complex point (LineString, Polygon, ...) contains
                4 bytes for ShapeTypes and
                32 bytes for Boundingbox.      
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeWriter.#ctor">
            <summary> 
            Creates a <coordinate>ShapeWriter</coordinate> that creates objects using a basic GeometryFactory.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeWriter.Write(MapWindow.Interfaces.Geometries.ICoordinate,System.IO.BinaryWriter)">
            <summary>
            
            </summary>
            <param name="coordinate"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeWriter.Write(MapWinGeoProc.NTS.Topology.Geometries.Point,System.IO.BinaryWriter)">
            <summary>
            
            </summary>
            <param name="point"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeWriter.Write(MapWinGeoProc.NTS.Topology.Geometries.LineString,System.IO.BinaryWriter)">
            <summary>
            
            </summary>
            <param name="lineString"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeWriter.Write(MapWinGeoProc.NTS.Topology.Geometries.Polygon,System.IO.BinaryWriter)">
            <summary>
            
            </summary>
            <param name="polygon"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeWriter.Write(MapWinGeoProc.NTS.Topology.Geometries.MultiPoint,System.IO.BinaryWriter)">
            <summary>
            
            </summary>
            <param name="multiPoint"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeWriter.Write(MapWinGeoProc.NTS.Topology.Geometries.MultiLineString,System.IO.BinaryWriter)">
            <summary>
            
            </summary>
            <param name="multiLineString"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeWriter.Write(MapWinGeoProc.NTS.Topology.Geometries.MultiPolygon,System.IO.BinaryWriter)">
            <summary>
            
            </summary>
            <param name="multiPolygon"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeWriter.WriteBoundingBox(MapWindow.Interfaces.Geometries.IGeometry,System.IO.BinaryWriter)">
            <summary>
            
            </summary>
            <param name="geometry"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeWriter.GetBytes(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Sets correct length for Byte Stream.
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeWriter.GetBytesLength(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Return correct length for Byte Stream.
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeWriter.SetByteStreamLength(MapWinGeoProc.NTS.Topology.Geometries.MultiPolygon)">
            <summary>
            
            </summary>
            <param name="multiPolygon"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeWriter.SetByteStreamLength(MapWinGeoProc.NTS.Topology.Geometries.MultiLineString)">
            <summary>
            
            </summary>
            <param name="multiLineString"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeWriter.SetByteStreamLength(MapWinGeoProc.NTS.Topology.Geometries.MultiPoint)">
            <summary>
            
            </summary>
            <param name="multiPoint"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeWriter.SetByteStreamLength(MapWinGeoProc.NTS.Topology.Geometries.Polygon)">
            <summary>
            
            </summary>
            <param name="polygon"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeWriter.SetByteStreamLength(MapWinGeoProc.NTS.Topology.Geometries.LineString)">
            <summary>
            
            </summary>
            <param name="lineString"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeWriter.SetByteStreamLength(MapWinGeoProc.NTS.Topology.Geometries.Point)">
            <summary>
            
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeWriter.CalculateLength(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="numParts"></param>
            <param name="numPoints"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.ShapeReader">
            <summary>
            Contains methods for reading a single <c>Geometry</c> in binary ESRI shapefile format.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.IO.ShapeReader.factory">
            <summary>
            Geometry creator.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeReader.#ctor">
            <summary>
            Initialize reader with a standard <c>GeometryFactory</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeReader.#ctor(MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory)">
            <summary>
            Initialize reader with the given <c>GeometryFactory</c>.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeReader.ReadPoint(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeReader.ReadLineString(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeReader.ReadPolygon(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeReader.ReadMultiPoint(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeReader.CreatePoint(MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            
            </summary>
            <param name="coordinate"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeReader.CreateLineString(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[])">
            <summary>
            Creates a single LineString.
            </summary>
            <param name="coords"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeReader.CreateMultiLineString(System.Int32,System.Int32[],MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Creates a MultiLineString.
            </summary>
            <param name="numPoints"></param>
            <param name="indexParts"></param>
            <param name="coords"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeReader.CreateSingleOrMultiPolygon(System.Int32,System.Int32[],MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Creates a single Polygon with holes.
            </summary>
            <param name="numPoints"></param>
            <param name="indexParts"></param>
            <param name="coords"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeReader.CreateSimpleSinglePolygon(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[])">
            <summary>
            Creates a single Polygon without holes.
            </summary>
            <param name="coords"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeReader.CreateMultiPoint(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[])">
            <summary>
            Creates a MultiPoint.
            </summary>
            <param name="coords"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeReader.ReadBoundingBox(System.IO.BinaryReader)">
            <summary>
            Jump values for VeDEx BoundingBox
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeReader.ReadNumParts(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeReader.ReadNumPoints(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeReader.ReadIndexParts(System.IO.BinaryReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <param name="numParts"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeReader.ReadCoordinates(System.IO.BinaryReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <param name="numPoints"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeReader.ReadCoordinate(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeReader.CreateGeometryCollection(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ShapeReader.Factory">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.PointHandler">
            <summary>
            Converts a Shapefile point to a OGIS Point.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.ShapeHandler">
            <summary>
            Abstract class that defines the interfaces that other 'Shape' handlers must implement.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeHandler.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeHandler.Read(MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryReader,MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            Reads a stream and converts the shapefile record to an equilivent geometry object.
            </summary>
            <param name="file">The stream to read.</param>
            <param name="geometryFactory">The geometry factory to use when making the object.</param>
            <returns>The Geometry object that represents the shape file record.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeHandler.Write(MapWindow.Interfaces.Geometries.IGeometry,System.IO.BinaryWriter,MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            Writes to the given stream the equilivent shape file record given a Geometry object.
            </summary>
            <param name="geometry">The geometry object to write.</param>
            <param name="file">The stream to write to.</param>
            <param name="geometryFactory">The geometry factory to use.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeHandler.GetLength(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Gets the length in bytes the Geometry will need when written as a shape file record.
            </summary>
            <param name="geometry">The Geometry object to use.</param>
            <returns>The length in 16bit words the Geometry will use when represented as a shape file record.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapeHandler.GetEnvelopeExternal(MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel,MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            Get Envelope in external coordinates.
            </summary>
            <param name="precisionModel"></param>
            <param name="envelope"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ShapeHandler.ShapeType">
            <summary>
            Returns the ShapeType the handler handles.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.PointHandler.#ctor">
            <summary>
            Initializes a new instance of the PointHandler class.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.PointHandler.Read(MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryReader,MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            Reads a stream and converts the shapefile record to an equilivent geometry object.
            </summary>
            <param name="file">The stream to read.</param>
            <param name="geometryFactory">The geometry factory to use when making the object.</param>
            <returns>The Geometry object that represents the shape file record.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.PointHandler.Write(MapWindow.Interfaces.Geometries.IGeometry,System.IO.BinaryWriter,MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            Writes to the given stream the equilivent shape file record given a Geometry object.
            </summary>
            <param name="geometry">The geometry object to write.</param>
            <param name="file">The stream to write to.</param>
            <param name="geometryFactory">The geometry factory to use.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.PointHandler.GetLength(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Gets the length in bytes the Geometry will need when written as a shape file record.
            </summary>
            <param name="geometry">The Geometry object to use.</param>
            <returns>The length in bytes the Geometry will use when represented as a shape file record.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.PointHandler.ShapeType">
            <summary>
            The shape type this handler handles (point).
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.WktStreamTokenizer">
            <summary>
            Reads a stream of Well Known Text (wkt) string and returns a stream of tokens.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.IO.StreamTokenizer">
            <summary>
            The StreamTokenizer class takes an input stream and parses it into "tokens", allowing the tokens to be read one at a time. The parsing process is controlled by a table and a number of flags that can be set to various states. The stream tokenizer can recognize identifiers, numbers, quoted strings, and various comment style
            </summary>
            <remarks>
            This is a crude c# implementation of Java's <a href="http://java.sun.com/products/jdk/1.2/docs/api/java/io/StreamTokenizer.html">StreamTokenizer</a> class.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.IO.StreamTokenizer.#ctor(System.IO.TextReader,System.Boolean)">
            <summary>
            Initializes a new instance of the StreamTokenizer class.
            </summary>
            <param name="reader">A TextReader with some text to read.</param>
            <param name="ignoreWhitespace">Flag indicating whether whitespace should be ignored.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.IO.StreamTokenizer.GetNumericValue">
            <summary>
            If the current token is a number, this field contains the value of that number. 
            </summary>
            <remarks>
            If the current token is a number, this field contains the value of that number. The current token is a number when the value of the ttype field is TT_NUMBER.
            </remarks>
            <exception cref="T:System.FormatException">Current token is not a number in a valid format.</exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.IO.StreamTokenizer.GetStringValue">
            <summary>
            If the current token is a word token, this field contains a string giving the characters of the word token. 
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.IO.StreamTokenizer.GetTokenType">
            <summary>
            Gets the token type of the current token.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.IO.StreamTokenizer.NextToken(System.Boolean)">
            <summary>
            Returns the next token.
            </summary>
            <param name="ignoreWhitespace">Determines is whitespace is ignored. True if whitespace is to be ignored.</param>
            <returns>The TokenType of the next token.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.IO.StreamTokenizer.NextToken">
            <summary>
            Returns the next token.
            </summary>
            <returns>The TokenType of the next token.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.IO.StreamTokenizer.GetType(System.Char)">
            <summary>
            Determines a characters type (e.g. number, symbols, character).
            </summary>
            <param name="character">The character to determine.</param>
            <returns>The TokenType the character is.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.IO.StreamTokenizer.NextNonWhitespaceToken">
            <summary>
            Returns next token that is not whitespace.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.IO.StreamTokenizer.LineNumber">
            <summary>
            The current line number of the stream being read.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.IO.StreamTokenizer.Column">
            <summary>
            The current column number of the stream being read.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.WktStreamTokenizer.#ctor(System.IO.TextReader)">
            <summary>
            Initializes a new instance of the WktStreamTokenizer class.
            </summary>
            <remarks>The WktStreamTokenizer class ais in reading WKT streams.</remarks>
            <param name="reader">A TextReader that contains </param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.WktStreamTokenizer.ReadToken(System.String)">
            <summary>
            Reads a token and checks it is what is expected.
            </summary>
            <param name="expectedToken">The expected token.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.WktStreamTokenizer.ReadDoubleQuotedWord">
            <summary>
            Reads a string inside double quotes.
            </summary>
            <remarks>
            White space inside quotes is preserved.
            </remarks>
            <returns>The string inside the double quotes.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.WktStreamTokenizer.ReadAuthority(System.String@,System.Int64@)">
            <summary>
            Reads the authority and authority code.
            </summary>
            <param name="authority">String to place the authority in.</param>
            <param name="authorityCode">String to place the authority code in.</param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Bintree.Bintree">
            <summary>
            An <c>BinTree</c> (or "Binary Interval Tree")
            is a 1-dimensional version of a quadtree.
            It indexes 1-dimensional intervals (which of course may
            be the projection of 2-D objects on an axis).
            It supports range searching
            (where the range may be a single point).
            This implementation does not require specifying the extent of the inserted
            items beforehand.  It will automatically expand to accomodate any extent
            of dataset.
            This index is different to the Interval Tree of Edelsbrunner
            or the Segment Tree of Bentley.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Bintree.EnsureExtent(MapWinGeoProc.NTS.Topology.Index.Bintree.Interval,System.Double)">
            <summary>
            Ensure that the Interval for the inserted item has non-zero extents.
            Use the current minExtent to pad it, if necessary.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Bintree.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Bintree.Insert(MapWinGeoProc.NTS.Topology.Index.Bintree.Interval,System.Object)">
            <summary>
            
            </summary>
            <param name="itemInterval"></param>
            <param name="item"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Bintree.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Bintree.Query(System.Double)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Bintree.Query(MapWinGeoProc.NTS.Topology.Index.Bintree.Interval)">
            <summary>
            min and max may be the same value.
            </summary>
            <param name="interval"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Bintree.Query(MapWinGeoProc.NTS.Topology.Index.Bintree.Interval,System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="interval"></param>
            <param name="foundItems"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Bintree.CollectStats(MapWinGeoProc.NTS.Topology.Index.Bintree.Interval)">
            <summary>
            
            </summary>
            <param name="interval"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Bintree.Bintree.Depth">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Bintree.Bintree.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Bintree.Bintree.NodeSize">
            <summary>
            Compute the total number of nodes in the tree.
            </summary>
            <returns>The number of nodes in the tree.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.Utilities.PolygonExtracter">
            <summary> 
            Extracts all the 2-dimensional (<c>Polygon</c>) components from a <c>Geometry</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.PolygonExtracter.GetPolygons(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary> 
            Returns the Polygon components from a single point.
            If more than one point is to be processed, it is more
            efficient to create a single <c>PolygonExtracterFilter</c> instance
            and pass it to multiple geometries.
            </summary>
            <param name="geom"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.PolygonExtracter.#ctor(System.Collections.IList)">
            <summary> 
            Constructs a PolygonExtracterFilter with a list in which to store Polygons found.
            </summary>
            <param name="comps"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.PolygonExtracter.Filter(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation">
            <summary> 
            A TopologyLocation is the labelling of a
            GraphComponent's topological relationship to a single Geometry.
            If the parent component is an area edge, each side and the edge itself
            have a topological location.  These locations are named:
             On: on the edge
             Left: left-hand side of the edge
             Right: right-hand side
            If the parent component is a line edge or node, there is a single
            topological relationship attribute, On.
            The possible values of a topological location are
            { Location.Null, Location.Exterior, Location.Boundary, Location.Interior } 
            The labelling is stored in an array location[j] where
            where j has the values On, Left, Right.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.#ctor(MapWindow.Interfaces.Geometries.Locations[])">
            <summary>
            
            </summary>
            <param name="location"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.#ctor(MapWindow.Interfaces.Geometries.Locations,MapWindow.Interfaces.Geometries.Locations,MapWindow.Interfaces.Geometries.Locations)">
            <summary> 
            Constructs a TopologyLocation specifying how points on, to the left of, and to the
            right of some GraphComponent relate to some Geometry. Possible values for the
            parameters are Location.Null, Location.Exterior, Location.Boundary, 
            and Location.Interior.
            </summary>        
            <param name="on"></param>
            <param name="left"></param>
            <param name="right"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.#ctor(MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            
            </summary>
            <param name="on"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation)">
            <summary>
            
            </summary>
            <param name="gl"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.Init(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.Get(MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions)">
            <summary>
            
            </summary>
            <param name="posIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.IsEqualOnSide(MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation,System.Int32)">
            <summary>
            
            </summary>
            <param name="le"></param>
            <param name="locIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.Flip">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.SetAllLocations(MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            
            </summary>
            <param name="locValue"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.SetAllLocationsIfNull(MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            
            </summary>
            <param name="locValue"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.SetLocation(MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions,MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            
            </summary>
            <param name="locIndex"></param>
            <param name="locValue"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.SetLocation(MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            
            </summary>
            <param name="locValue"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.GetLocations">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.SetLocations(MapWindow.Interfaces.Geometries.Locations,MapWindow.Interfaces.Geometries.Locations,MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            
            </summary>
            <param name="on"></param>
            <param name="left"></param>
            <param name="right"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.SetLocations(MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation)">
            <summary>
            
            </summary>
            <param name="gl"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.AllPositionsEqual(MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            
            </summary>
            <param name="loc"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.Merge(MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation)">
            <summary>
            Merge updates only the Null attributes of this object
            with the attributes of another.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.Item(MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions)">
            <summary>
            Get calls Get(Positions posIndex),
            Set calls SetLocation(Positions locIndex, Locations locValue)
            </summary>
            <param name="posIndex"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.IsNull">
            <returns>
            <c>true</c> if all locations are Null.
            </returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.IsAnyNull">
            <returns> 
            <c>true</c> if any locations are Null.
            </returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.IsArea">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation.IsLine">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label">
            <summary> 
            A <c>Label</c> indicates the topological relationship of a component
            of a topology graph to a given <c>Geometry</c>.
            This class supports labels for relationships to two <c>Geometry</c>s,
            which is sufficient for algorithms for binary operations.
            Topology graphs support the concept of labeling nodes and edges in the graph.
            The label of a node or edge specifies its topological relationship to one or
            more geometries.  (In fact, since NTS operations have only two arguments labels
            are required for only two geometries).  A label for a node or edge has one or
            two elements, depending on whether the node or edge occurs in one or both of the
            input <c>Geometry</c>s.  Elements contain attributes which categorize the
            topological location of the node or edge relative to the parent
            <c>Geometry</c>; that is, whether the node or edge is in the interior,
            boundary or exterior of the <c>Geometry</c>.  Attributes have a value
            from the set <c>{Interior, Boundary, Exterior}</c>.  In a node each
            element has a single attribute <c>On</c>. For an edge each element has a
            triplet of attributes <c>Left, On, Right</c>.
            It is up to the client code to associate the 0 and 1 <c>TopologyLocation</c>s
            with specific geometries.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.ToLineLabel(MapWinGeoProc.NTS.Topology.GeometriesGraph.Label)">
            <summary>
            Converts a Label to a Line label (that is, one with no side Locations).
            </summary>
            <param name="label">Label to convert.</param>
            <returns>Label as Line label.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.#ctor(MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            Construct a Label with a single location for both Geometries.
            Initialize the locations to Null.
            </summary>
            <param name="onLoc"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.#ctor(System.Int32,MapWindow.Interfaces.Geometries.Locations)">
            <summary> 
            Construct a Label with a single location for both Geometries.
            Initialize the location for the Geometry index.
            </summary>
            <param name="geomIndex"></param>
            <param name="onLoc"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.#ctor(MapWindow.Interfaces.Geometries.Locations,MapWindow.Interfaces.Geometries.Locations,MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            Construct a Label with On, Left and Right locations for both Geometries.
            Initialize the locations for both Geometries to the given values.
            </summary>
            <param name="onLoc"></param>
            <param name="leftLoc"></param>
            <param name="rightLoc"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.#ctor(System.Int32,MapWindow.Interfaces.Geometries.Locations,MapWindow.Interfaces.Geometries.Locations,MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            Construct a Label with On, Left and Right locations for both Geometries.
            Initialize the locations for the given Geometry index.
            </summary>
            <param name="geomIndex"></param>
            <param name="onLoc"></param>
            <param name="leftLoc"></param>
            <param name="rightLoc"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.#ctor(System.Int32,MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation)">
            <summary> 
            Construct a Label with the same values as the argument for the
            given Geometry index.
            </summary>
            <param name="geomIndex"></param>
            <param name="gl"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.Label)">
            <summary> 
            Construct a Label with the same values as the argument Label.
            </summary>
            <param name="lbl"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.Flip">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.GetLocation(System.Int32,MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <param name="posIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.GetLocation(System.Int32)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.SetLocation(System.Int32,MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions,MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <param name="posIndex"></param>
            <param name="location"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.SetLocation(System.Int32,MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <param name="location"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.SetAllLocations(System.Int32,MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <param name="location"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.SetAllLocationsIfNull(System.Int32,MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <param name="location"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.SetAllLocationsIfNull(MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            
            </summary>
            <param name="location"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.Merge(MapWinGeoProc.NTS.Topology.GeometriesGraph.Label)">
            <summary> 
            Merge this label with another one.
            Merging updates any null attributes of this label with the attributes from lbl.
            </summary>
            <param name="lbl"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.SetGeometryLocation(System.Int32,MapWinGeoProc.NTS.Topology.GeometriesGraph.TopologyLocation)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <param name="tl"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.IsNull(System.Int32)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.IsAnyNull(System.Int32)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.IsArea">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.IsArea(System.Int32)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.IsLine(System.Int32)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.IsEqualOnSide(MapWinGeoProc.NTS.Topology.GeometriesGraph.Label,System.Int32)">
            <summary>
            
            </summary>
            <param name="lbl"></param>
            <param name="side"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.AllPositionsEqual(System.Int32,MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <param name="loc"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.ToLine(System.Int32)">
            <summary> 
            Converts one GeometryLocation to a Line location.
            </summary>
            <param name="geomIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Label.GeometryCount">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SweepLineEvent">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SweepLineEvent.Insert">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SweepLineEvent.Delete">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SweepLineEvent.#ctor(System.Object,System.Double,MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SweepLineEvent,System.Object)">
            <summary>
            
            </summary>
            <param name="edgeSet"></param>
            <param name="x"></param>
            <param name="insertEvent"></param>
            <param name="obj"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SweepLineEvent.CompareTo(System.Object)">
            <summary>
            ProjectionEvents are ordered first by their x-value, and then by their eventType.
            It is important that Insert events are sorted before Delete events, so that
            items whose Insert and Delete events occur at the same x-value will be
            correctly handled.
            </summary>
            <param name="o"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SweepLineEvent.EdgeSet">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SweepLineEvent.IsInsert">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SweepLineEvent.IsDelete">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SweepLineEvent.InsertEvent">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SweepLineEvent.DeleteEventIndex">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SweepLineEvent.Object">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.MonotoneChainIndexer">
            <summary> 
            MonotoneChains are a way of partitioning the segments of an edge to
            allow for fast searching of intersections.
            They have the following properties:
            the segments within a monotone chain will never intersect each other, and
            the envelope of any contiguous subset of the segments in a monotone chain
            is simply the envelope of the endpoints of the subset.
            Property 1 means that there is no need to test pairs of segments from within
            the same monotone chain for intersection.
            Property 2 allows
            binary search to be used to find the intersection points of two monotone chains.
            For many types of real-world data, these properties eliminate a large number of
            segment comparisons, producing substantial speed gains.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.MonotoneChainIndexer.ToIntArray(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.MonotoneChainIndexer.#ctor">
            <summary>
            Default empty constructor.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.MonotoneChainIndexer.GetChainStartIndices(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            
            </summary>
            <param name="pts"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.MonotoneChainIndexer.FindChainEnd(MapWindow.Interfaces.Geometries.ICoordinate[],System.Int32)">
            <returns> 
            The index of the last point in the monotone chain.
            
            </returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersection">
            <summary> 
            An EdgeIntersection represents a point on an
            edge which intersects with another edge.
            The intersection may either be a single point, or a line segment
            (in which case this point is the start of the line segment)
            The label attached to this intersection point applies to
            the edge from this point forwards, until the next
            intersection or the end of the edge.
            The intersection point must be precise.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersection.#ctor(MapWindow.Interfaces.Geometries.ICoordinate,System.Int32,System.Double)">
            <summary>
            
            </summary>
            <param name="coord"></param>
            <param name="segmentIndex"></param>
            <param name="dist"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersection.CompareTo(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersection.Compare(System.Int32,System.Double)">
            <summary>
            
            </summary>
            <param name="segmentIndex"></param>
            <param name="dist"></param>
            <returns>
            -1 this EdgeIntersection is located before the argument location,
            0 this EdgeIntersection is at the argument location,
            1 this EdgeIntersection is located after the argument location.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersection.IsEndPoint(System.Int32)">
            <summary>
            
            </summary>
            <param name="maxSegmentIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersection.Write(System.IO.StreamWriter)">
            <summary>
            
            </summary>
            <param name="outstream"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersection.Coordinate">
            <summary>
            The point of intersection.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersection.SegmentIndex">
            <summary>
            The index of the containing line segment in the parent edge.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersection.Distance">
            <summary>
            The edge distance of this point along the containing line segment.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeocentricTransform">
            <summary>
            
            </summary>
            <remarks>
            <para>Latitude, Longitude and ellipsoidal height in terms of a 3-dimensional geographic system
            may by expressed in terms of a geocentric (earth centered) Cartesian coordinate reference system
            X, Y, Z with the Z axis corresponding to the earth's rotation axis positive northwards, the X
            axis through the intersection of the prime meridian and equator, and the Y axis through
            the intersection of the equator with longitude 90 degrees east. The geographic and geocentric
            systems are based on the same geodetic datum.</para>
            <para>Geocentric coordinate reference systems are conventionally taken to be defined with the X
            axis through the intersection of the Greenwich meridian and equator. This requires that the equivalent
            geographic coordinate reference systems based on a non-Greenwich prime meridian should first be
            transformed to their Greenwich equivalent. Geocentric coordinates X, Y and Z take their units from
            the units of the ellipsoid axes (a and b). As it is conventional for X, Y and Z to be in metres,
            if the ellipsoid axis dimensions are given in another linear unit they should first be converted
            to metres.</para>
            </remarks>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.MathTransform">
            <summary>
            Abstract class for creating multi-dimensional coordinate points transformations.
            </summary>
            <remarks>
            If a client application wishes to query the source and target coordinate 
            systems of a transformation, then it should keep hold of the 
            <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.ICoordinateTransformation"/> interface, and use the contained 
            math transform object whenever it wishes to perform a transform.
            </remarks>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform">
            <summary>
            Transforms muti-dimensional coordinate points.
            </summary>
            <remarks>
            If a client application wishes to query the source and target coordinate 
            systems of a transformation, then it should keep hold of the 
            <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.ICoordinateTransformation"/> interface, and use the contained 
            math transform object whenever it wishes to perform a transform.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform.Identity">
            <summary>
            Tests whether this transform does not move any points.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform.Derivative(MapWinGeoProc.NTS.Topology.Geometries.Point)">
            <summary>
            Gets the derivative of this transform at a point. If the transform does 
            not have a well-defined derivative at the point, then this function should 
            fail in the usual way for the DCP. The derivative is the matrix of the 
            non-translating portion of the approximate affine map at the point. The
            matrix will have dimensions corresponding to the source and target 
            coordinate systems. If the input dimension is M, and the output dimension 
            is N, then the matrix will have size [M][N]. The elements of the matrix 
            {elt[n][m] : n=0..(N-1)} form a vector in the output space which is 
            parallel to the displacement caused by a small change in the m'th ordinate 
            in the input space.
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform.GetCodomainConvexHull(System.Collections.Generic.List{System.Double})">
            <summary>
            Gets transformed convex hull.
            </summary>
            <remarks>
            <para>The supplied ordinates are interpreted as a sequence of points, which generates a convex
            hull in the source space. The returned sequence of ordinates represents a convex hull in the 
            output space. The number of output points will often be different from the number of input 
            points. Each of the input points should be inside the valid domain (this can be checked by 
            testing the points' domain flags individually). However, the convex hull of the input points
            may go outside the valid domain. The returned convex hull should contain the transformed image
            of the intersection of the source convex hull and the source domain.</para>
            <para>A convex hull is a shape in a coordinate system, where if two positions A and B are 
            inside the shape, then all positions in the straight line between A and B are also inside 
            the shape. So in 3D a cube and a sphere are both convex hulls. Other less obvious examples 
            of convex hulls are straight lines, and single points. (A single point is a convex hull, 
            because the positions A and B must both be the same - i.e. the point itself. So the straight
            line between A and B has zero length.)</para>
            <para>Some examples of shapes that are NOT convex hulls are donuts, and horseshoes.</para>
            </remarks>
            <param name="points"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform.GetDomainFlags(System.Collections.Generic.List{System.Double})">
            <summary>
            Gets flags classifying domain points within a convex hull.
            </summary>
            <remarks>
             The supplied ordinates are interpreted as a sequence of points, which 
            generates a convex hull in the source space. Conceptually, each of the 
            (usually infinite) points inside the convex hull is then tested against
            the source domain. The flags of all these tests are then combined. In 
            practice, implementations of different transforms will use different 
            short-cuts to avoid doing an infinite number of tests.
            </remarks>
            <param name="points"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform.Inverse">
            <summary>
            Creates the inverse transform of this object.
            </summary>
            <remarks>This method may fail if the transform is not one to one. However, all cartographic projections should succeed.</remarks>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform.Transform(MapWinGeoProc.NTS.Topology.Geometries.Point)">
            <summary>
            Transforms a coordinate point. The passed parameter point should not be modified.
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform.TransformList(System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.Geometries.Point})">
            <summary>
            Transforms a list of coordinate point ordinal values.
            </summary>
            <remarks>
            This method is provided for efficiently transforming many points. The supplied array 
            of ordinal values will contain packed ordinal values. For example, if the source 
            dimension is 3, then the ordinals will be packed in this order (x0,y0,z0,x1,y1,z1 ...).
            The size of the passed array must be an integer multiple of DimSource. The returned 
            ordinal values are packed in a similar way. In some DCPs. the ordinals may be 
            transformed in-place, and the returned array may be the same as the passed array.
            So any client code should not attempt to reuse the passed ordinal values (although
            they can certainly reuse the passed array). If there is any problem then the server
            implementation will throw an exception. If this happens then the client should not
            make any assumptions about the state of the ordinal values.
            </remarks>
            <param name="points"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform.Invert">
            <summary>
            Reverses the transformation
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform.DimSource">
            <summary>
            Gets the dimension of input points.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform.DimTarget">
            <summary>
            Gets the dimension of output points.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform.WKT">
            <summary>
            Gets a Well-Known text representation of this object.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform.XML">
            <summary>
            Gets an XML representation of this object.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.MathTransform.R2D">
            <summary>
            R2D
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.MathTransform.D2R">
            <summary>
            D2R
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.MathTransform.Identity">
            <summary>
            Tests whether this transform does not move any points.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.MathTransform.Derivative(MapWinGeoProc.NTS.Topology.Geometries.Point)">
            <summary>
            Gets the derivative of this transform at a point. If the transform does 
            not have a well-defined derivative at the point, then this function should 
            fail in the usual way for the DCP. The derivative is the matrix of the 
            non-translating portion of the approximate affine map at the point. The
            matrix will have dimensions corresponding to the source and target 
            coordinate systems. If the input dimension is M, and the output dimension 
            is N, then the matrix will have size [M][N]. The elements of the matrix 
            {elt[n][m] : n=0..(N-1)} form a vector in the output space which is 
            parallel to the displacement caused by a small change in the m'th ordinate 
            in the input space.
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.MathTransform.GetCodomainConvexHull(System.Collections.Generic.List{System.Double})">
            <summary>
            Gets transformed convex hull.
            </summary>
            <remarks>
            <para>The supplied ordinates are interpreted as a sequence of points, which generates a convex
            hull in the source space. The returned sequence of ordinates represents a convex hull in the 
            output space. The number of output points will often be different from the number of input 
            points. Each of the input points should be inside the valid domain (this can be checked by 
            testing the points' domain flags individually). However, the convex hull of the input points
            may go outside the valid domain. The returned convex hull should contain the transformed image
            of the intersection of the source convex hull and the source domain.</para>
            <para>A convex hull is a shape in a coordinate system, where if two positions A and B are 
            inside the shape, then all positions in the straight line between A and B are also inside 
            the shape. So in 3D a cube and a sphere are both convex hulls. Other less obvious examples 
            of convex hulls are straight lines, and single points. (A single point is a convex hull, 
            because the positions A and B must both be the same - i.e. the point itself. So the straight
            line between A and B has zero length.)</para>
            <para>Some examples of shapes that are NOT convex hulls are donuts, and horseshoes.</para>
            </remarks>
            <param name="points"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.MathTransform.GetDomainFlags(System.Collections.Generic.List{System.Double})">
            <summary>
            Gets flags classifying domain points within a convex hull.
            </summary>
            <remarks>
            The supplied ordinates are interpreted as a sequence of points, which 
            generates a convex hull in the source space. Conceptually, each of the 
            (usually infinite) points inside the convex hull is then tested against
            the source domain. The flags of all these tests are then combined. In 
            practice, implementations of different transforms will use different 
            short-cuts to avoid doing an infinite number of tests.
            </remarks>
            <param name="points"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.MathTransform.Inverse">
            <summary>
            Creates the inverse transform of this object.
            </summary>
            <remarks>This method may fail if the transform is not one to one. However, all cartographic projections should succeed.</remarks>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.MathTransform.Transform(MapWinGeoProc.NTS.Topology.Geometries.Point)">
            <summary>
            Transforms a coordinate point. The passed parameter point should not be modified.
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.MathTransform.TransformList(System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.Geometries.Point})">
            <summary>
            Transforms a list of coordinate point ordinal values.
            </summary>
            <remarks>
            This method is provided for efficiently transforming many points. The supplied array 
            of ordinal values will contain packed ordinal values. For example, if the source 
            dimension is 3, then the ordinals will be packed in this order (x0,y0,z0,x1,y1,z1 ...).
            The size of the passed array must be an integer multiple of DimSource. The returned 
            ordinal values are packed in a similar way. In some DCPs. the ordinals may be 
            transformed in-place, and the returned array may be the same as the passed array.
            So any client code should not attempt to reuse the passed ordinal values (although
            they can certainly reuse the passed array). If there is any problem then the server
            implementation will throw an exception. If this happens then the client should not
            make any assumptions about the state of the ordinal values.
            </remarks>
            <param name="points"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.MathTransform.Invert">
            <summary>
            Reverses the transformation
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.MathTransform.Degrees2Radians(System.Double)">
            <summary>
            To convert degrees to radians, multiply degrees by pi/180. 
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.MathTransform.Radians2Degrees(System.Double)">
            <summary>
            
            </summary>
            <param name="rad"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.MathTransform.DimSource">
            <summary>
            Gets the dimension of input points.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.MathTransform.DimTarget">
            <summary>
            Gets the dimension of output points.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.MathTransform.WKT">
            <summary>
            Gets a Well-Known text representation of this object.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.MathTransform.XML">
            <summary>
            Gets an XML representation of this object.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeocentricTransform.es">
            <summary>
            Eccentricity squared : (a^2 - b^2)/a^2
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeocentricTransform.ses">
            <summary>
            Second eccentricity squared : (a^2 - b^2)/b^2    
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeocentricTransform.#ctor(System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectionParameter},System.Boolean)">
            <summary>
            Initializes a geocentric projection object
            </summary>
            <param name="parameters">List of parameters to initialize the projection.</param>
            <param name="isInverse">Indicates whether the projection forward (meters to degrees or degrees to meters).</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeocentricTransform.#ctor(System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectionParameter})">
            <summary>
            Initializes a geocentric projection object
            </summary>
            <param name="parameters">List of parameters to initialize the projection.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeocentricTransform.Inverse">
            <summary>
            Returns the inverse of this conversion.
            </summary>
            <returns>IMathTransform that is the reverse of the current conversion.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeocentricTransform.DegreesToMeters(MapWinGeoProc.NTS.Topology.Geometries.Point)">
            <summary>
            Converts coordinates in decimal degrees to projected meters.
            </summary>
            <param name="lonlat">The point in decimal degrees.</param>
            <returns>Point in projected meters</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeocentricTransform.MetersToDegrees(MapWinGeoProc.NTS.Topology.Geometries.Point)">
            <summary>
            Converts coordinates in projected meters to decimal degrees.
            </summary>
            <param name="pnt">Point in meters</param>
            <returns>Transformed point in decimal degrees</returns>		
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeocentricTransform.Invert">
            <summary>
            Reverses the transformation
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.DatumTransform">
            <summary>
            Transformation for applying 
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectionParameter">
            <summary>
            A named projection parameter value.
            </summary>
            <remarks>
            The linear units of parameters' values match the linear units of the containing 
            projected coordinate system. The angular units of parameter values match the 
            angular units of the geographic coordinate system that the projected coordinate 
            system is based on. (Notice that this is different from <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Parameter"/>,
            where the units are always meters and degrees.)
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectionParameter.#ctor(System.String,System.Double)">
            <summary>
            Initializes an instance of a ProjectionParameter
            </summary>
            <param name="name">Name of parameter</param>
            <param name="value">Parameter value</param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectionParameter.Name">
            <summary>
            Parameter name.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectionParameter.Value">
            <summary>
            Parameter value.
            The linear units of a parameters' values match the linear units of the containing 
            projected coordinate system. The angular units of parameter values match the 
            angular units of the geographic coordinate system that the projected coordinate 
            system is based on.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectionParameter.WKT">
            <summary>
            Returns the Well-known text for this object
            as defined in the simple features specification.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectionParameter.XML">
            <summary>
            Gets an XML representation of this object
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectedCoordinateSystem">
            <summary>
            A 2D cartographic coordinate system.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.HorizontalCoordinateSystem">
            <summary>
            A 2D coordinate system suitable for positions on the Earth's surface.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystem">
            <summary>
            Base interface for all coordinate systems.
            </summary>
            <remarks>
            <para>A coordinate system is a mathematical space, where the elements of the space
            are called positions. Each position is described by a list of numbers. The length 
            of the list corresponds to the dimension of the coordinate system. So in a 2D 
            coordinate system each position is described by a list containing 2 numbers.</para>
            <para>However, in a coordinate system, not all lists of numbers correspond to a 
            position - some lists may be outside the domain of the coordinate system. For 
            example, in a 2D Lat/Lon coordinate system, the list (91,91) does not correspond
            to a position.</para>
            <para>Some coordinate systems also have a mapping from the mathematical space into 
            locations in the real world. So in a Lat/Lon coordinate system, the mathematical 
            position (lat, long) corresponds to a location on the surface of the Earth. This 
            mapping from the mathematical space into real-world locations is called a Datum.</para>
            </remarks>		
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Info">
            <summary>
            The Info object defines the standard information
            stored with spatial reference objects
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IInfo">
            <summary>
            The ISpatialReferenceInfo interface defines the standard 
            information stored with spatial reference objects. This
            interface is reused for many of the spatial reference
            objects in the system.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.IInfo.EqualParams(System.Object)">
            <summary>
            Checks whether the values of this instance is equal to the values of another instance.
            Only parameters used for coordinate system are used for comparison.
            Name, abbreviation, authority, alias and remarks are ignored in the comparison.
            </summary>
            <param name="obj"></param>
            <returns>True if equal</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IInfo.Name">
            <summary>
            Gets or sets the name of the object.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IInfo.Authority">
            <summary>
            Gets or sets the authority name for this object, e.g., “POSC”,
            is this is a standard object with an authority specific
            identity code. Returns “CUSTOM” if this is a custom object.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IInfo.AuthorityCode">
            <summary>
            Gets or sets the authority specific identification code of the object
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IInfo.Alias">
            <summary>
            Gets or sets the alias of the object.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IInfo.Abbreviation">
            <summary>
            Gets or sets the abbreviation of the object.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IInfo.Remarks">
            <summary>
            Gets or sets the provider-supplied remarks for the object.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IInfo.WKT">
            <summary>
            Returns the Well-known text for this spatial reference object
            as defined in the simple features specification.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IInfo.XML">
            <summary>
            Gets an XML representation of this object.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Info.#ctor(System.String,System.String,System.Int64,System.String,System.String,System.String)">
            <summary>
            A base interface for metadata applicable to coordinate system objects.
            </summary>
            <remarks>
            <para>The metadata items ‘Abbreviation’, ‘Alias’, ‘Authority’, ‘AuthorityCode’, ‘Name’ and ‘Remarks’ 
            were specified in the Simple Features interfaces, so they have been kept here.</para>
            <para>This specification does not dictate what the contents of these items 
            should be. However, the following guidelines are suggested:</para>
            <para>When <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemAuthorityFactory"/> is used to create an object, the ‘Authority’
            and 'AuthorityCode' values should be set to the authority name of the factory object, and the authority 
            code supplied by the client, respectively. The other values may or may not be set. (If the authority is 
            EPSG, the implementer may consider using the corresponding metadata values in the EPSG tables.)</para>
            <para>When <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory"/> creates an object, the 'Name' should be set to the value
            supplied by the client. All of the other metadata items should be left empty</para>
            </remarks>
            <param name="name">Name</param>
            <param name="authority">Authority name</param>
            <param name="code">Authority-specific identification code.</param>
            <param name="alias">Alias</param>
            <param name="abbreviation">Abbreviation</param>
            <param name="remarks">Provider-supplied remarks</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Info.ToString">
            <summary>
            Returns the Well-known text for this object
            as defined in the simple features specification.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Info.EqualParams(System.Object)">
            <summary>
            Checks whether the values of this instance is equal to the values of another instance.
            Only parameters used for coordinate system are used for comparison.
            Name, abbreviation, authority, alias and remarks are ignored in the comparison.
            </summary>
            <param name="obj"></param>
            <returns>True if equal</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Info.Name">
            <summary>
            Gets or sets the name of the object.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Info.Authority">
            <summary>
            Gets or sets the authority name for this object, e.g., "EPSG",
            is this is a standard object with an authority specific
            identity code. Returns "CUSTOM" if this is a custom object.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Info.AuthorityCode">
            <summary>
            Gets or sets the authority specific identification code of the object
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Info.Alias">
            <summary>
            Gets or sets the alias of the object.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Info.Abbreviation">
            <summary>
            Gets or sets the abbreviation of the object.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Info.Remarks">
            <summary>
            Gets or sets the provider-supplied remarks for the object.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Info.WKT">
            <summary>
            Returns the Well-known text for this object
            as defined in the simple features specification.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Info.XML">
            <summary>
            Gets an XML representation of this object.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Info.InfoXml">
            <summary>
            Returns an XML string of the info object
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystem">
            <summary>
            Base interface for all coordinate systems
            </summary>
            <remarks>
            <para>A coordinate system is a mathematical space, where the elements of the space are called
            positions. Each position is described by a list of numbers. The length of the list corresponds
            to the dimension of the coordinate system. So in a 2D coordinate system each position is 
            described by a list containing 2 numbers.</para>
            <para>
            However, in a coordinate system, not all lists of numbers correspond to a position - 
            some lists may be outside the domain of the coordinate system. For example, in a 2D Lat/Lon
            coordinate system, the list (91,91) does not correspond to a position.</para>
            <para>
            Some coordinate systems also have a mapping from the mathematical space into locations
            in the real world. So in a Lat/Lon coordinate system, the mathematical position (lat, long) 
            corresponds to a location on the surface of the Earth. This mapping from the mathematical 
            space into real-world locations is called a Datum.</para>
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystem.GetAxis(System.Int32)">
            <summary>
            Gets axis details for dimension within coordinate system.
            </summary>
            <param name="dimension">Dimension</param>
            <returns>Axis info</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystem.GetUnits(System.Int32)">
            <summary>
            Gets units for dimension within coordinate system.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystem.Dimension">
            <summary>
            Dimension of the coordinate system.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystem.DefaultEnvelope">
            <summary>
            Gets default envelope of coordinate system.
            </summary>
            <remarks>
            Gets default envelope of coordinate system. Coordinate systems 
            which are bounded should return the minimum bounding box of their 
            domain. Unbounded coordinate systems should return a box which is 
            as large as is likely to be used. For example, a (lon,lat) 
            geographic coordinate system in degrees should return a box from 
            (-180,-90) to (180,90), and a geocentric coordinate system could 
            return a box from (-r,-r,-r) to (+r,+r,+r) where r is the 
            approximate radius of the Earth.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystem.#ctor(System.String,System.String,System.Int64,System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of a coordinate system.
            </summary>
            <param name="name">Name</param>
            <param name="authority">Authority name</param>
            <param name="authorityCode">Authority-specific identification code.</param>
            <param name="alias">Alias</param>
            <param name="abbreviation">Abbreviation</param>
            <param name="remarks">Provider-supplied remarks</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystem.GetUnits(System.Int32)">
            <summary>
            Gets the units for the dimension within coordinate system. 
            Each dimension in the coordinate system has corresponding units.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystem.GetAxis(System.Int32)">
            <summary>
            Gets axis details for dimension within coordinate system.
            </summary>
            <param name="dimension">Dimension</param>
            <returns>Axis info</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystem.Dimension">
            <summary>
            Dimension of the coordinate system.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystem.DefaultEnvelope">
            <summary>
            Gets default envelope of coordinate system.
            </summary>
            <remarks>
            Coordinate systems which are bounded should return the minimum bounding box of their domain. 
            Unbounded coordinate systems should return a box which is as large as is likely to be used. 
            For example, a (lon,lat) geographic coordinate system in degrees should return a box from 
            (-180,-90) to (180,90), and a geocentric coordinate system could return a box from (-r,-r,-r)
            to (+r,+r,+r) where r is the approximate radius of the Earth.
            </remarks>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IHorizontalCoordinateSystem">
            <summary>
            A 2D coordinate system suitable for positions on the Earth's surface.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IHorizontalCoordinateSystem.HorizontalDatum">
            <summary>
            Returns the HorizontalDatum.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.HorizontalCoordinateSystem.#ctor(MapWinGeoProc.NTS.Topology.CoordinateSystems.IHorizontalDatum,System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo},System.String,System.String,System.Int64,System.String,System.String,System.String)">
            <summary>
            Creates an instance of HorizontalCoordinateSystem
            </summary>
            <param name="datum">Horizontal datum</param>
            <param name="axisInfo">Axis information</param>
            <param name="name">Name</param>
            <param name="authority">Authority name</param>
            <param name="code">Authority-specific identification code.</param>
            <param name="alias">Alias</param>
            <param name="abbreviation">Abbreviation</param>
            <param name="remarks">Provider-supplied remarks</param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.HorizontalCoordinateSystem.HorizontalDatum">
            <summary>
            Gets or sets the HorizontalDatum.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IProjectedCoordinateSystem">
            <summary>
            The IProjectedCoordinateSystem interface defines the standard information stored with
            projected coordinate system objects. A projected coordinate system is defined using a
            geographic coordinate system object and a projection object that defines the
            coordinate transformation from the geographic coordinate system to the projected
            coordinate systems. The instances of a single ProjectedCoordinateSystem COM class can
            be used to model different projected coordinate systems (e.g., UTM Zone 10, Albers)
            by associating the ProjectedCoordinateSystem instances with Projection instances
            belonging to different Projection COM classes (Transverse Mercator and Albers,
            respectively).
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IProjectedCoordinateSystem.GeographicCoordinateSystem">
            <summary>
            Gets or sets the geographic coordinate system associated with the projected
            coordinate system.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IProjectedCoordinateSystem.LinearUnit">
            <summary>
            Gets or sets the linear (projected) units of the projected coordinate system.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IProjectedCoordinateSystem.Projection">
            <summary>
            Gets or sets the projection for the projected coordinate system.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectedCoordinateSystem.#ctor(MapWinGeoProc.NTS.Topology.CoordinateSystems.IHorizontalDatum,MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeographicCoordinateSystem,MapWinGeoProc.NTS.Topology.CoordinateSystems.ILinearUnit,MapWinGeoProc.NTS.Topology.CoordinateSystems.IProjection,System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo},System.String,System.String,System.Int64,System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of a projected coordinate system
            </summary>
            <param name="datum">Horizontal datum</param>
            <param name="geographicCoordinateSystem">Geographic coordinate system</param>
            <param name="linearUnit">Linear unit</param>
            <param name="projection">Projection</param>
            <param name="axisInfo">Axis info</param>
            <param name="name">Name</param>
            <param name="authority">Authority name</param>
            <param name="code">Authority-specific identification code.</param>
            <param name="alias">Alias</param>
            <param name="abbreviation">Abbreviation</param>
            <param name="remarks">Provider-supplied remarks</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectedCoordinateSystem.GetUnits(System.Int32)">
            <summary>
            Gets units for dimension within coordinate system. Each dimension in 
            the coordinate system has corresponding units.
            </summary>
            <param name="dimension">Dimension</param>
            <returns>Unit</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectedCoordinateSystem.EqualParams(System.Object)">
            <summary>
            Checks whether the values of this instance is equal to the values of another instance.
            Only parameters used for coordinate system are used for comparison.
            Name, abbreviation, authority, alias and remarks are ignored in the comparison.
            </summary>
            <param name="obj"></param>
            <returns>True if equal</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectedCoordinateSystem.GeographicCoordinateSystem">
            <summary>
            Gets or sets the GeographicCoordinateSystem.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectedCoordinateSystem.LinearUnit">
            <summary>
            Gets or sets the <see cref="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectedCoordinateSystem.LinearUnit">LinearUnits</see>. The linear unit must be the same as the <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystem"/> units.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectedCoordinateSystem.Projection">
            <summary>
            Gets or sets the projection
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectedCoordinateSystem.WKT">
            <summary>
            Returns the Well-known text for this object
            as defined in the simple features specification.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectedCoordinateSystem.XML">
            <summary>
            Gets an XML representation of this object.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.LinearUnit">
            <summary>
            Definition of linear units.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ILinearUnit">
            <summary>
            The ILinearUnit interface defines methods on linear units.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IUnit">
            <summary>
            The IUnit interface abstracts different kinds of units, it has no methods.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.ILinearUnit.MetersPerUnit">
            <summary>
            Gets or sets the number of meters per <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ILinearUnit"/>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.LinearUnit.#ctor(System.Double,System.String,System.String,System.Int64,System.String,System.String,System.String)">
            <summary>
            Creates an instance of a linear unit
            </summary>
            <param name="metersPerUnit">Number of meters per <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.LinearUnit"/></param>
            <param name="name">Name</param>
            <param name="authority">Authority name</param>
            <param name="authorityCode">Authority-specific identification code.</param>
            <param name="alias">Alias</param>
            <param name="abbreviation">Abbreviation</param>
            <param name="remarks">Provider-supplied remarks</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.LinearUnit.EqualParams(System.Object)">
            <summary>
            Checks whether the values of this instance is equal to the values of another instance.
            Only parameters used for coordinate system are used for comparison.
            Name, abbreviation, authority, alias and remarks are ignored in the comparison.
            </summary>
            <param name="obj"></param>
            <returns>True if equal</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.LinearUnit.Metre">
            <summary>
            Returns the meters linear unit.
            Also known as International metre. SI standard unit.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.LinearUnit.Foot">
            <summary>
            Returns the foot linear unit (1ft = 0.3048m).
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.LinearUnit.USSurveyFoot">
            <summary>
            Returns the US Survey foot linear unit (1ftUS = 0.304800609601219m).
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.LinearUnit.NauticalMile">
            <summary>
            Returns the Nautical Mile linear unit (1NM = 1852m).
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.LinearUnit.ClarkesFoot">
            <summary>
            Returns Clarke's foot.
            </summary>
            <remarks>
            Assumes Clarke's 1865 ratio of 1 British foot = 0.3047972654 French legal metres applies to the international metre. 
            Used in older Australian, southern African &amp; British West Indian mapping.
            </remarks>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.LinearUnit.MetersPerUnit">
            <summary>
            Gets or sets the number of meters per <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.LinearUnit"/>.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.LinearUnit.WKT">
            <summary>
            Returns the Well-known text for this object
            as defined in the simple features specification.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.LinearUnit.XML">
            <summary>
            Gets an XML representation of this object
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemAuthorityFactory">
            <summary>
            Creates spatial reference objects using codes.
            </summary>
            <remarks>
             The codes are maintained by an external authority. A commonly used authority is EPSG, which is also used in the GeoTIFF standard and in SharpMap.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemAuthorityFactory.CreateProjectedCoordinateSystem(System.Int64)">
            <summary>
            Returns a projected coordinate system object corresponding to the given code.
            </summary>
            <param name="code">The identification code.</param>
            <returns>The projected coordinate system object with the given code.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemAuthorityFactory.CreateGeographicCoordinateSystem(System.Int64)">
            <summary>
            Returns a geographic coordinate system object corresponding to the given code.
            </summary>
            <param name="code">The identification code.</param>
            <returns>The geographic coordinate system object with the given code.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemAuthorityFactory.CreateHorizontalDatum(System.Int64)">
            <summary>
            Returns a horizontal datum object corresponding to the given code.
            </summary>
            <param name="code">The identification code.</param>
            <returns>The horizontal datum object with the given code.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemAuthorityFactory.CreateEllipsoid(System.Int64)">
            <summary>
            Returns an ellipsoid object corresponding to the given code.
            </summary>
            <param name="code">The identification code.</param>
            <returns>The ellipsoid object with the given code.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemAuthorityFactory.CreatePrimeMeridian(System.Int64)">
            <summary>
            Returns a prime meridian object corresponding to the given code.
            </summary>
            <param name="code">The identification code.</param>
            <returns>The prime meridian object with the given code.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemAuthorityFactory.CreateLinearUnit(System.Int64)">
            <summary>
            Returns a linear unit object corresponding to the given code.
            </summary>
            <param name="code">The identification code.</param>
            <returns>The linear unit object with the given code.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemAuthorityFactory.CreateAngularUnit(System.Int64)">
            <summary>
            Returns an <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IAngularUnit">angular unit</see> object corresponding to the given code.
            </summary>
            <param name="code">The identification code.</param>
            <returns>The angular unit object for the given code.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemAuthorityFactory.CreateVerticalDatum(System.Int64)">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IVerticalDatum"/> from a code.
            </summary>
            <param name="code">Authority code</param>
            <returns>Vertical datum for the given code</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemAuthorityFactory.CreateVerticalCoordinateSystem(System.Int64)">
            <summary>
            Create a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IVerticalCoordinateSystem">vertical coordinate system</see> from a code.
            </summary>
            <param name="code">Authority code</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemAuthorityFactory.CreateCompoundCoordinateSystem(System.Int64)">
            <summary>
            Creates a 3D coordinate system from a code.
            </summary>
            <param name="code">Authority code</param>
            <returns>Compound coordinate system for the given code</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemAuthorityFactory.CreateHorizontalCoordinateSystem(System.Int64)">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IHorizontalCoordinateSystem">horizontal co-ordinate system</see> from a code.
            The horizontal coordinate system could be geographic or projected.
            </summary>
            <param name="code">Authority code</param>
            <returns>Horizontal coordinate system for the given code</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemAuthorityFactory.GeoidFromWktName(System.String)">
            <summary>
            Gets the Geoid code from a WKT name.
            </summary>
            <remarks>
             In the OGC definition of WKT horizontal datums, the geoid is referenced 
            by a quoted string, which is used as a key value. This method converts 
            the key value string into a code recognized by this authority.
            </remarks>
            <param name="wkt"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemAuthorityFactory.WktGeoidName(System.String)">
            <summary>
            Gets the WKT name of a Geoid.
            </summary>
            <remarks>
             In the OGC definition of WKT horizontal datums, the geoid is referenced by 
            a quoted string, which is used as a key value. This method gets the OGC WKT 
            key value from a geoid code.
            </remarks>
            <param name="geoid"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemAuthorityFactory.Authority">
            <summary>
            Returns the authority name for this factory (e.g., "EPSG" or "POSC").
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemAuthorityFactory.DescriptionText">
            <summary>
            Gets a description of the object corresponding to a code.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeographicTransform">
            <summary>
            The GeographicTransform class is implemented on geographic transformation objects and
            implements datum transformations between geographic coordinate systems.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeographicTransform">
            <summary>
            The IGeographicTransform interface is implemented on geographic transformation
            objects and implements datum transformations between geographic coordinate systems.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeographicTransform.Forward(System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.Geometries.Point})">
            <summary>
            Transforms an array of points from the source geographic coordinate system
            to the target geographic coordinate system.
            </summary>
            <param name="point">Points in the source geographic coordinate system</param>
            <returns>Points in the target geographic coordinate system</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeographicTransform.Inverse(System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.Geometries.Point})">
            <summary>
            Transforms an array of points from the target geographic coordinate system
            to the source geographic coordinate system.
            </summary>
            <param name="point">Points in the target geographic coordinate system</param>
            <returns>Points in the source geographic coordinate system</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeographicTransform.SourceGCS">
            <summary>
            Gets or sets source geographic coordinate system for the transformation.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeographicTransform.TargetGCS">
            <summary>
            Gets or sets the target geographic coordinate system for the transformation.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeographicTransform.ParameterInfo">
            <summary>
            Returns an accessor interface to the parameters for this geographic transformation.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeographicTransform.Forward(System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.Geometries.Point})">
            <summary>
            Transforms an array of points from the source geographic coordinate
            system to the target geographic coordinate system.
            </summary>
            <param name="points">On input points in the source geographic coordinate system</param>
            <returns>Output points in the target geographic coordinate system</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeographicTransform.Inverse(System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.Geometries.Point})">
            <summary>
            Transforms an array of points from the target geographic coordinate
            system to the source geographic coordinate system.
            </summary>
            <param name="points">Input points in the target geographic coordinate system,</param>
            <returns>Output points in the source geographic coordinate system</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeographicTransform.EqualParams(System.Object)">
            <summary>
            Checks whether the values of this instance is equal to the values of another instance.
            Only parameters used for coordinate system are used for comparison.
            Name, abbreviation, authority, alias and remarks are ignored in the comparison.
            </summary>
            <param name="obj"></param>
            <returns>True if equal</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeographicTransform.SourceGCS">
            <summary>
            Gets or sets the source geographic coordinate system for the transformation.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeographicTransform.TargetGCS">
            <summary>
            Gets or sets the target geographic coordinate system for the transformation.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeographicTransform.ParameterInfo">
            <summary>
            Returns an accessor interface to the parameters for this geographic transformation.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeographicTransform.WKT">
            <summary>
            Returns the Well-known text for this object
            as defined in the simple features specification.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeographicTransform.XML">
            <summary>
            Gets an XML representation of this object [NOT IMPLEMENTED].
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.LayerFileElement">
            <summary>
            A modular control that can be used for specifying a filename for opening or closing files.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.LayerFileElement.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.LayerFileElement.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.LayerFileElement.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.LayerFileElement.cmdHelp">
            <summary>
            Help button
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.LayerFileElement.lblLight">
            <summary>
            Status Light
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.LayerFileElement.groupBox1">
            <summary>
            A group box to surround individual components
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.LayerFileElement.#ctor">
            <summary>
            Creates a new instance of the FileElement class
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.LayerFileElement.OnClick(System.EventArgs)">
            <summary>
            Called to fire the click event for this element
            </summary>
            <param name="e">A mouse event args thingy</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.LayerFileElement.OnHelpButtonPressed(MapWinGeoProc.Dialogs.HelpPannelEventArgs)">
            <summary>
            Called when the help button has been pressed
            </summary>
            <param name="e">A HelpPanelEventArgs parameter with a new help title, text and image.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.LayerFileElement.OnHelpContextChanged(MapWinGeoProc.Dialogs.HelpPannelEventArgs)">
            <summary>
            Called when the data entry field is entered to change a topic, but only if panel is visible
            </summary>
            <param name="e">A HelpPanelEventArgs parameter with a new help title, text and image.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.LayerFileElement.OnResizeStarted">
            <summary>
            Fires when someone uses the resize grip to resize the element
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.LayerFileElement.OnResizeEnded">
            <summary>
            Fires when someone has stopped resizing with the grip
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.LayerFileElement.HelpText_Append(System.String)">
            <summary>
            Appends a string to the end of the help content
            </summary>
            <param name="HelpText"></param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.LayerFileElement.HelpText_Clear(System.String)">
            <summary>
            Clears the existing help content.
            </summary>
            <param name="HelpText"></param>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.LayerFileElement.Clicked">
            <summary>
            Fires when the inactive areas around the controls are clicked on the element.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.LayerFileElement.HelpButtonPressed">
            <summary>
            Fires when the help button is clicked.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.LayerFileElement.HelpContextChanged">
            <summary>
            Fires when the the user enters a data entry region.  Changes help without opening panel.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.LayerFileElement.ResizeStarted">
            <summary>
            Fires when the element is being resized.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.LayerFileElement.ResizeEnded">
            <summary>
            Fires when the element is no longer being resized.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.LayerOnlyBoolElements">
            <summary>
            When a layer field is selected, rather than a file name, the dialog
            will attempt to set the "enabled" property to true
            for each of the listed objects.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.IsLayer">
            <summary>
            Gets a boolean value which is true if the text in the drop down matches one of the layer names
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.SelectedLayerName">
            <summary>
            Returns a string value representing the name of the layer that appears in the drop down text window
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.SelectedLayerIndex">
            <summary>
            Gets or Sets the index from the list of layernames that matches the current text shown
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.Caption">
            <summary>
            Controls the caption for this element (the group box text)
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.LightVisible">
            <summary>
            Gets or sets whether the status light is visible for this element.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.LightMessage">
            <summary>
            Gets or sets the tool tip that shows when you hold the mouse over the light
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.Status">
            <summary>
            Indicates the current condition of this element.
            - Green = ok to continue
            - Yellow = not specified yet
            - Red = process halting error
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.AllowGripResize">
            <summary>
            Gets or sets a boolean.  True if the user is allowed to adjust the width of the 
            element to better display longer filenames.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.Halt">
            <summary>
            Boolean, true if either of the conditions that may prevent dialog completion are true 
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.HaltOnEmpty">
            <summary>
            Gets or sets a boolean.  True if an unspecified condition will prevent dialog completion.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.HaltOnError">
            <summary>
            Gets or sets a boolean.  True if an Error status will prevent dialog completion.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.MaxWidth">
            <summary>
            Gets or sets the maximum allowable width for dynamic resize.  The dialog form sets this
            dynamically to the size of the container panel.  This is because the behavior for
            resizing larger than the size of the panel is erratic because of the autoscrolling
            behavior.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.MinWidth">
            <summary>
            Gets or sets the minimum allowable width for dynamic resizing.  This specifically affects
            the behavior when the user uses the grip to resize the element.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.HelpImage">
            <summary>
            Gets or Sets the image that will appear after the help text in the panel, if any.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.HelpText">
            <summary>
            Gets or Sets the text to appear in the help pannel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.HelpTitle">
            <summary>
            Gets or Sets the title to be shown in the help panel.  Defaults to the Caption.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.WikiAddress">
            <summary>
            Gets or Sets the web address to use from the wiki button in the help panel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.DefaultImage">
            <summary>
            Gets or Sets the default image that will be used in the help panel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.AlternateImage">
            <summary>
            Gets or Sets the alternate image that can be used in the help panel instead.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.FileAccess">
            <summary>
            Gets or sets whether the file is opened or saved
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.InputText">
            <summary>
            Gets or sets the filename shown in the textbox for this element
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.FileType">
            <summary>
            Gets or Sets the allowable file types by specifying shapefiles, images, or grids.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.LayerNames">
            <summary>
            Gets or sets the list of layer names that will appear in the drop down
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.Filter">
            <summary>
            Gets or Sets the dialog filter to be used directly.  Setting AllowedFileTypes will
            automatically set this with the filter values allowed for grids, images or shapefiles.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.HelpButtonVisible">
            <summary>
            Override the basic help button property change to also handle the text box resize
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.LayerFileElement.ResizeGripVisible">
            <summary>
            Gets or sets whether a resize grip is provided for the user to change the dimensions of the control.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.LayerFileElement.LightStatus">
            <summary>
            Indicates the allowed values for the status of the element, illustrated by the light
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.LayerFileElement.LightStatus.Empty">
            <summary>
            Indicates that no value has been set for this yet.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.LayerFileElement.LightStatus.Ok">
            <summary>
            Indicates that the element parameter is ok and won't halt.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.LayerFileElement.LightStatus.Error">
            <summary>
            Indicates that the element value will cause an error.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.LayerFileElement.FileTypes">
            <summary>
            Specifies a GIS file category to help narrow down the open/save file dialogs
            and improve the file format validation.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.LayerFileElement.FileTypes.Shapefile">
            <summary>
            Shapefiles that end with extension .shp
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.LayerFileElement.FileTypes.Grid">
            <summary>
            Grid file formats like geotif, asc, esri grids etc.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.LayerFileElement.FileTypes.Image">
            <summary>
            Image file formats like bmp, jpg, gif, etc.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.LayerFileElement.FileTypes.All">
            <summary>
            The element will not use any filter for file extensions or validation.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.LayerFileElement.FileAccessType">
            <summary>
            Specifies whether an element is being used to open or save a file.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.LayerFileElement.FileAccessType.Open">
            <summary>
            Speficies that the element will be used to open files.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.LayerFileElement.FileAccessType.Save">
            <summary>
            Specifies that the element will be used to save files.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.LayerFileElement.HelpButtonHandler">
            <summary>
            Public delegate for when someone presses the help button
            </summary>
            <param name="sender">The element sending the event</param>
            <param name="e">HelpPannelEventArgs with help title, text and an image</param>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.LayerFileElement.ResizeStartedHandler">
            <summary>
            Delegate for the when someone starts resizing an element
            </summary>
            <param name="sender">The element being resized</param>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.LayerFileElement.ResizeEndedHandler">
            <summary>
            Fires when the element is no longer being resized.
            </summary>
            <param name="sender"></param>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.GeoProcDialog">
            <summary>
            A generic form that works with the various dialog elements in order to create 
            a fully working process.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.GeoProcDialog.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.GeoProcDialog.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.GeoProcDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.GeoProcDialog.Elements">
            <summary>
            A System.Collections.ArrayList that stores a list of all the DialogElements that have been added to this dialog
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.GeoProcDialog.#ctor">
            <summary>
            A class that will support a collection of DialogElements in order to 
            allow users to specify the parameters to be used for geoproc functions.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.GeoProcDialog.Add_LayerFileElement(MapWinGeoProc.Dialogs.GeoProcDialog.ElementTypes)">
            <summary>
            Adds a an element to the dialog that allows the selection of a layer or a file.
            The layernames must be added manually.
            </summary>
            <param name="ElementType">Specifies exactly what sort of files will work</param>
            <returns>A LayerFileElement object that was added to the dialog</returns>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.GeoProcDialog.Add_FileElement(MapWinGeoProc.Dialogs.GeoProcDialog.ElementTypes)">
            <summary>
            Adds a new FileElement to the dialog and to the Elements arraylist.
            </summary>
            <param name="ElementType">An ElementTypes enumeration specifying what sort of files the project will use.</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.GeoProcDialog.Add_ComboBoxElement">
            <summary>
            Adds a new ComboBoxElement to the dialog and to the Elements arraylist.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.GeoProcDialog.Add_TextElement">
            <summary>
            Adds a new TextElement control to the dialog to receive a text parameter from a user.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.GeoProcDialog.Add_BooleanElement">
            <summary>
            Adds a new BooleanElement control to the dialog to receive true false information from
            the users.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.GeoProcDialog.HelpPanelVisible">
            <summary>
            A property to get the current help panel visible or sets it visible or not visible
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.GeoProcDialog.WikiAreaVisible">
            <summary>
            Boolean.  True if a wiki button with it's associated region will be shown at the top of the help panel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.GeoProcDialog.HelpResizeButtonsVisible">
            <summary>
            Boolean.  If true, two buttons appear in the wiki area of the help panel to allow quick resizing.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.GeoProcDialog.HelpTitle">
            <summary>
            "Gets or Sets the help title that will appear for the entire dialog.  Defaults to the Dialog's Caption Text."
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.GeoProcDialog.DialogHelpTitle">
            <summary>
            Gets or sets the default help title that appears initially, and when clicking outside of help enabled elements."
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.GeoProcDialog.HelpTitleFont">
            <summary>
            Gets or sets the font that will be used for any of the help titles shown in the help panel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.GeoProcDialog.DialogHelpText">
            <summary>
            Gets or sets the help text that will appear for the entire dialog.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.GeoProcDialog.HelpText">
            <summary>
            Gets or sets the text that is currently being displayed in the help panel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.GeoProcDialog.HelpTextFont">
            <summary>
            Gets or sets the font that is used for the explanatory text in the help panel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.GeoProcDialog.DialogHelpImage">
            <summary>
            Gets or sets the backup help image that will appear initially and when clicking outside of help enabled elements.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.GeoProcDialog.HelpImage">
            <summary>
            Gets or sets the image currently being shown in the help panel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.GeoProcDialog.HelpWebAddress">
            <summary>
            Gets or sets the URL that the wiki button will use for this dialog.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.GeoProcDialog.Parameters">
            <summary>
            Gets the values that were entered into each of the elements.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.GeoProcDialog.Captions">
            <summary>
            Gets the captions for all the elements.
            In the case of boolean elements, this is the text next to the checkbox.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.GeoProcDialog.ElementTypes">
            <summary>
            Specifies the type of files the FileElemnt can use and whether or not it will be opening or saving them.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.GeoProcDialog.ElementTypes.OpenFile">
            <summary>
            The element will be used to open any file type.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.GeoProcDialog.ElementTypes.OpenGridFile">
            <summary>
            The element will be used to open grid files.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.GeoProcDialog.ElementTypes.OpenImageFile">
            <summary>
            The element will be used to open image files.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.GeoProcDialog.ElementTypes.OpenShapefile">
            <summary>
            The element will be used to open shapefiles.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.GeoProcDialog.ElementTypes.SaveFile">
            <summary>
            The element will be used to save any file type.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.GeoProcDialog.ElementTypes.SaveGridFile">
            <summary>
            The element will be used to save a grid file.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.GeoProcDialog.ElementTypes.SaveImageFile">
            <summary>
            The element will be used to save an image file.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.GeoProcDialog.ElementTypes.SaveShapefile">
            <summary>
            The element will be used to save a shapefile.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.ComboBoxElement">
            <summary>
            A modular element that supports a textbox for users to enter information
            as part of a larger dialog control.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.ComboBoxElement.#ctor">
            <summary>
            Creates a new instance of the TextElement class
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.ComboBoxElement.OnClick(System.EventArgs)">
            <summary>
            Called to fire the click event for this element
            </summary>
            <param name="e">A mouse event args thingy</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.ComboBoxElement.OnHelpButtonPressed(MapWinGeoProc.Dialogs.HelpPannelEventArgs)">
            <summary>
            Called when the help button has been pressed
            </summary>
            <param name="e">A HelpPanelEventArgs parameter with a new help title, text and image.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.ComboBoxElement.OnHelpContextChanged(MapWinGeoProc.Dialogs.HelpPannelEventArgs)">
            <summary>
            Called when the data entry field is entered to change a topic, but only if panel is visible
            </summary>
            <param name="e">A HelpPanelEventArgs parameter with a new help title, text and image.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.ComboBoxElement.OnResizeStarted">
            <summary>
            Fires when someone uses the resize grip to resize the element
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.ComboBoxElement.OnResizeEnded">
            <summary>
            Fires when someone has stopped resizing with the grip
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.ComboBoxElement.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.ComboBoxElement.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.ComboBoxElement.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.ComboBoxElement.cmdHelp">
            <summary>
            Help button
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.ComboBoxElement.lblLight">
            <summary>
            Status Light
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.ComboBoxElement.groupBox1">
            <summary>
            A group box to surround individual components
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.ComboBoxElement.Clicked">
            <summary>
            Fires when the inactive areas around the controls are clicked on the element.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.ComboBoxElement.HelpButtonPressed">
            <summary>
            Fires when the help button is clicked.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.ComboBoxElement.HelpContextChanged">
            <summary>
            Fires when the the user enters a data entry region.  Changes help without opening panel.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.ComboBoxElement.ResizeStarted">
            <summary>
            Fires when the element is being resized.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.ComboBoxElement.ResizeEnded">
            <summary>
            Fires when the element is no longer being resized.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ComboBoxElement.Caption">
            <summary>
            Controls the caption for this element (the group box text)
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ComboBoxElement.LightVisible">
            <summary>
            Gets or sets whether the status light is visible for this element.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ComboBoxElement.LightMessage">
            <summary>
            Gets or sets the tool tip that shows when you hold the mouse over the light
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ComboBoxElement.Status">
            <summary>
            Indicates the current condition of this element.
            - Green = ok to continue
            - Yellow = not specified yet
            - Red = process halting error
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ComboBoxElement.AllowGripResize">
            <summary>
            Gets or sets a boolean.  True if the user is allowed to adjust the width of the 
            element to better display longer filenames.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ComboBoxElement.Halt">
            <summary>
            Boolean, true if either of the conditions that may prevent dialog completion are true 
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ComboBoxElement.HaltOnEmpty">
            <summary>
            Gets or sets a boolean.  True if an unspecified condition will prevent dialog completion.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ComboBoxElement.HaltOnError">
            <summary>
            Gets or sets a boolean.  True if an Error status will prevent dialog completion.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ComboBoxElement.MaxWidth">
            <summary>
            Gets or sets the maximum allowable width for dynamic resize.  The dialog form sets this
            dynamically to the size of the container panel.  This is because the behavior for
            resizing larger than the size of the panel is erratic because of the autoscrolling
            behavior.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ComboBoxElement.MinWidth">
            <summary>
            Gets or sets the minimum allowable width for dynamic resizing.  This specifically affects
            the behavior when the user uses the grip to resize the element.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ComboBoxElement.HelpImage">
            <summary>
            Gets or Sets the image that will appear after the help text in the panel, if any.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ComboBoxElement.HelpText">
            <summary>
            Gets or Sets the text to appear in the help pannel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ComboBoxElement.HelpTitle">
            <summary>
            Gets or Sets the title to be shown in the help panel.  Defaults to the Caption.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ComboBoxElement.WikiAddress">
            <summary>
            Gets or Sets the web address to use from the wiki button in the help panel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ComboBoxElement.DefaultImage">
            <summary>
            Gets or Sets the default image that will be used in the help panel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ComboBoxElement.AlternateImage">
            <summary>
            Gets or Sets the alternate image that can be used in the help panel instead.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ComboBoxElement.HelpButtonVisible">
            <summary>
            Overrides the basic help button property to also handle the text box resize
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ComboBoxElement.ResizeGripVisible">
            <summary>
            Gets or sets whether a resize grip is provided for the user to change the dimensions of the control.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ComboBoxElement.ListItems">
            <summary>
            Gets or sets the list of layer names that will appear in the drop down
            </summary>
            
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ComboBoxElement.Value">
            <summary>
            Gets or sets the value of the text in the text field.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ComboBoxElement.Text">
            <summary>
            Gets or sets the value of the text in the text field.
            This was added because the text property of the user control is confusing.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.ComboBoxElement.LightStatus">
            <summary>
            Indicates the allowed values for the status of the element, illustrated by the light
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.ComboBoxElement.LightStatus.Empty">
            <summary>
            Indicates that no value has been set for this yet.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.ComboBoxElement.LightStatus.Ok">
            <summary>
            Indicates that the element parameter is ok and won't halt.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.ComboBoxElement.LightStatus.Error">
            <summary>
            Indicates that the element value will cause an error.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.ComboBoxElement.HelpButtonHandler">
            <summary>
            Public delegate for when someone presses the help button
            </summary>
            <param name="sender">The element sending the event</param>
            <param name="e">HelpPannelEventArgs with help title, text and an image</param>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.ComboBoxElement.ResizeStartedHandler">
            <summary>
            Delegate for the when someone starts resizing an element
            </summary>
            <param name="sender">The element being resized</param>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.ComboBoxElement.ResizeEndedHandler">
            <summary>
            Fires when the element is no longer being resized.
            </summary>
            <param name="sender"></param>
        </member>
        <member name="T:MapWinGeoProc.ClipPolySFWithPoly">
            <summary>
            Functions for clipping a polygon shapefile with an outside polygon.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.ClipPolySFWithPoly.ClipPolygonSFWithPolygon(System.String@,MapWinGIS.Shape@,System.String@,System.Boolean)">
            <summary>
            Returns all portions of the shapefile polygons that fall within the clipper polygon.
            </summary>
            <param name="polySFPath">The full path to the shapefile of polygons to be clipped.</param>
            <param name="polygon">The polygon used for clipping the shapefile.</param>
            <param name="resultSFPath">The full path to the result file for where the clipped polygons should be saved.</param>
            <param name="copyAttributes">True if copying attrs</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.ClipPolySFWithPoly.ClipPolygonSFWithPolygon(MapWinGIS.Shapefile@,MapWinGIS.Shape@,MapWinGIS.Shapefile@,System.Boolean)">
            <summary>
            Returns the portions of the polygons in polySF that lie within polygon as a 
            new shapefile of polygons: resultPolySF.
            </summary>
            <param name="polySF">The shapefile of polygons that are to be clipped.</param>
            <param name="polygon">The polygon used for clipping.</param>
            <param name="resultPolySF">The result shapefile for the resulting polygons to be saved (in-memory).</param>
            <param name="copyAttributes">True if copying attrs</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="T:MapWinGeoProc.Pitfill.Frame">
            <summary>
            Very large images are divided up and tracked by a collection of bricked windows called a framework.
            The framework is divided up into individual frames.  Like a frame, this object doesn't actually contain
            any of the data itself.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Pitfill.Frame.#ctor(System.Int32,System.Int32,MapWinGeoProc.Pitfill.Framework)">
            <summary>
            Initializes a new frame using specific parameters
            </summary>
            <param name="X_value">The horizontal integer index of the frame.</param>
            <param name="Y_value">The vertical integer index of the frame.</param>
            <param name="ParentFramework">The Framework collection that will contain the new frame.</param>
        </member>
        <member name="M:MapWinGeoProc.Pitfill.Frame.get_Dependencies">
            <summary>
            This will return a list of locations relative to this frame where values have 
            been altered and we need to run the "Fill Dependencies" algorithm again.
            </summary>
            <returns>A List of Frame.Loc structures</returns>
        </member>
        <member name="M:MapWinGeoProc.Pitfill.Frame.Write_Dependencies(System.Byte[],System.Int32)">
            <summary>
            Writes the dependencies to a file.
            </summary>
            <param name="Values">byte[] direction of specific dependencies relative to the frame
            - 1 North, 2 South, 3 West, 4 East</param>
            <param name="Direction">Integer direction of values relative to the frame
            - 1 North, 2 South, 3 West, 4 East</param>
        </member>
        <member name="M:MapWinGeoProc.Pitfill.Frame.Update_Neighbor_Status(System.Boolean[])">
            <summary>
            If dependencies exist in a direction, this is where we tell the neighboring
            frames that they have new dependencies to take into consideration.
            </summary>
            <param name="DepsExist">bool array, true if dependencies exist in that direction</param>
        </member>
        <member name="M:MapWinGeoProc.Pitfill.Frame.Set_HasDependencies(System.Int32,System.Boolean)">
            <summary>
            Sets the boolean characteristic of having dependencies in a specific direction to 
            the value specified by val.
            </summary>
            <param name="Direction">The direction relative to this frame
            -1 North, 2 South, 3 West, 4 East</param>
            <param name="val">Boolean, true if the frame in Direction depends on changes made in this frame.</param>
        </member>
        <member name="M:MapWinGeoProc.Pitfill.Frame.Clear_Dependencies">
            <summary>
            Immediately after evaluating a frame, it won't have any dependencies so we can clear them
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Pitfill.Frame.GetArrayFromWindow(MapWinGIS.Grid,MapWinGIS.ICallback)">
            <summary>
            Converts a region of a grid into a 2D array of float values
            </summary>
            <param name="mwSourceGrid">The grid to read</param>
            <param name="ICallBack">A MapWinGIS.ICallback for status messages</param>
            <returns>float[][] the values from the grid</returns>
        </member>
        <member name="M:MapWinGeoProc.Pitfill.Frame.GetBorders(MapWinGIS.Grid,MapWinGIS.Grid,MapWinGIS.ICallback)">
            <summary>
            Returns jagged array where the borders are read from the destination file but the central
            portion is set to be the maximum float value.
            </summary>
            <param name="mwSourceGrid">A MapWinGIS.Grid to read the frame borders that are on the very outside of the image</param>
            <param name="mwDestGrid">A MapWinGIS.Grid to read the frame borders on the interior edges already processed </param>
            <param name="ICallBack">A MapWinGIS.ICallback for messages (optional)</param>
            <returns>A float[][] array representing the destination values for an entire frame</returns>
        </member>
        <member name="M:MapWinGeoProc.Pitfill.Frame.SaveArrayToWindow(System.Single[][],MapWinGIS.Grid,MapWinGIS.ICallback)">
            <summary>
            This function copies a two dimensional array of float values to the appropriate space in the grid.
            </summary>
            <param name="OutputArray">The two dimensional array of floats to save to the grid</param>
            <param name="mwGrid">The MapWinGIS.grid to save the float values to</param>
            <param name="ICallBack">A MapWinGIS.ICallback for status messages</param>
        </member>
        <member name="P:MapWinGeoProc.Pitfill.Frame.Parent">
            <summary>
            Gets the framework collection that this frame belongs to
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Pitfill.Frame.X">
            <summary>
            Gets the horizontal index of the frame from the left
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Pitfill.Frame.Y">
            <summary>
            Gets the vertical index of the frame from the top
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Pitfill.Frame.Status">
            <summary>
            Gets the current status of this Frame:
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Pitfill.Frame.Rank">
            <summary>
            Gets or Sets the rank value.  A frame on the edge of an image
            has a rank of 0.  Otherwise it is the minimum number of frames
            required to reach the edge of the image.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Pitfill.Frame.HasDependencies">
            <summary>
            Gets the boolean value indicating whether any dependencies exist for this frame.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Pitfill.Frame.Rectangle">
            <summary>
            Gets a System.Drawing.Rectangle representing the row and column placement and extent of the frame
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Pitfill.Frame.Left">
            <summary>
            Gets an integer representing the first grid column included in the frame
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Pitfill.Frame.Top">
            <summary>
            Gets an integer representing the first grid row included in the frame
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Pitfill.Frame.Width">
            <summary>
            Gets an integer representing the cell width of the frame
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Pitfill.Frame.Height">
            <summary>
            Gets an integer representing the cell height of the frame
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Pitfill.Frame.StatusType">
            <summary>
            The completion status of a frame.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Pitfill.Frame.StatusType.tkNotEvaluated">
            <summary>
            No analysis has been done on this frame yet.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Pitfill.Frame.StatusType.tkEvaluatedNoDependencies">
            <summary>
            The frame has been analyzed and has not been tagged for re-analysis.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Pitfill.Frame.StatusType.tkEvaluatedNeedsRevisiting">
            <summary>
            The frame has been analyzed, but needs to be re-analyzed.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Pitfill.Frame.StatusType.tkBeingEvaluated1">
            <summary>
            The frame is currently being analyzed.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Pitfill.Frame.Loc">
            <summary>
            A structure to hold X, Y values
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Pitfill.Frame.Loc.X">
            <summary>
            Integer, The X coordinate or horizontal value of the Location
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Pitfill.Frame.Loc.Y">
            <summary>
            Integer, the Y coordinate or vertical value of the location.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Pitfill.Frame.Loc.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new instance of a Location structure.
            </summary>
            <param name="X_Value">integer, The X coordinate</param>
            <param name="Y_Value">integer, The Y coordinate</param>
        </member>
        <member name="T:MapWinGeoProc.PointExporter">
            <summary>
            This class converts an array of [x,y,z] coordinates to a shapefile or text file
            </summary>
        </member>
        <member name="M:MapWinGeoProc.PointExporter.#ctor(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Creates a new class for exporting points
            </summary>
            <param name="points">Array of [x,y,z] points to be exported</param>
        </member>
        <member name="M:MapWinGeoProc.PointExporter.#ctor(System.Collections.Generic.List{MapWindow.Interfaces.Geometries.ICoordinate})">
            <summary>
            Creates a new PointExporter object for exporting points
            </summary>
            <param name="points"></param>
        </member>
        <member name="M:MapWinGeoProc.PointExporter.#ctor(System.Collections.Generic.IEnumerable{MapWindow.Interfaces.Geometries.ICoordinate})">
            <summary>
            creates a point exporter to export a list of points
            </summary>
            <param name="points"></param>
        </member>
        <member name="M:MapWinGeoProc.PointExporter.#ctor(MapWinGIS.Point[])">
            <summary>
            creates a point exporter from an array of MapWinGIS points
            </summary>
            <param name="mwPoints"></param>
        </member>
        <member name="M:MapWinGeoProc.PointExporter.PointToText(MapWindow.Interfaces.Geometries.ICoordinate,System.String)">
            <summary>
            Converts an x, y, z point to a formatted text string
            </summary>
            <param name="point">An [x,y,z] point</param>
            <param name="separator">the separator character (typically space, comma, semicolon)</param>
            <returns>A formatted string with coordinates divided by the separator character</returns>
        </member>
        <member name="M:MapWinGeoProc.PointExporter.ToTextFile(System.String,System.String)">
            <summary>
            Converts an array of x,y,z points to a text file.
            The separator can be specified (use comma or semicolon for CSV files)
            </summary>
            <param name="textFileName">name of output text file</param>
            <param name="separator">separator character (" ", "," ";" etc.)</param>
        </member>
        <member name="M:MapWinGeoProc.PointExporter.ToShapefile(System.String,System.String)">
            <summary>
            Converts a list of 3d-points to a point shapefile with z-value field.
            This function creates a new shapefile. The shapefile has two fields:
            a 'MWShapeId' field and a field which contains the z-value.
            </summary>
            <param name="ShpFileName">Name of the resulting point shapefile</param>
            <param name="ZFieldName">Name of the z-field in the shapefile</param>
        </member>
        <member name="T:MapWinGeoProc.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:RTools.Util.SoftwarePackage">
            <summary>
            This class represents an installed software package on a Windows
            system.  This has some static utility methods that will get the
            list of installed software packages, letting you uninstall one.
            </summary>
            <remarks>
            <para>This is motivated by the desire to get the version of an installed
            package, and by the fact that I wasn't able to find an easier way to 
            uninstall an Msi by product name (msiexec needs the product code).
            </para>
            <para>
            This looks for uninstallable packages in the registry in:
            HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall
            </para>
            </remarks>
        </member>
        <member name="M:RTools.Util.SoftwarePackage.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:RTools.Util.SoftwarePackage.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Constructor which sets all values.
            </summary>
            <param name="name">The product name.</param>
            <param name="productCode">The ProductCode.</param>
            <param name="uninstallString">The uninstall string.</param>
            <param name="displayVersion">The display version.</param>
        </member>
        <member name="M:RTools.Util.SoftwarePackage.Uninstall(System.Boolean)">
            <summary>
            Uninstall this setup.
            </summary>
            <param name="interactive">Whether or not to use the interactive
            interface.</param>
            <returns>bool - true for success, false for failure</returns>
        </member>
        <member name="M:RTools.Util.SoftwarePackage.ToString">
            <summary>
            ToString override.
            </summary>
            <returns></returns>
        </member>
        <member name="M:RTools.Util.SoftwarePackage.GetList">
            <summary>
            This returns an array of potentially unstallable SoftwarePackages.
            See SoftwarePackage.IsUninstallable to see whether this class
            can uninstall a particular SoftwarePackage.
            </summary>
            <returns>The SoftwarePackage[], null for error.</returns>
        </member>
        <member name="M:RTools.Util.SoftwarePackage.GetPackage(System.String)">
            <summary>
            Get a particular software package, by product name. This returns
            the first package found with the specified product name.
            </summary>
            <param name="productName">The product name of the package to 
            get.</param>
            <returns>SoftwarePackage</returns>
        </member>
        <member name="M:RTools.Util.SoftwarePackage.FindOne(System.String,RTools.Util.SoftwarePackage[])">
            <summary>
            This returns the requested SoftwarePackage only if it only appears 
            exactly once (as determined solely by name) in the input SoftwarePackage
            array.
            </summary>
            <param name="name">The product name to look for.</param>
            <param name="list">The array of SoftwarePackages to search.</param>
            <returns>The SoftwarePackage found, or null for none found or more
            than one found.</returns>
        </member>
        <member name="M:RTools.Util.SoftwarePackage.UninstallMultiple(System.String,System.Boolean)">
            <summary>
            Uninstall all uninstallable packages with the specified product name.
            </summary>
            <param name="productName">The product name of the packages to 
            uninstall.</param>
            <param name="interactive">Whether to run Msiexec in interactive mode
            or not.</param>
            <returns>bool - true for 1 or more found and uninstalled, false
            otherwise.</returns>
        </member>
        <member name="P:RTools.Util.SoftwarePackage.Name">
            <summary>Product name.</summary>
        </member>
        <member name="P:RTools.Util.SoftwarePackage.ProductCode">
            <summary>Product Code.</summary>
        </member>
        <member name="P:RTools.Util.SoftwarePackage.UninstallString">
            <summary>Uninstall string (a shell command to use to remove this SoftwarePackage).</summary>
        </member>
        <member name="P:RTools.Util.SoftwarePackage.DisplayVersion">
            <summary>The DisplayVersion for this SoftwarePackage.</summary>
        </member>
        <member name="P:RTools.Util.SoftwarePackage.IsUninstallable">
            <summary>Whether or not this SoftwarePackage is uninstallable (by this class).</summary>
        </member>
        <member name="T:RTools.Util.Opts">
            <summary>
            A command-line option parser similar to Perl's getopts. 
            This is for parsing command-line
            options like "-name foo -type theType -v -d".  This parses a string[]
            (like main usually takes) and collects argument information
            based on a parse specification.
            </summary>
            <remarks>
            <para>
            The UsageSpec endCapStyle parse is unfinished.  
            Basically the UsageSpec endCapStyle parse is more expressive than the
            ParseSpec endCapStyle parse (see below).  But in this current implementation,
            none of the additional expressiveness is used.  In other words
            this class does not currently do anything with the optional/required
            switches (-file [-help]) and does not do anything with the pipe
            operator.
            </para>
            <para>
            This takes two types of parse specifications, a perl getopts endCapStyle
            such as "file=s, type:s, v, d" (see the ParseSpec property), 
            or a unix usage endCapStyle such as
            "-file fileName -type [typeName] [-v|-d]" (see the UsageSpec property).
            </para>
            <para>
            For the ParseSpec property, the rules are as follows:
            1) The string is comma-separated like "file=s, type:s, v, d"
            2) = means must have an argument
            3) : means may have an argument
            </para>
            <para>
            For the UsageSpec property, the rules are as follows:
            1) Optional arguments must be enclosed in square brackets [].
            2) Argument names must be all word characters (- is considered to be a 
               word character).
            </para>
            <para>
            
            </para>
            <para>
            Here's an example use:
            <code>
            Opts opts = new Opts();
            opts.ParseSpec = "file=s, type:s, v, d");
             - or -
            opts.UsageSpec = "-file fileName -type [typeName] [-v|-d]";
            if (!opts.Parse(args, out errorMessage)) { // display error message and usage }
            if (opts.Options.ContainsKey("v")) // -v was specified
            if (!opts.Options.ContainsKey("file")) { error... // need -file specified }
            Console.WriteLine("-file specified is {0}", opts.Options["file"]);
            </code>
            </para>
            </remarks>
        </member>
        <member name="F:RTools.Util.Opts.log">
            <summary>
            Peer class for logging.
            </summary>
        </member>
        <member name="F:RTools.Util.Opts.options">
            <summary>
            Has all the info after the parse... presence, and arguments.
            </summary>
        </member>
        <member name="F:RTools.Util.Opts.unswitchedArgs">
            <summary>
            After the parse, has the arguments which were unswitched
            (not after an option like -file).
            </summary>
        </member>
        <member name="F:RTools.Util.Opts.parseSpec">
            <summary>
            The specification.
            </summary>
        </member>
        <member name="F:RTools.Util.Opts.requireArg">
            <summary>
            Set from the parseSpec. This is for options which require arguments.
            </summary>
        </member>
        <member name="F:RTools.Util.Opts.mayHaveArg">
            <summary>
            Set from the parseSpec. This is for options which may have arguments.
            </summary>
        </member>
        <member name="F:RTools.Util.Opts.noArg">
            <summary>
            Set from the parseSpec. This is for options which do not have arguments.
            </summary>
        </member>
        <member name="M:RTools.Util.Opts.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:RTools.Util.Opts.Initialize">
            <summary>
            Utility function, things common to constructors.
            </summary>
        </member>
        <member name="M:RTools.Util.Opts.Display">
            <summary>
            Display the state of this object.
            </summary>
        </member>
        <member name="M:RTools.Util.Opts.Display(System.String)">
            <summary>
            Display the state of this object, with a per-line prefix.
            </summary>
            <param name="prefix">The pre-line prefix.</param>
        </member>
        <member name="M:RTools.Util.Opts.DisplayParseSpec">
            <summary>
            Display the information gained from the parseSpec.
            </summary>
        </member>
        <member name="M:RTools.Util.Opts.DisplayParseSpec(System.String)">
            <summary>
            Display the information gained from the parseSpec.
            </summary>
            <param name="prefix">A prefix to prepend to each line.</param>
        </member>
        <member name="M:RTools.Util.Opts.IsSwitch(System.String)">
            <summary>
            Utility method to determine whether a string is a switch or not.
            This currently just checks if it starts with a - which is not
            followed by a digit.
            </summary>
            <param name="s">The string to test.</param>
            <returns>bool - true for yes it's a switch</returns>
        </member>
        <member name="M:RTools.Util.Opts.Parse(System.String[],System.String@)">
            <summary>
            Parse the options string[], determine if the parse spec
            requirements are met, and provide an error message string
            if not.
            </summary>
            <param name="args">The string[] to parse.</param>
            <param name="errorMessage">Output error message. This
            is set if the input options don't have all the pieces
            required by the parseSpec string.</param>
            <returns>bool - true if parseSpec requirements are met, 
            false otherwise.</returns>
        </member>
        <member name="M:RTools.Util.Opts.TestSelf">
            <summary>
            Simple self test.
            </summary>
            <returns>bool - true for success, false for failure.</returns>
        </member>
        <member name="P:RTools.Util.Opts.ParseSpec">
            <summary>
            The specification of what options to look for, which
            have arguments, etc.  This is the "name=s, type:s, v, d"
            endCapStyle.
            </summary>
        </member>
        <member name="P:RTools.Util.Opts.UsageSpec">
            <summary>
            The specification of what options to look for, which
            have arguments, etc.  This is the "-name fileName [-v|-d]"
            endCapStyle.
            </summary>
        </member>
        <member name="P:RTools.Util.Opts.Options">
            <summary>
            This hashtable is built during Parse.  This contains the results
            of the parse for switches (options). Options which don't take
            arguments will map to bool True.  Options which may have arguments
            will map to the argument string if present, and null if not present.
            Options which must have arguments will map to the argument string
            if the Parse succeeds.
            </summary>
        </member>
        <member name="P:RTools.Util.Opts.UnswitchedArgs">
            <summary>
            These are the rest of the command line arguments which are
            not associated with options (switches like "-file").
            </summary>
        </member>
        <member name="P:RTools.Util.Opts.Verbosity">
            <summary>
            The verbosity level for this object's Logger.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Utilities.ReverseOrder">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.ReverseOrder.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.ReverseOrder.Compare(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Utilities.CoordinateCountFilter">
            <summary>
            A <c>CoordinateFilter</c> that counts the total number of coordinates
            in a <c>Geometry</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.CoordinateCountFilter.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.CoordinateCountFilter.Filter(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="coord"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Utilities.CoordinateCountFilter.Count">
            <summary>
            Returns the result of the filtering.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Valid.QuadtreeNestedRingTester">
            <summary>
            Tests whether any of a set of <c>LinearRing</c>s are
            nested inside another ring in the set, using a <c>Quadtree</c>
            index to speed up the comparisons.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.QuadtreeNestedRingTester.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            
            </summary>
            <param name="graph"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.QuadtreeNestedRingTester.Add(MapWinGeoProc.NTS.Topology.Geometries.LinearRing)">
            <summary>
            
            </summary>
            <param name="ring"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.QuadtreeNestedRingTester.IsNonNested">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.QuadtreeNestedRingTester.BuildQuadtree">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Valid.QuadtreeNestedRingTester.NestedPoint">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateComputer">
            <summary>
            Computes the topological relationship between two Geometries.
            RelateComputer does not need to build a complete graph structure to compute
            the IntersectionMatrix.  The relationship between the geometries can
            be computed by simply examining the labelling of edges incident on each node.
            RelateComputer does not currently support arbitrary GeometryCollections.
            This is because GeometryCollections can contain overlapping Polygons.
            In order to correct compute relate on overlapping Polygons, they
            would first need to be noded and merged (if not explicitly, at least
            implicitly).
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateComputer.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph[])">
            <summary>
            
            </summary>
            <param name="arg"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateComputer.ComputeIM">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateComputer.InsertEdgeEnds(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="ee"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateComputer.ComputeProperIntersectionIM(MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector,MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix)">
            <summary>
            
            </summary>
            <param name="intersector"></param>
            <param name="im"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateComputer.CopyNodesAndLabels(System.Int32)">
            <summary>
            Copy all nodes from an arg point into this graph.
            The node label in the arg point overrides any previously computed
            label for that argIndex.
            (E.g. a node may be an intersection node with
            a computed label of Boundary,
            but in the original arg Geometry it is actually
            in the interior due to the Boundary Determination Rule)
            </summary>
            <param name="argIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateComputer.ComputeIntersectionNodes(System.Int32)">
            <summary>
            Insert nodes for all intersections on the edges of a Geometry.
            Label the created nodes the same as the edge label if they do not already have a label.
            This allows nodes created by either self-intersections or
            mutual intersections to be labelled.
            Endpoint nodes will already be labelled from when they were inserted.
            </summary>
            <param name="argIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateComputer.LabelIntersectionNodes(System.Int32)">
            <summary>
            For all intersections on the edges of a Geometry,
            label the corresponding node IF it doesn't already have a label.
            This allows nodes created by either self-intersections or
            mutual intersections to be labelled.
            Endpoint nodes will already be labelled from when they were inserted.
            </summary>
            <param name="argIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateComputer.ComputeDisjointIM(MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix)">
            <summary>
            If the Geometries are disjoint, we need to enter their dimension and
            boundary dimension in the Ext rows in the IM
            </summary>
            <param name="im"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateComputer.LabelNodeEdges">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateComputer.UpdateIM(MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix)">
            <summary>
            Update the IM with the sum of the IMs for each component.
            </summary>
            <param name="im"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateComputer.LabelIsolatedEdges(System.Int32,System.Int32)">
            <summary> 
            Processes isolated edges by computing their labelling and adding them
            to the isolated edges list.
            Isolated edges are guaranteed not to touch the boundary of the target (since if they
            did, they would have caused an intersection to be computed and hence would
            not be isolated).
            </summary>
            <param name="thisIndex"></param>
            <param name="targetIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateComputer.LabelIsolatedEdge(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge,System.Int32,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Label an isolated edge of a graph with its relationship to the target point.
            If the target has dim 2 or 1, the edge can either be in the interior or the exterior.
            If the target has dim 0, the edge must be in the exterior.
            </summary>
            <param name="e"></param>
            <param name="targetIndex"></param>
            <param name="target"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateComputer.LabelIsolatedNodes">
            <summary>
            Isolated nodes are nodes whose labels are incomplete
            (e.g. the location for one Geometry is null).
            This is the case because nodes in one graph which don't intersect
            nodes in the other are not completely labelled by the initial process
            of adding nodes to the nodeList.
            To complete the labelling we need to check for nodes that lie in the
            interior of edges, and in the interior of areas.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateComputer.LabelIsolatedNode(MapWinGeoProc.NTS.Topology.GeometriesGraph.Node,System.Int32)">
            <summary>
            Label an isolated node with its relationship to the target point.
            </summary>
            <param name="n"></param>
            <param name="targetIndex"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Polygonize.EdgeRing">
            <summary>
            Represents a ring of <c>PolygonizeDirectedEdge</c>s which form
            a ring of a polygon.  The ring may be either an outer shell or a hole.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.EdgeRing.FindEdgeRingContaining(MapWinGeoProc.NTS.Topology.Operation.Polygonize.EdgeRing,System.Collections.IList)">
            <summary>
            Find the innermost enclosing shell EdgeRing containing the argument EdgeRing, if any.
            The innermost enclosing ring is the <i>smallest</i> enclosing ring.
            The algorithm used depends on the fact that:
            ring A contains ring B iff envelope(ring A) contains envelope(ring B).
            This routine is only safe to use if the chosen point of the hole
            is known to be properly contained in a shell
            (which is guaranteed to be the case if the hole does not touch its shell).
            </summary>
            <param name="shellList"></param>
            <param name="testEr"></param>
            <returns>Containing EdgeRing, if there is one, OR
            null if no containing EdgeRing is found.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.EdgeRing.PtNotInList(MapWindow.Interfaces.Geometries.ICoordinate[],MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Finds a point in a list of points which is not contained in another list of points.
            </summary>
            <param name="testPts">The <c>Coordinate</c>s to test.</param>
            <param name="pts">An array of <c>Coordinate</c>s to test the input points against.</param>
            <returns>A <c>Coordinate</c> from <c>testPts</c> which is not in <c>pts</c>, 
            or <c>null</c>.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.EdgeRing.IsInList(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Tests whether a given point is in an array of points.
            Uses a value-based test.
            </summary>
            <param name="pt">A <c>Coordinate</c> for the test point.</param>
            <param name="pts">An array of <c>Coordinate</c>s to test,</param>
            <returns><c>true</c> if the point is in the array.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.EdgeRing.#ctor(MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            
            </summary>
            <param name="factory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.EdgeRing.Add(MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge)">
            <summary>
            Adds a DirectedEdge which is known to form part of this ring.
            </summary>
            <param name="de">The DirectedEdge to add.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.EdgeRing.AddHole(MapWindow.Interfaces.Geometries.ILinearRing)">
            <summary>
            Adds a hole to the polygon formed by this ring.
            </summary>
            <param name="hole">The LinearRing forming the hole.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.EdgeRing.AddEdge(MapWindow.Interfaces.Geometries.ICoordinate[],System.Boolean,MapWinGeoProc.NTS.Topology.Geometries.CoordinateList)">
            <summary>
            
            </summary>
            <param name="coords"></param>
            <param name="isForward"></param>
            <param name="coordList"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Polygonize.EdgeRing.IsHole">
            <summary>
            Tests whether this ring is a hole.
            Due to the way the edges in the polyongization graph are linked,
            a ring is a hole if it is oriented counter-clockwise.
            </summary>
            <returns><c>true</c> if this ring is a hole.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Polygonize.EdgeRing.Polygon">
            <summary>
            Computes and returns the Polygon formed by this ring and any contained holes.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Polygonize.EdgeRing.IsValid">
            <summary>
            Tests if the LinearRing ring formed by this edge ring is topologically valid.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Polygonize.EdgeRing.Coordinates">
            <summary>
            Computes and returns the list of coordinates which are contained in this ring.
            The coordinatea are computed once only and cached.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Polygonize.EdgeRing.LineString">
            <summary>
            Gets the coordinates for this ring as a <c>LineString</c>.
            Used to return the coordinates in this ring
            as a valid point, when it has been detected that the ring is topologically
            invalid.
            </summary>        
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Polygonize.EdgeRing.Ring">
            <summary>
            Returns this ring as a LinearRing, or null if an Exception occurs while
            creating it (such as a topology problem). Details of problems are written to
            standard output.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Overlay.SpatialFunctions">
            <summary>
            The spatial functions supported by this class.
            These operations implement various bool combinations of the resultants of the overlay.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Overlay.SpatialFunctions.Intersection">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Overlay.SpatialFunctions.Union">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Overlay.SpatialFunctions.Difference">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Overlay.SpatialFunctions.SymDifference">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp">
            <summary>
            Computes the overlay of two <c>Geometry</c>s.  The overlay
            can be used to determine any bool combination of the geometries.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.GeometryGraphOperation">
            <summary>
            The base class for operations that require <c>GeometryGraph</c>s.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.GeometryGraphOperation.resultPrecisionModel">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.GeometryGraphOperation.arg">
            <summary>
            The operation args into an array so they can be accessed by index.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.GeometryGraphOperation.#ctor(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="g0"></param>
            <param name="g1"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.GeometryGraphOperation.#ctor(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="g0"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.GeometryGraphOperation.GetArgGeometry(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.GeometryGraphOperation.lineIntersector">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.GeometryGraphOperation.ComputationPrecision">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.Overlay(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.IGeometry,MapWinGeoProc.NTS.Topology.Operation.Overlay.SpatialFunctions)">
            <summary>
            
            </summary>
            <param name="geom0"></param>
            <param name="geom1"></param>
            <param name="opCode"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.IsResultOfOp(MapWinGeoProc.NTS.Topology.GeometriesGraph.Label,MapWinGeoProc.NTS.Topology.Operation.Overlay.SpatialFunctions)">
            <summary>
            
            </summary>
            <param name="label"></param>
            <param name="opCode"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.IsResultOfOp(MapWindow.Interfaces.Geometries.Locations,MapWindow.Interfaces.Geometries.Locations,MapWinGeoProc.NTS.Topology.Operation.Overlay.SpatialFunctions)">
            <summary>
            This method will handle arguments of Location.NULL correctly.
            </summary>
            <returns><c>true</c> if the locations correspond to the opCode.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.#ctor(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="g0"></param>
            <param name="g1"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.GetResultGeometry(MapWinGeoProc.NTS.Topology.Operation.Overlay.SpatialFunctions)">
            <summary>
            
            </summary>
            <param name="funcCode"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.ComputeOverlay(MapWinGeoProc.NTS.Topology.Operation.Overlay.SpatialFunctions)">
            <summary>
            
            </summary>
            <param name="opCode"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.InsertUniqueEdges(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="edges"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.InsertUniqueEdge(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge)">
            <summary>
            Insert an edge from one of the noded input graphs.
            Checks edges that are inserted to see if an
            identical edge already exists.
            If so, the edge is not inserted, but its label is merged
            with the existing edge.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.ComputeLabelsFromDepths">
            <summary>
            Update the labels for edges according to their depths.
            For each edge, the depths are first normalized.
            Then, if the depths for the edge are equal,
            this edge must have collapsed into a line edge.
            If the depths are not equal, update the label
            with the locations corresponding to the depths
            (i.e. a depth of 0 corresponds to a Location of Exterior,
            a depth of 1 corresponds to Interior)
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.ReplaceCollapsedEdges">
            <summary>
            If edges which have undergone dimensional collapse are found,
            replace them with a new edge which is a L edge
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.CopyPoints(System.Int32)">
            <summary>
            Copy all nodes from an arg point into this graph.
            The node label in the arg point overrides any previously computed
            label for that argIndex.
            (E.g. a node may be an intersection node with
            a previously computed label of Boundary,
            but in the original arg Geometry it is actually
            in the interior due to the Boundary Determination Rule)
            </summary>
            <param name="argIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.ComputeLabelling">
            <summary> 
            Compute initial labelling for all DirectedEdges at each node.
            In this step, DirectedEdges will acquire a complete labelling
            (i.e. one with labels for both Geometries)
            only if they
            are incident on a node which has edges for both Geometries
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.MergeSymLabels">
            <summary> 
            For nodes which have edges from only one Geometry incident on them,
            the previous step will have left their dirEdges with no labelling for the other
            Geometry.  However, the sym dirEdge may have a labelling for the other
            Geometry, so merge the two labels.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.UpdateNodeLabelling">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.LabelIncompleteNodes">
            <summary>
            Incomplete nodes are nodes whose labels are incomplete.
            (e.g. the location for one Geometry is null).
            These are either isolated nodes,
            or nodes which have edges from only a single Geometry incident on them.
            Isolated nodes are found because nodes in one graph which don't intersect
            nodes in the other are not completely labelled by the initial process
            of adding nodes to the nodeList.
            To complete the labelling we need to check for nodes that lie in the
            interior of edges, and in the interior of areas.
            When each node labelling is completed, the labelling of the incident
            edges is updated, to complete their labelling as well.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.LabelIncompleteNode(MapWinGeoProc.NTS.Topology.GeometriesGraph.Node,System.Int32)">
            <summary>
            Label an isolated node with its relationship to the target point.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.FindResultAreaEdges(MapWinGeoProc.NTS.Topology.Operation.Overlay.SpatialFunctions)">
            <summary>
            Find all edges whose label indicates that they are in the result area(s),
            according to the operation being performed.  Since we want polygon shells to be
            oriented CW, choose dirEdges with the interior of the result on the RHS.
            Mark them as being in the result.
            Interior Area edges are the result of dimensional collapses.
            They do not form part of the result area boundary.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.CancelDuplicateResultEdges">
            <summary>
            If both a dirEdge and its sym are marked as being in the result, cancel
            them out.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.IsCoveredByLA(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            This method is used to decide if a point node should be included in the result or not.
            </summary>
            <returns><c>true</c> if the coord point is covered by a result Line or Area point.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.IsCoveredByA(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            This method is used to decide if an L edge should be included in the result or not.
            </summary>
            <returns><c>true</c> if the coord point is covered by a result Area point.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.IsCovered(MapWindow.Interfaces.Geometries.ICoordinate,System.Collections.IList)">
            <returns>
            <c>true</c> if the coord is located in the interior or boundary of
            a point in the list.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.ComputeGeometry(System.Collections.IList,System.Collections.IList,System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="resultPointList"></param>
            <param name="resultLineList"></param>
            <param name="resultPolyList"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp.Graph">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMergeEdge">
            <summary>
            An edge of a <c>LineMergeGraph</c>. The <c>marked</c> field indicates
            whether this Edge has been logically deleted from the graph.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMergeEdge.#ctor(MapWinGeoProc.NTS.Topology.Geometries.LineString)">
            <summary>
            Constructs a LineMergeEdge with vertices given by the specified LineString.
            </summary>
            <param name="line"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMergeEdge.Line">
            <summary>
            Returns the LineString specifying the vertices of this edge.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.IsSimpleOp">
            <summary>
            Tests whether a <c>Geometry</c> is simple.
            Only <c>Geometry</c>s whose definition allows them
            to be simple or non-simple are tested.  (E.g. Polygons must be simple
            by definition, so no test is provided.  To test whether a given Polygon is valid,
            use <c>Geometry.IsValid</c>)
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.IsSimpleOp.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.IsSimpleOp.IsSimple(MapWinGeoProc.NTS.Topology.Geometries.LineString)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.IsSimpleOp.IsSimple(MapWinGeoProc.NTS.Topology.Geometries.MultiLineString)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.IsSimpleOp.IsSimple(MapWinGeoProc.NTS.Topology.Geometries.MultiPoint)">
            <summary>
            A MultiPoint is simple if it has no repeated points.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.IsSimpleOp.IsSimpleLinearGeometry(MapWinGeoProc.NTS.Topology.Geometries.Geometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.IsSimpleOp.HasNonEndpointIntersection(MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            For all edges, check if there are any intersections which are NOT at an endpoint.
            The Geometry is not simple if there are intersections not at endpoints.
            </summary>
            <param name="graph"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.IsSimpleOp.HasClosedEndpointIntersection(MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph)">
            <summary> 
            Test that no edge intersection is the
            endpoint of a closed line.  To check this we compute the
            degree of each endpoint. The degree of endpoints of closed lines
            must be exactly 2.
            </summary>
            <param name="graph"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.IsSimpleOp.AddEndpoint(System.Collections.IDictionary,MapWindow.Interfaces.Geometries.ICoordinate,System.Boolean)">
            <summary>
            Add an endpoint to the map, creating an entry for it if none exists.
            </summary>
            <param name="endPoints"></param>
            <param name="p"></param>
            <param name="isClosed"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.IsSimpleOp.EndpointInfo">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.IsSimpleOp.EndpointInfo.#ctor(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="pt"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.IsSimpleOp.EndpointInfo.AddEndpoint(System.Boolean)">
            <summary>
            
            </summary>
            <param name="isClosed"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.IsSimpleOp.EndpointInfo.Point">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.IsSimpleOp.EndpointInfo.IsClosed">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.IsSimpleOp.EndpointInfo.Degree">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Distance.ConnectedElementLocationFilter">
            <summary>
            A ConnectedElementPointFilter extracts a single point
            from each connected element in a Geometry
            (e.g. a polygon, linestring or point)
            and returns them in a list. The elements of the list are 
            <c>com.vividsolutions.jts.operation.distance.GeometryLocation</c>s.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.ConnectedElementLocationFilter.GetLocations(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Returns a list containing a point from each Polygon, LineString, and Point
            found inside the specified point. Thus, if the specified point is
            not a GeometryCollection, an empty list will be returned. The elements of the list 
            are <c>com.vividsolutions.jts.operation.distance.GeometryLocation</c>s.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.ConnectedElementLocationFilter.#ctor(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="locations"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.ConnectedElementLocationFilter.Filter(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferOp">
            <summary>
            Computes the buffer of a point, for both positive and negative buffer distances.    
            In GIS, the buffer of a point is defined as
            the Minkowski sum or difference of the point
            with a circle with radius equal to the absolute value of the buffer distance.
            In the CAD/CAM world buffers are known as offset curves.
            Since true buffer curves may contain circular arcs,
            computed buffer polygons can only be approximations to the true point.
            The user can control the accuracy of the curve approximation by specifying
            the number of linear segments with which to approximate a curve.
            The end cap endCapStyle of a linear buffer may be specified. The
            following end cap styles are supported:
            <para>
            {CAP_ROUND} - the usual round end caps
            {CAP_BUTT} - end caps are truncated flat at the line ends
            {CAP_SQUARE} - end caps are squared off at the buffer distance beyond the line ends
            </para>
            The computation uses an algorithm involving iterated noding and precision reduction
            to provide a high degree of robustness.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferOp.PrecisionScaleFactor(MapWindow.Interfaces.Geometries.IGeometry,System.Double,System.Int32)">
            <summary>
            Compute a reasonable scale factor to limit the precision of
            a given combination of Geometry and buffer distance.
            The scale factor is based on a heuristic.
            </summary>
            <param name="g">The Geometry being buffered.</param>
            <param name="distance">The buffer distance.</param>
            <param name="maxPrecisionDigits">The mzx # of digits that should be allowed by
            the precision determined by the computed scale factor.</param>
            <returns>A scale factor that allows a reasonable amount of precision for the buffer computation.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferOp.Buffer(MapWindow.Interfaces.Geometries.IGeometry,System.Double)">
            <summary>
            Computes the buffer of a point for a given buffer distance.
            </summary>
            <param name="g">The point to buffer.</param>
            <param name="distance">The buffer distance.</param>
            <returns> The buffer of the input point.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferOp.Buffer(MapWinGeoProc.NTS.Topology.Geometries.Geometry,System.Double,MapWindow.Interfaces.Geometries.BufferStyles)">
            <summary>
            Computes the buffer of a point for a given buffer distance,
            using the given Cap Style for borders of the point.
            </summary>
            <param name="g">The point to buffer.</param>
            <param name="distance">The buffer distance.</param>        
            <param name="endCapStyle">Cap Style to use for compute buffer.</param>
            <returns> The buffer of the input point.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferOp.Buffer(MapWinGeoProc.NTS.Topology.Geometries.Geometry,System.Double,System.Int32)">
            <summary>
            Computes the buffer for a point for a given buffer distance
            and accuracy of approximation.
            </summary>
            <param name="g">The point to buffer.</param>
            <param name="distance">The buffer distance.</param>
            <param name="quadrantSegments">The number of segments used to approximate a quarter circle.</param>
            <returns>The buffer of the input point.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferOp.Buffer(MapWindow.Interfaces.Geometries.IGeometry,System.Double,System.Int32,MapWindow.Interfaces.Geometries.BufferStyles)">
            <summary>
            Computes the buffer for a point for a given buffer distance
            and accuracy of approximation.
            </summary>
            <param name="g">The point to buffer.</param>
            <param name="distance">The buffer distance.</param>
            <param name="quadrantSegments">The number of segments used to approximate a quarter circle.</param>
            <param name="endCapStyle">Cap Style to use for compute buffer.</param>
            <returns>The buffer of the input point.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferOp.#ctor(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Initializes a buffer computation for the given point.
            </summary>
            <param name="g">The point to buffer.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferOp.GetResultGeometry(System.Double)">
            <summary>
            
            </summary>
            <param name="distance"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferOp.GetResultGeometry(System.Double,System.Int32)">
            <summary>
            
            </summary>
            <param name="distance"></param>
            <param name="quadrantSegments"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferOp.ComputeGeometry">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferOp.BufferOriginalPrecision">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferOp.BufferFixedPrecision(System.Int32)">
            <summary>
            
            </summary>
            <param name="precisionDigits"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferOp.EndCapStyle">
            <summary> 
            Specifies the end cap endCapStyle of the generated buffer.
            The styles supported are CapRound, CapButt, and CapSquare.
            The default is CapRound.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferOp.QuadrantSegments">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.Snapround.HotPixel">
            <summary>
            Implements a "hot pixel" as used in the Snap Rounding algorithm.
            A hot pixel contains the interior of the tolerance square and the boundary
            minus the top and right segments.
            The hot pixel operations are all computed in the integer domain
            to avoid rounding problems.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.HotPixel.#ctor(MapWindow.Interfaces.Geometries.ICoordinate,System.Double,MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector)">
            <summary>
            Initializes a new instance of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.Snapround.HotPixel"/> class.
            </summary>
            <param name="pt"></param>
            <param name="scaleFactor"></param>
            <param name="li"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.HotPixel.GetSafeEnvelope">
            <summary>
            Returns a "safe" envelope that is guaranteed to contain the hot pixel.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.HotPixel.InitCorners(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="pt"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.HotPixel.Scale(System.Double)">
            <summary>
            
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.HotPixel.Intersects(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.HotPixel.CopyScaled(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="p"></param>
            <param name="pScaled"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.HotPixel.IntersectsScaled(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.HotPixel.IntersectsToleranceSquare(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Tests whether the segment p0-p1 intersects the hot pixel tolerance square.
            Because the tolerance square point set is partially open (along the
            top and right) the test needs to be more sophisticated than
            simply checking for any intersection.  However, it
            can take advantage of the fact that because the hot pixel edges
            do not lie on the coordinate grid.  It is sufficient to check
            if there is at least one of:
             - a proper intersection with the segment and any hot pixel edge.
             - an intersection between the segment and both the left and bottom edges.
             - an intersection between a segment endpoint and the hot pixel coordinate.
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.HotPixel.IntersectsPixelClosure(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Test whether the given segment intersects
            the closure of this hot pixel.
            This is NOT the test used in the standard snap-rounding
            algorithm, which uses the partially closed tolerance square instead.
            This routine is provided for testing purposes only.
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.Snapround.HotPixel.Coordinate">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.SegmentStringDissolver">
             <summary>
             Dissolves a noded collection of <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s to produce
             a set of merged linework with unique segments.
             A custom merging strategy can be applied when two identical (up to orientation)
             strings are dissolved together.
             The default merging strategy is simply to discard the merged string.
            <para>
             A common use for this class is to merge noded edges
             while preserving topological labelling.
             </para>
             </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentStringDissolver.#ctor(MapWinGeoProc.NTS.Topology.Noding.SegmentStringDissolver.ISegmentStringMerger)">
            <summary>
            Creates a dissolver with a user-defined merge strategy.
            </summary>
            <param name="merger"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentStringDissolver.#ctor">
            <summary>
            Creates a dissolver with the default merging strategy.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentStringDissolver.Dissolve(System.Collections.ICollection)">
            <summary>
            Dissolve all <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s in the input <see cref="T:System.Collections.ICollection"/>.
            </summary>
            <param name="segStrings"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentStringDissolver.Add(MapWinGeoProc.NTS.Topology.Noding.OrientedCoordinateArray,MapWinGeoProc.NTS.Topology.Noding.SegmentString)">
            <summary>
            
            </summary>
            <param name="oca"></param>
            <param name="segString"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentStringDissolver.Dissolve(MapWinGeoProc.NTS.Topology.Noding.SegmentString)">
            <summary>
            Dissolve the given <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>.
            </summary>
            <param name="segString"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentStringDissolver.FindMatching(MapWinGeoProc.NTS.Topology.Noding.OrientedCoordinateArray,MapWinGeoProc.NTS.Topology.Noding.SegmentString)">
            <summary>
            
            </summary>
            <param name="oca"></param>
            <param name="segString"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.SegmentStringDissolver.Dissolved">
            <summary>
            Gets the collection of dissolved (i.e. unique) <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.SegmentStringDissolver.ISegmentStringMerger">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentStringDissolver.ISegmentStringMerger.Merge(MapWinGeoProc.NTS.Topology.Noding.SegmentString,MapWinGeoProc.NTS.Topology.Noding.SegmentString,System.Boolean)">
            <summary>
            Updates the context data of a <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>
            when an identical (up to orientation) one is found during dissolving.
            </summary>
            <param name="mergeTarget">The segment string to update.</param>
            <param name="ssToMerge">The segment string being dissolved.</param>
            <param name="isSameOrientation">
            <c>true</c> if the strings are in the same direction,
            <c>false</c> if they are opposite.
            </param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.OrientedCoordinateArray">
            <summary>
             Allows comparing <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> arrays in an orientation-independent way.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.OrientedCoordinateArray.#ctor(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Creates a new <see cref="T:MapWinGeoProc.NTS.Topology.Noding.OrientedCoordinateArray"/>}
            for the given <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> array.
            </summary>
            <param name="pts"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.OrientedCoordinateArray.Orientation(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Computes the canonical orientation for a coordinate array.
            </summary>
            <param name="pts"></param>
            <returns>
            <c>true</c> if the points are oriented forwards, or
            <c>false</c>if the points are oriented in reverse.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.OrientedCoordinateArray.CompareTo(System.Object)">
            <summary>
            Compares two <see cref="T:MapWinGeoProc.NTS.Topology.Noding.OrientedCoordinateArray"/>s for their relative order.
            </summary>
            <param name="o1"></param>
            <returns>
            -1 this one is smaller, or
             0 the two objects are equal, or
             1 this one is greater.
            </returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.MCIndexNoder">
            <summary>
            Nodes a set of <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s using a index based
            on <see cref="T:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain"/>s and a <see cref="T:MapWinGeoProc.NTS.Topology.Index.ISpatialIndex"/>.
            The <see cref="T:MapWinGeoProc.NTS.Topology.Index.ISpatialIndex"/> used should be something that supports
            envelope (range) queries efficiently (such as a <see cref="T:MapWinGeoProc.NTS.Topology.Index.Quadtree.Quadtree"/>
            or <see cref="T:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree"/>.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.SinglePassNoder">
            <summary>
            Base class for <see cref="T:MapWinGeoProc.NTS.Topology.Noding.INoder"/>s which make a single pass to find intersections.
            This allows using a custom <see cref="T:MapWinGeoProc.NTS.Topology.Noding.ISegmentIntersector"/>
            (which for instance may simply identify intersections, rather than insert them).
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SinglePassNoder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SinglePassNoder"/> class.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SinglePassNoder.#ctor(MapWinGeoProc.NTS.Topology.Noding.ISegmentIntersector)">
            <summary>
            Initializes a new instance of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SinglePassNoder"/> class.
            </summary>
            <param name="segInt">The <see cref="T:MapWinGeoProc.NTS.Topology.Noding.ISegmentIntersector"/> to use.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SinglePassNoder.ComputeNodes(System.Collections.IList)">
            <summary>
            Computes the noding for a collection of <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s.
            Some Noders may add all these nodes to the input <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s;
            others may only add some or none at all.
            </summary>
            <param name="segStrings"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SinglePassNoder.GetNodedSubstrings">
            <summary>
            Returns a <see cref="T:System.Collections.IList"/> of fully noded <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s.
            The <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s have the same context as their parent.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.SinglePassNoder.SegmentIntersector">
            <summary>
            Gets/sets the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.ISegmentIntersector"/> to use with this noder.
            A <see cref="T:MapWinGeoProc.NTS.Topology.Noding.ISegmentIntersector"/>  will normally add intersection nodes
            to the input segment strings, but it may not - it may
            simply record the presence of intersections.
            However, some <see cref="T:MapWinGeoProc.NTS.Topology.Noding.INoder"/>s may require that intersections be added.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.MCIndexNoder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.MCIndexNoder"/> class.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.MCIndexNoder.#ctor(MapWinGeoProc.NTS.Topology.Noding.ISegmentIntersector)">
            <summary>
            Initializes a new instance of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.MCIndexNoder"/> class.
            </summary>
            <param name="segInt">The <see cref="T:MapWinGeoProc.NTS.Topology.Noding.ISegmentIntersector"/> to use.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.MCIndexNoder.GetNodedSubstrings">
            <summary>
            Returns a <see cref="T:System.Collections.IList"/> of fully noded <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s.
            The <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s have the same context as their parent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.MCIndexNoder.ComputeNodes(System.Collections.IList)">
            <summary>
            Computes the noding for a collection of <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s.
            Some Noders may add all these nodes to the input <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s;
            others may only add some or none at all.
            </summary>
            <param name="inputSegStrings"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.MCIndexNoder.IntersectChains">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.MCIndexNoder.Add(MapWinGeoProc.NTS.Topology.Noding.SegmentString)">
            <summary>
            
            </summary>
            <param name="segStr"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.MCIndexNoder.MonotoneChains">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.MCIndexNoder.Index">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.MCIndexNoder.SegmentOverlapAction">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainOverlapAction">
            <summary> 
            The action for the internal iterator for performing
            overlap queries on a MonotoneChain.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainOverlapAction.TempEnv1">
            <summary>
            This envelope is used during the MonotoneChain search process.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainOverlapAction.TempEnv2">
            <summary>
            This envelope is used during the MonotoneChain search process. 
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainOverlapAction.overlapSeg1">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainOverlapAction.overlapSeg2">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainOverlapAction.Overlap(MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain,System.Int32,MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain,System.Int32)">
            <summary>
            This function can be overridden if the original chains are needed.
            </summary>
            <param name="mc1"></param>
            <param name="start1">The index of the start of the overlapping segment from mc1.</param>
            <param name="mc2"></param>
            <param name="start2">The index of the start of the overlapping segment from mc2.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainOverlapAction.Overlap(MapWinGeoProc.NTS.Topology.Geometries.LineSegment,MapWinGeoProc.NTS.Topology.Geometries.LineSegment)">
            <summary> 
            This is a convenience function which can be overridden to obtain the actual
            line segments which overlap.
            </summary>
            <param name="seg1"></param>
            <param name="seg2"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.MCIndexNoder.SegmentOverlapAction.#ctor(MapWinGeoProc.NTS.Topology.Noding.ISegmentIntersector)">
            <summary>
            Initializes a new instance of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.MCIndexNoder.SegmentOverlapAction"/> class.
            </summary>
            <param name="si">The <see cref="T:MapWinGeoProc.NTS.Topology.Noding.ISegmentIntersector"/></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.MCIndexNoder.SegmentOverlapAction.Overlap(MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain,System.Int32,MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain,System.Int32)">
            <summary>
            
            </summary>
            <param name="mc1"></param>
            <param name="start1"></param>
            <param name="mc2"></param>
            <param name="start2"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.MyShapeFileWriter">
            <summary>
             A class for writing shapefiles data.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.IO.MyShapeFileWriter.shapeWriter">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MyShapeFileWriter.#ctor">
            <summary>
            Default empty constructor
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MyShapeFileWriter.Write(MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection,System.String)">
            <summary>
            Writes an homogeneus <c>GometryCollection</c> into a binary shapefile.
            </summary>
            <param name="geometries">If geometries are not of the same type throws <c>System.ArgumentException</c>.</param>
            <param name="shapepath">Path of the shapefile to create: will be created a new file using the given path.
            if file exists throws <c>System.IO.IOException</c>.</param>        
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MyShapeFileWriter.Write(MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection,System.IO.Stream)">
            <summary>
            Writes an homogeneus <c>GometryCollection</c> into a binary stream.
            </summary>
            <param name="geometries"></param>
            <param name="stream"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MyShapeFileWriter.Write(MapWinGeoProc.NTS.Topology.Geometries.Geometry,System.IO.BinaryWriter,MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryWriter)">
            <summary>
            
            </summary>
            <param name="geometry"></param>
            <param name="leWriter"></param>
            <param name="beWriter"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MyShapeFileWriter.GetShapeType(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MyShapeFileWriter.WriteHeaderFile(MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection,System.IO.BinaryWriter,MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryWriter,System.Int32)">
            <summary>
            
            </summary>
            <param name="geometries"></param>
            <param name="beWriter">Big Endian Writer</param>
            <param name="leWriter">Little Endian Endian Writer</param>
            <param name="streamLength"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MyShapeFileWriter.WriteFeatureHeader(MapWinGeoProc.NTS.Topology.Geometries.Geometry,MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryWriter)">
            <summary>
            
            </summary>
            <param name="geometry"></param>
            <param name="beWriter"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.MyShapeFileReader">
            <summary>
             A class for reading shapefiles data.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.IO.MyShapeFileReader.shapeReader">
            <summary>
            Shape features reader.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MyShapeFileReader.#ctor">
            <summary>
            Default empty constructor
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MyShapeFileReader.#ctor(MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory)">
            <summary>
            
            </summary>
            <param name="factory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MyShapeFileReader.Read(System.String)">
            <summary>
            Reads a shapefile containing geographic data, 
            and returns a collection of all the features contained.
            Since NTS Geometry Model not support Z and M data, those informations are ignored if presents in shapefile.
            </summary>
            <param name="filepath">Shapefile path.</param>
            <returns><c>GeometryCollection</c> containing all geometries in shapefile.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MyShapeFileReader.Read(System.IO.Stream)">
            <summary>
            Reads a generic stream containing geographic data saved as shapefile structure, 
            and returns a collection of all the features contained.
            Since NTS Geometry Model not support Z and M data, those informations are ignored if presents in shapefile.
            </summary>
            <param name="stream">Shapefile data stream.</param>
            <returns><c>GeometryCollection</c> containing all geometries in shapefile.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MyShapeFileReader.ReadPointData(System.IO.Stream)">
            <summary>
            Reads Point shapefile
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MyShapeFileReader.ReadFeatureHeader(MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryReader)">
            <summary>
            
            </summary>
            <param name="beReader"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MyShapeFileReader.ReadLineStringData(System.IO.Stream)">
            <summary>
            Reads LineString shapefile
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MyShapeFileReader.ReadPolygonData(System.IO.Stream)">
            <summary>
            Reads Polygon shapefile
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MyShapeFileReader.ReadMultiPointData(System.IO.Stream)">
            <summary>
            Reads MultiPoint shapefile
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Strtree.ItemBoundable">
            <summary>
            Boundable wrapper for a non-Boundable spatial object. Used internally by
            AbstractSTRtree.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Strtree.IBoundable">
            <summary>
            A spatial object in an AbstractSTRtree.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Strtree.IBoundable.Bounds">
            <summary> 
            Returns a representation of space that encloses this Boundable, preferably
            not much bigger than this Boundable's boundary yet fast to test for intersection
            with the bounds of other Boundables. The class of object returned depends
            on the subclass of AbstractSTRtree.
            </summary>
            <returns> 
            An Envelope (for STRtrees), an Interval (for SIRtrees), or other object
            (for other subclasses of AbstractSTRtree).
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.ItemBoundable.#ctor(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="bounds"></param>
            <param name="item"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Strtree.ItemBoundable.Bounds">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Strtree.ItemBoundable.Item">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.Envelope">
            <summary>
            Defines a rectangular region of the 2D coordinate plane.
            It is often used to represent the bounding box of a <c>Geometry</c>,
            e.g. the minimum and maximum x and y values of the <c>Coordinate</c>s.
            Note that Envelopes support infinite or half-infinite regions, by using the values of
            <c>Double.PositiveInfinity</c> and <c>Double.NegativeInfinity</c>.
            When Envelope objects are created or initialized,
            the supplies extent values are automatically sorted into the correct order.    
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.AllZero">
            <summary>
            Boolean, tests to see if all of the values are zero, and returns
            true if they are zero and false if any are not zero.
            </summary>
            <returns>Boolean</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.GetHashCode">
            <summary>
            Return HashCode.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Intersects(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Test the point q to see whether it intersects the Envelope
            defined by p1-p2.
            </summary>
            <param name="p1">One extremal point of the envelope.</param>
            <param name="p2">Another extremal point of the envelope.</param>
            <param name="q">Point to test for intersection.</param>
            <returns><c>true</c> if q intersects the envelope p1-p2.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Intersects(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Test the envelope defined by p1-p2 for intersection
            with the envelope defined by q1-q2
            </summary>
            <param name="p1">One extremal point of the envelope Point.</param>
            <param name="p2">Another extremal point of the envelope Point.</param>
            <param name="q1">One extremal point of the envelope Q.</param>
            <param name="q2">Another extremal point of the envelope Q.</param>
            <returns><c>true</c> if Q intersects Point</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.#ctor">
            <summary>
            Creates a null <c>Envelope</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates an <c>Envelope</c> for a region defined by maximum and minimum values.
            </summary>
            <param name="x1">The first x-value.</param>
            <param name="x2">The second x-value.</param>
            <param name="y1">The first y-value.</param>
            <param name="y2">The second y-value.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.#ctor(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            Creates an <c>Envelope</c> for a region defined by an Vector.IEnvelope
            </summary>
            <param name="Ienvelope">The .IEnvelope to create an envelope from</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.#ctor(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Creates an <c>Envelope</c> for a region defined by two Coordinates.
            </summary>
            <param name="p1">The first Coordinate.</param>
            <param name="p2">The second Coordinate.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.#ctor(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Creates an <c>Envelope</c> for a region defined by a single Coordinate.
            </summary>
            <param name="p">The Coordinate.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Init">
            <summary>
            Initialize to a null <c>Envelope</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Init(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initialize an <c>Envelope</c> for a region defined by maximum and minimum values.
            </summary>
            <param name="x1">The first x-value.</param>
            <param name="x2">The second x-value.</param>
            <param name="y1">The first y-value.</param>
            <param name="y2">The second y-value.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Init(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            This will set all 3 dimensions.  Be warned, the Z dimensions are just place holders
            for any topology opperations and do not have any true functionality.  Whichever
            is smaller becomes the minimum and whichever is larger becomes the maximum.
            </summary>
            <param name="x1">An X coordinate </param>
            <param name="x2">Another X coordinate</param>
            <param name="y1">A Y coordinate</param>
            <param name="y2">Another Y coordinate</param>
            <param name="z1">A Z coordinate</param>
            <param name="z2">Another Z coordinate</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Init(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Initialize an <c>Envelope</c> for a region defined by two Coordinates.
            </summary>
            <param name="p1">The first Coordinate.</param>
            <param name="p2">The second Coordinate.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Init(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Initialize an <c>Envelope</c> for a region defined by a single Coordinate.
            </summary>
            <param name="p">The Coordinate.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Init(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            Initialize an <c>Envelope</c> from an existing Envelope.
            </summary>
            <param name="env">The Envelope to initialize from.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.SetToNull">
            <summary>
            Makes this <c>Envelope</c> a "null" envelope..
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.ExpandBy(System.Double)">
            <summary>
            Expands this envelope by a given distance in all directions.
            Both positive and negative distances are supported.
            </summary>
            <param name="distance">The distance to expand the envelope.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.ExpandBy(System.Double,System.Double)">
            <summary>
            Expands this envelope by a given distance in all directions.
            Both positive and negative distances are supported.
            </summary>
            <param name="deltaX">The distance to expand the envelope along the the X axis.</param>
            <param name="deltaY">The distance to expand the envelope along the the Y axis.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.ExpandToInclude(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Enlarges the boundary of the <c>Envelope</c> so that it contains (p).
            Does nothing if (p) is already on or within the boundaries.
            </summary>
            <param name="p">The Coordinate.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.ExpandToInclude(System.Double,System.Double)">
            <summary>
            Enlarges the boundary of the <c>Envelope</c> so that it contains
            (x,y). Does nothing if (x,y) is already on or within the boundaries.
            </summary>
            <param name="x">The value to lower the minimum x to or to raise the maximum x to.</param>
            <param name="y">The value to lower the minimum y to or to raise the maximum y to.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.ExpandToInclude(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            Enlarges the boundary of the <c>Envelope</c> so that it contains
            <c>other</c>. Does nothing if <c>other</c> is wholly on or
            within the boundaries.
            </summary>
            <param name="other">the <c>Envelope</c> to merge with.</param>        
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Translate(System.Double,System.Double)">
            <summary>
            Translates this envelope by given amounts in the X and Y direction.
            </summary>
            <param name="transX">The amount to translate along the X axis.</param>
            <param name="transY">The amount to translate along the Y axis.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Intersection(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            Finds an envelope that represents the intersection between this
            envelope and the specified <c>IEnvelope</c>
            </summary>
            <param name="env">An <c>IEnvelope</c> to compare against</param>
            <returns>an <c>IEnvelope</c> that bounds the intersection area</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Intersects(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary> 
            Check if the region defined by <c>other</c>
            overlaps (intersects) the region of this <c>Envelope</c>.
            </summary>
            <param name="other"> the <c>Envelope</c> which this <c>Envelope</c> is
            being checked for overlapping.
            </param>
            <returns>        
            <c>true</c> if the <c>Envelope</c>s overlap.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Overlaps(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            Use Intersects instead. In the future, Overlaps may be
            changed to be a true overlap check; that is, whether the intersection is
            two-dimensional.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Overlaps(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Use Intersects instead.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Overlaps(System.Double,System.Double)">
            <summary>
            Use Intersects instead.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Intersects(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>  
            Check if the point <c>p</c> overlaps (lies inside) the region of this <c>Envelope</c>.
            </summary>
            <param name="p"> the <c>Coordinate</c> to be tested.</param>
            <returns><c>true</c> if the point overlaps this <c>Envelope</c>.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Intersects(System.Double,System.Double)">
            <summary>  
            Check if the point <c>(x, y)</c> overlaps (lies inside) the region of this <c>Envelope</c>.
            </summary>
            <param name="x"> the x-ordinate of the point.</param>
            <param name="y"> the y-ordinate of the point.</param>
            <returns><c>true</c> if the point overlaps this <c>Envelope</c>.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Contains(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>  
            Returns <c>true</c> if the given point lies in or on the envelope.
            </summary>
            <param name="p"> the point which this <c>Envelope</c> is
            being checked for containing.</param>
            <returns>    
            <c>true</c> if the point lies in the interior or
            on the boundary of this <c>Envelope</c>.
            </returns>                
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Contains(System.Double,System.Double)">
            <summary>  
            Returns <c>true</c> if the given point lies in or on the envelope.
            </summary>
            <param name="x"> the x-coordinate of the point which this <c>Envelope</c> is
            being checked for containing.</param>
            <param name="y"> the y-coordinate of the point which this <c>Envelope</c> is
            being checked for containing.</param>
            <returns><c>true</c> if <c>(x, y)</c> lies in the interior or
            on the boundary of this <c>Envelope</c>.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Contains(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>  
            Returns <c>true</c> if the <c>Envelope other</c>
            lies wholely inside this <c>Envelope</c> (inclusive of the boundary).
            </summary>
            <param name="other"> the <c>Envelope</c> which this <c>Envelope</c> is being checked for containing.</param>
            <returns><c>true</c> if <c>other</c> is contained in this <c>Envelope</c>.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Distance(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary> 
            Computes the distance between this and another
            <c>Envelope</c>.
            The distance between overlapping Envelopes is 0.  Otherwise, the
            distance is the Euclidean distance between the closest points.
            </summary>
            <returns>The distance between this and another <c>Envelope</c>.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.op_Equality(MapWinGeoProc.NTS.Topology.Geometries.Envelope,MapWinGeoProc.NTS.Topology.Geometries.Envelope)">
            <summary>
            See <see cref="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Equals(System.Object)"/>
            </summary>
            <param name="obj1"></param>
            <param name="obj2"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.op_Inequality(MapWinGeoProc.NTS.Topology.Geometries.Envelope,MapWinGeoProc.NTS.Topology.Geometries.Envelope)">
            <summary>
            
            </summary>
            <param name="obj1"></param>
            <param name="obj2"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Clone">
            <summary>
            Creates a copy of the current envelope.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Union(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Calculates the union of the current box and the given coordinate.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Union(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            Calculates the union of the current box and the given box.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.SetCentre(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Moves the envelope to the indicated coordinate.
            </summary>
            <param name="centre">The new centre coordinate.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.SetCentre(System.Double,System.Double)">
            <summary>
            Resizes the envelope to the indicated point.
            </summary>
            <param name="width">The new width.</param>
            <param name="height">The new height.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.SetCentre(MapWindow.Interfaces.Geometries.ICoordinate,System.Double,System.Double)">
            <summary>
            Moves and resizes the current envelope.
            </summary>
            <param name="centre">The new centre coordinate.</param>
            <param name="width">The new width.</param>
            <param name="height">The new height.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Zoom(System.Double)">
            <summary>
            Zoom the box. 
            Possible values are e.g. 50 (to zoom in a 50%) or -50 (to zoom out a 50%).
            </summary>
            <param name="perCent"> 
            Negative do Envelope smaller.
            Positive do Envelope bigger.
            </param>
            <example> 
             perCent = -50 compact the envelope a 50% (make it smaller).
             perCent = 200 enlarge envelope by 2.
            </example>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.SetExtents(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Despite the naming of the extents, this will force the larger of the two x values
            to become Xmax etc.
            </summary>
            <param name="minX">An X coordinate</param>
            <param name="minY">A Y coordinate</param>
            <param name="minZ">A Z coordinate</param>
            <param name="maxX">Another X coordinate</param>
            <param name="maxY">Another Y coordinate</param>
            <param name="maxZ">Another Z coordinate</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.SetExtents(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            The two dimensional overload for consistency with other code.
            Despite the names, this will force the smallest X coordinate given
            to become maxX.  
            </summary>
            <param name="minX">An X coordinate</param>
            <param name="minY">A Y coordinate</param>
            <param name="maxX">Another X coordinate</param>
            <param name="maxY">Another Y coordinate</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Envelope.ToPolygon">
            <summary>
            Technically an Evelope object is not actually a geometry.
            This creates a polygon from the extents.
            </summary>
            <returns>A Polygon, which technically qualifies as an IGeometry</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Envelope.IsNull">
            <summary>
            Returns <c>true</c> if this <c>Envelope</c> is a "null" envelope.
            </summary>
            <returns>
            <c>true</c> if this <c>Envelope</c> is uninitialized
            or is the envelope of the empty point.
            </returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Width">
            <summary>
            Returns the difference between the maximum and minimum x values.
            </summary>
            <returns>max x - min x, or 0 if this is a null <c>Envelope</c>.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Height">
            <summary>
            Returns the difference between the maximum and minimum y values.
            </summary>
            <returns>max y - min y, or 0 if this is a null <c>Envelope</c>.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Envelope.MinX">
            <summary>
            Gets or Sets the Minimum X value.  By setting the value,
            the current Minimum X is replaced, and the new value is
            compared with the current Maximum X.  If the new value
            is greater, then it becomes MaxX instead of MinX.
            </summary>
            <returns>The minimum x-coordinate.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Envelope.MaxX">
            <summary>
            Gets or Sets the Maximum X value.  By setting the value,
            the current Maximum X is replaced, and the new value is
            compared with the current Minimum X.  If the new value
            is less, then it becomes MinX instead of MaxX.
            </summary>
            <returns>The maximum x-coordinate.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Envelope.MinY">
            <summary>
            Gets or Sets the Minimum Y value.  By setting the value,
            the current Minimum Y is replaced, and the new value is
            compared with the current Maximum Y.  If the new value
            is greater, then it becomes MaxY instead of MinY.
            </summary>
            <returns>The minimum y-coordinate.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Envelope.MaxY">
            <summary>
            Gets or Sets the Maximum Y value.  By setting the value,
            the current Maximum Y is replaced, and the new value is
            compared with the current Minimum Y.  If the new value
            is less, then it becomes MinY instead of MaxY.
            </summary>
            <returns>The maximum y-coordinate.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Envelope.MinZ">
            <summary>
            Gets or Sets the Minimum Z value.  By setting the value,
            the current Minimum Z is replaced, and the new value is
            compared with the current Maximum Z.  If the new value
            is greater, then it becomes MaxZ instead of MinZ.
            </summary>
            <returns>The maximum y-coordinate.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Envelope.MaxZ">
            <summary>
            Gets or Sets the Maximum Z value.  By setting the value,
            the current Maximum Z is replaced, and the new value is
            compared with the current Minimum Z.  If the new value
            is less, then it becomes MinZ instead of MaxZ.
            </summary>
            <returns>The maximum y-coordinate.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Centre">
            <summary>
            Computes the coordinate of the centre of this envelope (as long as it is non-null).
            </summary>
            <returns>
            The centre coordinate of this envelope, 
            or <c>null</c> if the envelope is null.
            </returns>.
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Envelope.Area">
            <summary>
            Returns the area of the envelope.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Envelope.GeometryType">
            <summary>
            Specifies that this is in fact an envelope
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph">
            <summary> 
            The computation of the <c>IntersectionMatrix</c> relies on the use of a structure
            called a "topology graph". The topology graph contains nodes and edges
            corresponding to the nodes and line segments of a <c>Geometry</c>. Each
            node and edge in the graph is labeled with its topological location relative to
            the source point.
            Note that there is no requirement that points of self-intersection be a vertex.
            Thus to obtain a correct topology graph, <c>Geometry</c>s must be
            self-noded before constructing their graphs.
            Two fundamental operations are supported by topology graphs:
            Computing the intersections between all the edges and nodes of a single graph
            Computing the intersections between the edges and nodes of two different graphs
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.LinkResultDirectedEdges(System.Collections.IList)">
            <summary> 
            For nodes in the Collection, link the DirectedEdges at the node that are in the result.
            This allows clients to link only a subset of nodes in the graph, for
            efficiency (because they know that only a subset is of interest).
            </summary>
            <param name="nodes"></param>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.edges">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.nodes">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.edgeEndList">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.NodeFactory)">
            <summary>
            
            </summary>
            <param name="nodeFact"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.GetEdgeEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.IsBoundaryNode(System.Int32,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <param name="coord"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.InsertEdge(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.Add(MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.GetNodeEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.AddNode(MapWinGeoProc.NTS.Topology.GeometriesGraph.Node)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.AddNode(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="coord"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.Find(MapWindow.Interfaces.Geometries.ICoordinate)">
            <returns> 
            The node if found; null otherwise
            </returns>
            <param name="coord"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.AddEdges(System.Collections.IList)">
            <summary> 
            Add a set of edges to the graph.  For each edge two DirectedEdges
            will be created.  DirectedEdges are NOT linked by this method.
            </summary>
            <param name="edgesToAdd"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.LinkResultDirectedEdges">
            <summary> 
            Link the DirectedEdges at the nodes of the graph.
            This allows clients to link only a subset of nodes in the graph, for
            efficiency (because they know that only a subset is of interest).
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.LinkAllDirectedEdges">
            <summary> 
            Link the DirectedEdges at the nodes of the graph.
            This allows clients to link only a subset of nodes in the graph, for
            efficiency (because they know that only a subset is of interest).
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.FindEdgeEnd(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge)">
            <summary> 
            Returns the EdgeEnd which has edge e as its base edge
            (MD 18 Feb 2002 - this should return a pair of edges).
            </summary>
            <param name="e"></param>
            <returns> The edge, if found <c>null</c> if the edge was not found.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.FindEdge(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Returns the edge whose first two coordinates are p0 and p1.
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <returns> The edge, if found <c>null</c> if the edge was not found.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.FindEdgeInSameDirection(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
             <summary>
             Returns the edge which starts at p0 and whose first segment is
             parallel to p1.
             </summary>
             <param name="p0"></param>
            <param name="p1"></param>
             <returns> The edge, if found <c>null</c> if the edge was not found.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.MatchInSameDirection(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            The coordinate pairs match if they define line segments lying in the same direction.
            E.g. the segments are parallel and in the same quadrant
            (as opposed to parallel and opposite!).
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <param name="ep0"></param>
            <param name="ep1"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.WriteEdges(System.IO.StreamWriter)">
            <summary>
            
            </summary>
            <param name="outstream"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.EdgeEnds">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph.Nodes">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.MonotoneChainEdge">
            <summary> 
            MonotoneChains are a way of partitioning the segments of an edge to
            allow for fast searching of intersections.
            They have the following properties:
            the segments within a monotone chain will never intersect each other, and 
            the envelope of any contiguous subset of the segments in a monotone chain
            is simply the envelope of the endpoints of the subset.
            Property 1 means that there is no need to test pairs of segments from within
            the same monotone chain for intersection.
            Property 2 allows
            binary search to be used to find the intersection points of two monotone chains.
            For many types of real-world data, these properties eliminate a large number of
            segment comparisons, producing substantial speed gains.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.MonotoneChainEdge.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.MonotoneChainEdge.GetMinX(System.Int32)">
            <summary>
            
            </summary>
            <param name="chainIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.MonotoneChainEdge.GetMaxX(System.Int32)">
            <summary>
            
            </summary>
            <param name="chainIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.MonotoneChainEdge.ComputeIntersects(MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.MonotoneChainEdge,MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector)">
            <summary>
            
            </summary>
            <param name="mce"></param>
            <param name="si"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.MonotoneChainEdge.ComputeIntersectsForChain(System.Int32,MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.MonotoneChainEdge,System.Int32,MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector)">
            <summary>
            
            </summary>
            <param name="chainIndex0"></param>
            <param name="mce"></param>
            <param name="chainIndex1"></param>
            <param name="si"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.MonotoneChainEdge.ComputeIntersectsForChain(System.Int32,System.Int32,MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.MonotoneChainEdge,System.Int32,System.Int32,MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector)">
            <summary>
            
            </summary>
            <param name="start0"></param>
            <param name="end0"></param>
            <param name="mce"></param>
            <param name="start1"></param>
            <param name="end1"></param>
            <param name="ei"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.MonotoneChainEdge.Coordinates">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.MonotoneChainEdge.StartIndexes">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersectionList">
            <summary>
            A list of edge intersections along an Edge.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersectionList.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge)">
            <summary>
            
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersectionList.Add(MapWindow.Interfaces.Geometries.ICoordinate,System.Int32,System.Double)">
            <summary> 
            Adds an intersection into the list, if it isn't already there.
            The input segmentIndex and dist are expected to be normalized.
            </summary>
            <param name="intPt"></param>
            <param name="segmentIndex"></param>
            <param name="dist"></param>
            <returns>The EdgeIntersection found or added.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersectionList.GetEnumerator">
            <summary> 
            Returns an iterator of EdgeIntersections.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersectionList.IsIntersection(MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersectionList.AddEndpoints">
            <summary>
            Adds entries for the first and last points of the edge to the list.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersectionList.AddSplitEdges(System.Collections.IList)">
            <summary> 
            Creates new edges for all the edges that the intersections in this
            list split the parent edge into.
            Adds the edges to the input list (this is so a single list
            can be used to accumulate all split edges for a Geometry).
            </summary>
            <param name="edgeList"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersectionList.CreateSplitEdge(MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersection,MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersection)">
            <summary>
            Create a new "split edge" with the section of points between
            (and including) the two intersections.
            The label for the new edge is the same as the label for the parent edge.
            </summary>
            <param name="ei0"></param>
            <param name="ei1"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersectionList.Write(System.IO.StreamWriter)">
            <summary>
            
            </summary>
            <param name="outstream"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersectionList.Count">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd">
            <summary> 
            Models the end of an edge incident on a node.
            EdgeEnds have a direction
            determined by the direction of the ray from the initial
            point to the next point.
            EdgeEnds are IComparable under the ordering
            "a has a greater angle with the x-axis than b".
            This ordering is used to sort EdgeEnds around a node.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd.edge">
            <summary>
            The parent edge of this edge end.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd.label">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge)">
            <summary>
            
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="edge"></param>
            <param name="p0"></param>
            <param name="p1"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWinGeoProc.NTS.Topology.GeometriesGraph.Label)">
            <summary>
            
            </summary>
            <param name="edge"></param>
            <param name="p0"></param>
            <param name="p1"></param>
            <param name="label"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd.Init(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd.CompareTo(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd.CompareDirection(MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd)">
            <summary> 
            Implements the total order relation:
            a has a greater angle with the positive x-axis than b.
            Using the obvious algorithm of simply computing the angle is not robust,
            since the angle calculation is obviously susceptible to roundoff.
            A robust algorithm is:
            - first compare the quadrant.  If the quadrants
            are different, it it trivial to determine which vector is "greater".
            - if the vectors lie in the same quadrant, the computeOrientation function
            can be used to decide the relative orientation of the vectors.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd.ComputeLabel">
            <summary>
            Subclasses should override this if they are using labels
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd.Write(System.IO.StreamWriter)">
            <summary>
            
            </summary>
            <param name="outstream"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd.Edge">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd.Label">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd.Coordinate">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd.DirectedCoordinate">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd.Quadrant">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd.Dx">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd.Dy">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd.Node">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Features.IAttributesTable">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Features.IAttributesTable.AddAttribute(System.String,System.Object)">
            <summary>
            
            </summary>
            <param name="attributeName"></param>
            <param name="value"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Features.IAttributesTable.DeleteAttribute(System.String)">
            <summary>
            
            </summary>
            <param name="attributeName"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Features.IAttributesTable.GetType(System.String)">
            <summary>
            
            </summary>
            <param name="attributeName"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Features.IAttributesTable.Exists(System.String)">
            <summary>
            
            </summary>
            <param name="attributeName"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Features.IAttributesTable.GetNames">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Features.IAttributesTable.GetValues">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Features.IAttributesTable.Item(System.String)">
            <summary>
            
            </summary>
            <param name="attributeName"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Features.IAttributesTable.Count">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IVerticalDatum">
            <summary>
            Procedure used to measure vertical distances.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IDatum">
            <summary>
            A set of quantities from which other quantities are calculated.
            </summary>
            <remarks>
            For the OGC abstract model, it can be defined as a set of real points on the earth 
            that have coordinates. EG. A datum can be thought of as a set of parameters 
            defining completely the origin and orientation of a coordinate system with respect 
            to the earth. A textual description and/or a set of parameters describing the 
            relationship of a coordinate system to some predefined physical locations (such 
            as center of mass) and physical directions (such as axis of spin). The definition 
            of the datum may also include the temporal behavior (such as the rate of change of
            the orientation of the coordinate axes).
            </remarks>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IDatum.DatumType">
            <summary>
            Gets or sets the type of the datum as an enumerated code.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IHorizontalDatum">
            <summary>
            Procedure used to measure positions on the surface of the Earth.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IHorizontalDatum.Ellipsoid">
            <summary>
            Gets or sets the ellipsoid of the datum.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IHorizontalDatum.Wgs84Parameters">
            <summary>
            Gets preferred parameters for a Bursa Wolf transformation into WGS84. The 7 returned values 
            correspond to (dx,dy,dz) in meters, (ex,ey,ez) in arc-seconds, and scaling in parts-per-million.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IEllipsoid">
            <summary>
            The IEllipsoid interface defines the standard information stored with ellipsoid objects.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IEllipsoid.SemiMajorAxis">
            <summary>
            Gets or sets the value of the semi-major axis.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IEllipsoid.SemiMinorAxis">
            <summary>
            Gets or sets the value of the semi-minor axis.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IEllipsoid.InverseFlattening">
            <summary>
            Gets or sets the value of the inverse of the flattening constant of the ellipsoid.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IEllipsoid.AxisUnit">
            <summary>
            Gets or sets the value of the axis unit.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IEllipsoid.IsIvfDefinitive">
            <summary>
            Is the Inverse Flattening definitive for this ellipsoid? Some ellipsoids use the
            IVF as the defining value, and calculate the polar radius whenever asked. Other
            ellipsoids use the polar radius to calculate the IVF whenever asked. This
            distinction can be important to avoid floating-point rounding errors.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IAngularUnit">
            <summary>
            The IAngularUnit interface defines methods on angular units.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IAngularUnit.RadiansPerUnit">
            <summary>
            Gets or sets the number of radians per angular unit.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointLine">
            <summary>
            Computes a point in the interior of an linear point.
            Algorithm:
            Find an interior vertex which is closest to
            the centroid of the linestring.
            If there is no interior vertex, find the endpoint which is
            closest to the centroid.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointLine.#ctor(MapWinGeoProc.NTS.Topology.Geometries.Geometry)">
            <summary>
            
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointLine.AddInterior(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Tests the interior vertices (if any)
            defined by a linear Geometry for the best inside point.
            If a Geometry is not of dimension 1 it is not tested.
            </summary>
            <param name="geom">The point to add.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointLine.AddInterior(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            
            </summary>
            <param name="pts"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointLine.AddEndpoints(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary> 
            Tests the endpoint vertices
            defined by a linear Geometry for the best inside point.
            If a Geometry is not of dimension 1 it is not tested.
            </summary>
            <param name="geom">The point to add.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointLine.AddEndpoints(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            
            </summary>
            <param name="pts"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointLine.Add(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="point"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointLine.InteriorPoint">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.TextElement">
            <summary>
            A modular element that supports a textbox for users to enter information
            as part of a larger dialog control.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.TextElement.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.TextElement.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.TextElement.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.TextElement.cmdHelp">
            <summary>
            Help button
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.TextElement.lblLight">
            <summary>
            Status Light
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.TextElement.groupBox1">
            <summary>
            A group box to surround individual components
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.TextElement.#ctor">
            <summary>
            Creates a new instance of the TextElement class
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.TextElement.OnClick(System.EventArgs)">
            <summary>
            Called to fire the click event for this element
            </summary>
            <param name="e">A mouse event args thingy</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.TextElement.OnHelpButtonPressed(MapWinGeoProc.Dialogs.HelpPannelEventArgs)">
            <summary>
            Called when the help button has been pressed
            </summary>
            <param name="e">A HelpPanelEventArgs parameter with a new help title, text and image.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.TextElement.OnHelpContextChanged(MapWinGeoProc.Dialogs.HelpPannelEventArgs)">
            <summary>
            Called when the data entry field is entered to change a topic, but only if panel is visible
            </summary>
            <param name="e">A HelpPanelEventArgs parameter with a new help title, text and image.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.TextElement.OnResizeStarted">
            <summary>
            Fires when someone uses the resize grip to resize the element
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.TextElement.OnResizeEnded">
            <summary>
            Fires when someone has stopped resizing with the grip
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.TextElement.Clicked">
            <summary>
            Fires when the inactive areas around the controls are clicked on the element.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.TextElement.HelpButtonPressed">
            <summary>
            Fires when the help button is clicked.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.TextElement.HelpContextChanged">
            <summary>
            Fires when the the user enters a data entry region.  Changes help without opening panel.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.TextElement.ResizeStarted">
            <summary>
            Fires when the element is being resized.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.TextElement.ResizeEnded">
            <summary>
            Fires when the element is no longer being resized.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.Caption">
            <summary>
            Controls the caption for this element (the group box text)
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.LightVisible">
            <summary>
            Gets or sets whether the status light is visible for this element.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.LightMessage">
            <summary>
            Gets or sets the tool tip that shows when you hold the mouse over the light
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.Status">
            <summary>
            Indicates the current condition of this element.
            - Green = ok to continue
            - Yellow = not specified yet
            - Red = process halting error
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.AllowGripResize">
            <summary>
            Gets or sets a boolean.  True if the user is allowed to adjust the width of the 
            element to better display longer filenames.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.Halt">
            <summary>
            Boolean, true if either of the conditions that may prevent dialog completion are true 
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.HaltOnEmpty">
            <summary>
            Gets or sets a boolean.  True if an unspecified condition will prevent dialog completion.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.HaltOnError">
            <summary>
            Gets or sets a boolean.  True if an Error status will prevent dialog completion.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.MaxWidth">
            <summary>
            Gets or sets the maximum allowable width for dynamic resize.  The dialog form sets this
            dynamically to the size of the container panel.  This is because the behavior for
            resizing larger than the size of the panel is erratic because of the autoscrolling
            behavior.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.MinWidth">
            <summary>
            Gets or sets the minimum allowable width for dynamic resizing.  This specifically affects
            the behavior when the user uses the grip to resize the element.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.HelpImage">
            <summary>
            Gets or Sets the image that will appear after the help text in the panel, if any.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.HelpText">
            <summary>
            Gets or Sets the text to appear in the help pannel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.HelpTitle">
            <summary>
            Gets or Sets the title to be shown in the help panel.  Defaults to the Caption.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.WikiAddress">
            <summary>
            Gets or Sets the web address to use from the wiki button in the help panel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.DefaultImage">
            <summary>
            Gets or Sets the default image that will be used in the help panel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.AlternateImage">
            <summary>
            Gets or Sets the alternate image that can be used in the help panel instead.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.Type">
            <summary>
            Gets or sets the text type to be allowed for the text field
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.MinValue">
            <summary>
            Gets or sets the minimum value.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.MaxValue">
            <summary>
            Gets or sets the maximum value.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.Value">
            <summary>
            Gets or sets the value of the text in the text field.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.Text">
            <summary>
            Gets or sets the value of the text in the text field.
            This was added because the text property of the user control is confusing.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.HelpButtonVisible">
            <summary>
            Overrides the basic help button property to also handle the text box resize
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.TextElement.ResizeGripVisible">
            <summary>
            Gets or sets whether a resize grip is provided for the user to change the dimensions of the control.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.TextElement.TextType">
            <summary>
            Type for the TextElement
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.TextElement.TextType.TextInteger">
            <summary>
            Integer type
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.TextElement.TextType.TextDouble">
            <summary>
            Double type
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.TextElement.TextType.TextString">
            <summary>
            String type
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.TextElement.LightStatus">
            <summary>
            Indicates the allowed values for the status of the element, illustrated by the light
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.TextElement.LightStatus.Empty">
            <summary>
            Indicates that no value has been set for this yet.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.TextElement.LightStatus.Ok">
            <summary>
            Indicates that the element parameter is ok and won't halt.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.TextElement.LightStatus.Error">
            <summary>
            Indicates that the element value will cause an error.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.TextElement.HelpButtonHandler">
            <summary>
            Public delegate for when someone presses the help button
            </summary>
            <param name="sender">The element sending the event</param>
            <param name="e">HelpPannelEventArgs with help title, text and an image</param>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.TextElement.ResizeStartedHandler">
            <summary>
            Delegate for the when someone starts resizing an element
            </summary>
            <param name="sender">The element being resized</param>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.TextElement.ResizeEndedHandler">
            <summary>
            Fires when the element is no longer being resized.
            </summary>
            <param name="sender"></param>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.BatchFileElement">
            <summary>
            A modular control that can be used for specifying a filename for opening or closing files.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.BatchFileElement.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.BatchFileElement.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.BatchFileElement.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.BatchFileElement.cmdHelp">
            <summary>
            Help button
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.BatchFileElement.lblLight">
            <summary>
            Status Light
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.BatchFileElement.groupBox1">
            <summary>
            A group box to surround individual components
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.BatchFileElement.#ctor">
            <summary>
            Creates a new instance of the FileElement class
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.BatchFileElement.OnClick(System.EventArgs)">
            <summary>
            Called to fire the click event for this element
            </summary>
            <param name="e">A mouse event args thingy</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.BatchFileElement.OnHelpButtonPressed(MapWinGeoProc.Dialogs.HelpPannelEventArgs)">
            <summary>
            Called when the help button has been pressed
            </summary>
            <param name="e">A HelpPanelEventArgs parameter with a new help title, text and image.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.BatchFileElement.OnHelpContextChanged(MapWinGeoProc.Dialogs.HelpPannelEventArgs)">
            <summary>
            Called when the data entry field is entered to change a topic, but only if panel is visible
            </summary>
            <param name="e">A HelpPanelEventArgs parameter with a new help title, text and image.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.BatchFileElement.OnResizeStarted">
            <summary>
            Fires when someone uses the resize grip to resize the element
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.BatchFileElement.OnResizeEnded">
            <summary>
            Fires when someone has stopped resizing with the grip
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.BatchFileElement.HelpText_Append(System.String)">
            <summary>
            Appends a string to the end of the help content
            </summary>
            <param name="HelpText"></param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.BatchFileElement.HelpText_Clear(System.String)">
            <summary>
            Clears the existing help content.
            </summary>
            <param name="HelpText"></param>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.BatchFileElement.Clicked">
            <summary>
            Fires when the inactive areas around the controls are clicked on the element.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.BatchFileElement.HelpButtonPressed">
            <summary>
            Fires when the help button is clicked.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.BatchFileElement.HelpContextChanged">
            <summary>
            Fires when the the user enters a data entry region.  Changes help without opening panel.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.BatchFileElement.ResizeStarted">
            <summary>
            Fires when the element is being resized.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.BatchFileElement.ResizeEnded">
            <summary>
            Fires when the element is no longer being resized.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BatchFileElement.Caption">
            <summary>
            Controls the caption for this element (the group box text)
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BatchFileElement.LightVisible">
            <summary>
            Gets or sets whether the status light is visible for this element.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BatchFileElement.LightMessage">
            <summary>
            Gets or sets the tool tip that shows when you hold the mouse over the light
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BatchFileElement.Status">
            <summary>
            Indicates the current condition of this element.
            - Green = ok to continue
            - Yellow = not specified yet
            - Red = process halting error
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BatchFileElement.AllowGripResize">
            <summary>
            Gets or sets a boolean.  True if the user is allowed to adjust the width of the 
            element to better display longer filenames.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BatchFileElement.Halt">
            <summary>
            Boolean, true if either of the conditions that may prevent dialog completion are true 
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BatchFileElement.HaltOnEmpty">
            <summary>
            Gets or sets a boolean.  True if an unspecified condition will prevent dialog completion.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BatchFileElement.HaltOnError">
            <summary>
            Gets or sets a boolean.  True if an Error status will prevent dialog completion.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BatchFileElement.MaxWidth">
            <summary>
            Gets or sets the maximum allowable width for dynamic resize.  The dialog form sets this
            dynamically to the size of the container panel.  This is because the behavior for
            resizing larger than the size of the panel is erratic because of the autoscrolling
            behavior.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BatchFileElement.MinWidth">
            <summary>
            Gets or sets the minimum allowable width for dynamic resizing.  This specifically affects
            the behavior when the user uses the grip to resize the element.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BatchFileElement.HelpImage">
            <summary>
            Gets or Sets the image that will appear after the help text in the panel, if any.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BatchFileElement.HelpText">
            <summary>
            Gets or Sets the text to appear in the help pannel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BatchFileElement.HelpTitle">
            <summary>
            Gets or Sets the title to be shown in the help panel.  Defaults to the Caption.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BatchFileElement.WikiAddress">
            <summary>
            Gets or Sets the web address to use from the wiki button in the help panel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BatchFileElement.DefaultImage">
            <summary>
            Gets or Sets the default image that will be used in the help panel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BatchFileElement.AlternateImage">
            <summary>
            Gets or Sets the alternate image that can be used in the help panel instead.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BatchFileElement.FileAccess">
            <summary>
            Gets or sets whether the file is opened or saved
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BatchFileElement.Filename">
            <summary>
            Gets or sets the filename shown in the textbox for this element
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BatchFileElement.FileType">
            <summary>
            Gets or Sets the allowable file types by specifying shapefiles, images, or grids.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BatchFileElement.Filter">
            <summary>
            Gets or Sets the dialog filter to be used directly.  Setting AllowedFileTypes will
            automatically set this with the filter values allowed for grids, images or shapefiles.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BatchFileElement.HelpButtonVisible">
            <summary>
            Override the basic help button property change to also handle the text box resize
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BatchFileElement.ResizeGripVisible">
            <summary>
            Gets or sets whether a resize grip is provided for the user to change the dimensions of the control.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.BatchFileElement.LightStatus">
            <summary>
            Indicates the allowed values for the status of the element, illustrated by the light
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.BatchFileElement.LightStatus.Empty">
            <summary>
            Indicates that no value has been set for this yet.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.BatchFileElement.LightStatus.Ok">
            <summary>
            Indicates that the element parameter is ok and won't halt.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.BatchFileElement.LightStatus.Error">
            <summary>
            Indicates that the element value will cause an error.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.BatchFileElement.FileTypes">
            <summary>
            Specifies a GIS file category to help narrow down the open/save file dialogs
            and improve the file format validation.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.BatchFileElement.FileTypes.Shapefile">
            <summary>
            Shapefiles that end with extension .shp
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.BatchFileElement.FileTypes.Grid">
            <summary>
            Grid file formats like geotif, asc, esri grids etc.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.BatchFileElement.FileTypes.Image">
            <summary>
            Image file formats like bmp, jpg, gif, etc.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.BatchFileElement.FileTypes.All">
            <summary>
            The element will not use any filter for file extensions or validation.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.BatchFileElement.FileAccessType">
            <summary>
            Specifies whether an element is being used to open or save a file.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.BatchFileElement.FileAccessType.Open">
            <summary>
            Speficies that the element will be used to open files.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.BatchFileElement.FileAccessType.Save">
            <summary>
            Specifies that the element will be used to save files.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.BatchFileElement.HelpButtonHandler">
            <summary>
            Public delegate for when someone presses the help button
            </summary>
            <param name="sender">The element sending the event</param>
            <param name="e">HelpPannelEventArgs with help title, text and an image</param>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.BatchFileElement.ResizeStartedHandler">
            <summary>
            Delegate for the when someone starts resizing an element
            </summary>
            <param name="sender">The element being resized</param>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.BatchFileElement.ResizeEndedHandler">
            <summary>
            Fires when the element is no longer being resized.
            </summary>
            <param name="sender"></param>
        </member>
        <member name="T:MapWinGeoProc.Topology.Envelope">
            <summary>
            A primitive rectangle class for holding double values
            Since we define it in terms of X, Y and Z, this is an 
            axis-aligned bounding box (AABB). 
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.Envelope.xMin">
            <summary>
            Double, The minimum X value
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.Envelope.xMax">
            <summary>
            Double, The largest X value
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.Envelope.yMin">
            <summary>
            Double, The minimum Y value
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.Envelope.yMax">
            <summary>
            Double, the largest Y value
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.Envelope.zMin">
            <summary>
            Double, the smallest Z value
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.Envelope.zMax">
            <summary>
            Double, the largest Z value
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology.Envelope.#ctor">
            <summary>
            Creates a new, blank extents object with all the extents = 0.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology.Envelope.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a new instance of Envelope from double values
            </summary>
            <param name="MinX">Double, The minimum X value</param>
            <param name="MaxX">Double, The largest X value</param>
            <param name="MinY">Double, The minimum Y value</param>
            <param name="MaxY">Double, the largest Y value</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.Envelope.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a new instance of Envelope from double values
            </summary>
            <param name="MinX">Double, The minimum X value</param>
            <param name="MaxX">Double, The largest X value</param>
            <param name="MinY">Double, The minimum Y value</param>
            <param name="MaxY">Double, the largest Y value</param>
            <param name="MinZ">Double, the minimum Z value</param>
            <param name="MaxZ">Double, the largest Z value</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.Envelope.#ctor(MapWinGIS.Extents)">
            <summary>
            Creates a new instance of Envelope from double values in the MapWinGIS.Extents object
            </summary>
            <param name="Bounds">A MapWinGIS.Extents object to define a rectangle</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.Envelope.Intersects(MapWinGIS.Point)">
            <summary>
            Determines whether a point is inside or on the bounds of the rectangle
            </summary>
            <param name="Point">A MapWinGIS.Point parameter</param>
            <returns>True if the point is inside or on the bounds of the rectangle</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Envelope.Intersects(MapWinGeoProc.Topology.Point)">
            <summary>
            Determines whether a point is inside or on the bounds of the rectangle
            </summary>
            <param name="Point">A Topology.Point parameter</param>
            <returns>True if the point is inside or on the bounds of the rectangle</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Envelope.Intersects(MapWinGeoProc.Topology.LineSegment)">
            <summary>
            Returns true if any part of the segment has coordinates within the extents
            </summary>
            <param name="Seg">The line segment to test</param>
            <returns>Boolean, true if any part of the segment is within the extents</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Envelope.Intersection(MapWinGeoProc.Topology.Envelope)">
            <summary>
            Returns a RectD that has the intersection area for both rectangles
            </summary>
            <param name="Rectangle2">A Envelope that you wish to intersect with this rectangle</param>
            <returns>The Envelope of the intersection area</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Envelope.AreIdenticalTo(MapWinGeoProc.Topology.Envelope)">
            <summary>
            Checks each value in the point to see if they are the same
            </summary>
            <param name="Ext">The Envelope to compare with this point</param>
            <returns>Boolean, true if the points are the same</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Envelope.AreIdenticalTo(MapWinGIS.Extents)">
            <summary>
            Checks each value in the point to see if they are the same
            </summary>
            <param name="Ext">The Envelope to compare with this point</param>
            <returns>Boolean, true if the points are the same</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Envelope.ToMapWinEnvelope">
            <summary>
            Converts this rectangleD to a MapWinGIS.Extents object
            </summary>
            <returns>A MapWinGIS.Extents object with the same measurements as Envelope</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Envelope.ToLineSegments">
            <summary>
            Creates a list of segments that define the boundaries of the extents.
            </summary>
            <returns>List of LineSegments</returns>
        </member>
        <member name="P:MapWinGeoProc.Topology.Envelope.Width">
            <summary>
            Gets or sets the width.  Setting this will keep xMin the same and adjust xMax.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology.Envelope.Height">
            <summary>
            Gets or sets the height.  Setting this will keep the yMin the same and adjust yMax.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology.Envelope.Depth">
            <summary>
            Gets or sets the depth.  Setting this will keep the zMin the same and adjust zMax.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology.Envelope.Center">
            <summary>
            Gets or sets the center.  Setting this will translate the entire box.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Topology2D.ShapeCategories">
            <summary>
            A grouping that categorizies the shape types
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.ShapeCategories.Point">
            <summary>
            Point, PointM, or PointZ
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.ShapeCategories.MultiPoint">
            <summary>
            MultiPoint, MultiPointM, or MultiPointZ
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.ShapeCategories.Line">
            <summary>
            LineString, LineStringM, or LineStringZ
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.ShapeCategories.Polygon">
            <summary>
            Polygon, PolygonM, or PolygonZ
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.ShapeCategories.Invalid">
            <summary>
            NullShape or MultiPatch (Not Supported)
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS_Functions">
            <summary>
            This enables easier access to some NTS functions
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS_Functions.Buffer(MapWinGIS.Shape,System.Double,System.Int32,MapWindow.Interfaces.Geometries.BufferStyles)">
            <summary>
            Creates a buffer polygon that is Distance around mwShape
            </summary>
            <param name="mwShape">The polygon to buffer</param>
            <param name="Distance">The distance</param>
            <param name="QuadrantSegmants">how rounded the buffer is</param>
            <param name="EndCap">The type of endcap</param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Utilities.Radians">
            <summary>
            Converts radians to degress.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.Radians.ToDegrees(System.Double)">
            <summary>
            Converts radians to degress.
            </summary>
            <param name="radians">Angle in radians.</param>
            <returns>The angle in degrees.</returns>
        </member>
        <member name="T:Iesi.Collections.HashedSet">
            <summary>
            Implements a <c>Set</c> based on a hash table.  This will give the best lookup, add, and remove
            performance for very large data-sets, but iteration will occur in no particular order.
            </summary>
        </member>
        <member name="T:Iesi.Collections.DictionarySet">
             <summary>
             <p><c>DictionarySet</c> is an abstract class that supports the creation of new <c>Set</c>
             types where the underlying data store is an <c>IDictionary</c> instance.</p> 
              
             <p>You can use any object that implements the <c>IDictionary</c> interface to hold set data.
             You can define your own, or you can use one of the objects provided in the Framework.   
             The type of <c>IDictionary</c> you choose will affect both the performance and the behavior
             of the <c>Set</c> using it. </p>
            
             <p>To make a <c>Set</c> typed based on your own <c>IDictionary</c>, simply derive a
             new class with a constructor that takes no parameters.  Some <c>Set</c> implmentations
             cannot be defined with a default constructor.  If this is the case for your class, 
             you will need to override <c>Clone()</c> as well.</p>
            
             <p>It is also standard practice that at least one of your constructors takes an <c>ICollection</c> or 
             an <c>ISet</c> as an argument.</p>
             </summary>
        </member>
        <member name="T:Iesi.Collections.Set">
            <summary><p>A collection that contains no duplicate elements.  This class models the mathematical
            <c>Set</c> abstraction, and is the base class for all other <c>Set</c> implementations.  
            The order of elements in a set is dependant on (a)the data-structure implementation, and 
            (b)the implementation of the various <c>Set</c> methods, and thus is not guaranteed.</p>
             
            <p>None of the <c>Set</c> implementations in this library are guranteed to be thread-safe
            in any way unless wrapped in a <c>SynchronizedSet</c>.</p>
            
            <p>The following table summarizes the binary operators that are supported by the <c>Set</c> class.</p>
            <list type="table">
            	<listheader>
            		<term>Operation</term>
            		<term>Description</term>
            		<term>Method</term>
            		<term>Operator</term>
            	</listheader>
            	<item>
            		<term>Union (OR)</term>
            		<term>Element included in result if it exists in either <c>A</c> OR <c>B</c>.</term>
            		<term><c>Union()</c></term>
            		<term><c>|</c></term>
            	</item>
            	<item>
            		<term>Intersection (AND)</term>
            		<term>Element included in result if it exists in both <c>A</c> AND <c>B</c>.</term>
            		<term><c>InterSect()</c></term>
            		<term><c>&amp;</c></term>
            	</item>
            	<item>
            		<term>Exclusive Or (XOR)</term>
            		<term>Element included in result if it exists in one, but not both, of <c>A</c> and <c>B</c>.</term>
            		<term><c>ExclusiveOr()</c></term>
            		<term><c>^</c></term>
            	</item>
            	<item>
            		<term>Minus (n/a)</term>
            		<term>Take all the elements in <c>A</c>.  Now, if any of them exist in <c>B</c>, remove
            		them.  Note that unlike the other operators, <c>A - B</c> is not the same as <c>B - A</c>.</term>
            		<term><c>Minus()</c></term>
            		<term><c>-</c></term>
            	</item>
            </list>
            </summary>
        </member>
        <member name="T:Iesi.Collections.ISet">
            <summary>
            <p>A collection that contains no duplicate elements.  This interface models the mathematical
            <c>Set</c> abstraction.    
            The order of elements in a set is dependant on (a)the data-structure implementation, and 
            (b)the implementation of the various <c>Set</c> methods, and thus is not guaranteed.</p>
            
            <p>None of the <c>Set</c> implementations in this library are guranteed to be thread-safe
            in any way unless wrapped in a <c>SynchronizedSet</c>.</p>
            
            <p>The following table summarizes the binary operators that are supported by the <c>Set</c> class.</p>
            <list type="table">
            	<listheader>
            		<term>Operation</term>
            		<term>Description</term>
            		<term>Method</term>
            	</listheader>
            	<item>
            		<term>Union (OR)</term>
            		<term>Element included in result if it exists in either <c>A</c> OR <c>B</c>.</term>
            		<term><c>Union()</c></term>
            	</item>
            	<item>
            		<term>Intersection (AND)</term>
            		<term>Element included in result if it exists in both <c>A</c> AND <c>B</c>.</term>
            		<term><c>InterSect()</c></term>
            	</item>
            	<item>
            		<term>Exclusive Or (XOR)</term>
            		<term>Element included in result if it exists in one, but not both, of <c>A</c> and <c>B</c>.</term>
            		<term><c>ExclusiveOr()</c></term>
            	</item>
            	<item>
            		<term>Minus (n/a)</term>
            		<term>Take all the elements in <c>A</c>.  Now, if any of them exist in <c>B</c>, remove
            		them.  Note that unlike the other operators, <c>A - B</c> is not the same as <c>B - A</c>.</term>
            		<term><c>Minus()</c></term>
            	</item>
            </list>
            </summary>
        </member>
        <member name="M:Iesi.Collections.ISet.Union(Iesi.Collections.ISet)">
            <summary>
            Performs a "union" of the two sets, where all the elements
            in both sets are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            Neither this set nor the input set are modified during the operation.  The return value
            is a <c>Clone()</c> of this set with the extra elements added in.
            </summary>
            <param name="a">A collection of elements.</param>
            <returns>A new <c>Set</c> containing the union of this <c>Set</c> with the specified collection.
            Neither of the input objects is modified by the union.</returns>
        </member>
        <member name="M:Iesi.Collections.ISet.Intersect(Iesi.Collections.ISet)">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included if it exists in
            both sets.  The <c>Intersect()</c> operation does not modify the input sets.  It returns
            a <c>Clone()</c> of this set with the appropriate elements removed.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>The intersection of this set with <c>a</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.ISet.Minus(Iesi.Collections.ISet)">
            <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of this <c>Set</c> containing the elements from the operation.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>A set containing the elements from this set with the elements in <c>a</c> removed.</returns>
        </member>
        <member name="M:Iesi.Collections.ISet.ExclusiveOr(Iesi.Collections.ISet)">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of this set containing
            the elements from the exclusive-or operation.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>A set containing the result of <c>a ^ b</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.ISet.Contains(System.Object)">
            <summary>
            Returns <c>true</c> if this set contains the specified element.
            </summary>
            <param name="o">The element to look for.</param>
            <returns><c>true</c> if this set contains the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.ISet.ContainsAll(System.Collections.ICollection)">
            <summary>
            Returns <c>true</c> if the set contains all the elements in the specified collection.
            </summary>
            <param name="c">A collection of objects.</param>
            <returns><c>true</c> if the set contains all the elements in the specified collection, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.ISet.Add(System.Object)">
            <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
            <param name="o">The object to add to the set.</param>
            <returns><c>true</c> is the object was added, <c>false</c> if it was already present.</returns>
        </member>
        <member name="M:Iesi.Collections.ISet.AddAll(System.Collections.ICollection)">
            <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
            <param name="c">A collection of objects to add to the set.</param>
            <returns><c>true</c> is the set changed as a result of this operation, <c>false</c> if not.</returns>
        </member>
        <member name="M:Iesi.Collections.ISet.Remove(System.Object)">
            <summary>
            Removes the specified element from the set.
            </summary>
            <param name="o">The element to be removed.</param>
            <returns><c>true</c> if the set contained the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.ISet.RemoveAll(System.Collections.ICollection)">
            <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
            <param name="c">A collection of elements to remove.</param>
            <returns><c>true</c> if the set was modified as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.ISet.RetainAll(System.Collections.ICollection)">
            <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
            <param name="c">Collection that defines the set of elements to be retained.</param>
            <returns><c>true</c> if this set changed as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.ISet.Clear">
            <summary>
            Removes all objects from the set.
            </summary>
        </member>
        <member name="P:Iesi.Collections.ISet.IsEmpty">
            <summary>
            Returns <c>true</c> if this set contains no elements.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Set.Union(Iesi.Collections.ISet)">
            <summary>
            Performs a "union" of the two sets, where all the elements
            in both sets are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            Neither this set nor the input set are modified during the operation.  The return value
            is a <c>Clone()</c> of this set with the extra elements added in.
            </summary>
            <param name="a">A collection of elements.</param>
            <returns>A new <c>Set</c> containing the union of this <c>Set</c> with the specified collection.
            Neither of the input objects is modified by the union.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.Union(Iesi.Collections.ISet,Iesi.Collections.ISet)">
            <summary>
            Performs a "union" of two sets, where all the elements
            in both are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            The return value is a <c>Clone()</c> of one of the sets (<c>a</c> if it is not <c>null</c>) with elements of the other set
            added in.  Neither of the input sets is modified by the operation.
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>A set containing the union of the input sets.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.op_BitwiseOr(Iesi.Collections.Set,Iesi.Collections.Set)">
            <summary>
            Performs a "union" of two sets, where all the elements
            in both are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            The return value is a <c>Clone()</c> of one of the sets (<c>a</c> if it is not <c>null</c>) with elements of the other set
            added in.  Neither of the input sets is modified by the operation.
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>A set containing the union of the input sets.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.Intersect(Iesi.Collections.ISet)">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included if it exists in
            both sets.  The <c>Intersect()</c> operation does not modify the input sets.  It returns
            a <c>Clone()</c> of this set with the appropriate elements removed.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>The intersection of this set with <c>a</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.Intersect(Iesi.Collections.ISet,Iesi.Collections.ISet)">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included only if it exists in
            both <c>a</c> and <c>b</c>.  Neither input object is modified by the operation.
            The result object is a <c>Clone()</c> of one of the input objects (<c>a</c> if it is not <c>null</c>) containing the
            elements from the intersect operation. 
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>The intersection of the two input sets.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.op_BitwiseAnd(Iesi.Collections.Set,Iesi.Collections.Set)">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included only if it exists in
            both <c>a</c> and <c>b</c>.  Neither input object is modified by the operation.
            The result object is a <c>Clone()</c> of one of the input objects (<c>a</c> if it is not <c>null</c>) containing the
            elements from the intersect operation. 
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>The intersection of the two input sets.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.Minus(Iesi.Collections.ISet)">
            <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of this <c>Set</c> containing the elements from the operation.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>A set containing the elements from this set with the elements in <c>a</c> removed.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.Minus(Iesi.Collections.ISet,Iesi.Collections.ISet)">
            <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of set <c>a</c> containing the elements from the operation. 
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>A set containing <c>A - B</c> elements.  <c>null</c> if <c>a</c> is <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.op_Subtraction(Iesi.Collections.Set,Iesi.Collections.Set)">
            <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of set <c>a</c> containing the elements from the operation. 
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>A set containing <c>A - B</c> elements.  <c>null</c> if <c>a</c> is <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.ExclusiveOr(Iesi.Collections.ISet)">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of this set containing
            the elements from the exclusive-or operation.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>A set containing the result of <c>a ^ b</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.ExclusiveOr(Iesi.Collections.ISet,Iesi.Collections.ISet)">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of one of the sets
            (<c>a</c> if it is not <c>null</c>) containing
            the elements from the exclusive-or operation.
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>A set containing the result of <c>a ^ b</c>.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.op_ExclusiveOr(Iesi.Collections.Set,Iesi.Collections.Set)">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of one of the sets
            (<c>a</c> if it is not <c>null</c>) containing
            the elements from the exclusive-or operation.
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>A set containing the result of <c>a ^ b</c>.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.Add(System.Object)">
            <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
            <param name="o">The object to add to the set.</param>
            <returns><c>true</c> is the object was added, <c>false</c> if it was already present.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.AddAll(System.Collections.ICollection)">
            <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
            <param name="c">A collection of objects to add to the set.</param>
            <returns><c>true</c> is the set changed as a result of this operation, <c>false</c> if not.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.Clear">
            <summary>
            Removes all objects from the set.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Set.Contains(System.Object)">
            <summary>
            Returns <c>true</c> if this set contains the specified element.
            </summary>
            <param name="o">The element to look for.</param>
            <returns><c>true</c> if this set contains the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.ContainsAll(System.Collections.ICollection)">
            <summary>
            Returns <c>true</c> if the set contains all the elements in the specified collection.
            </summary>
            <param name="c">A collection of objects.</param>
            <returns><c>true</c> if the set contains all the elements in the specified collection, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.Remove(System.Object)">
            <summary>
            Removes the specified element from the set.
            </summary>
            <param name="o">The element to be removed.</param>
            <returns><c>true</c> if the set contained the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.RemoveAll(System.Collections.ICollection)">
            <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
            <param name="c">A collection of elements to remove.</param>
            <returns><c>true</c> if the set was modified as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.RetainAll(System.Collections.ICollection)">
            <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
            <param name="c">Collection that defines the set of elements to be retained.</param>
            <returns><c>true</c> if this set changed as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.Clone">
            <summary>
            Returns a clone of the <c>Set</c> instance.  This will work for derived <c>Set</c>
            classes if the derived class implements a constructor that takes no arguments.
            </summary>
            <returns>A clone of this object.</returns>
        </member>
        <member name="M:Iesi.Collections.Set.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements in the <c>Set</c> to an array.  The type of array needs
            to be compatible with the objects in the <c>Set</c>, obviously.
            </summary>
            <param name="array">An array that will be the target of the copy operation.</param>
            <param name="index">The zero-based index where copying will start.</param>
        </member>
        <member name="M:Iesi.Collections.Set.GetEnumerator">
            <summary>
            Gets an enumerator for the elements in the <c>Set</c>.
            </summary>
            <returns>An <c>IEnumerator</c> over the elements in the <c>Set</c>.</returns>
        </member>
        <member name="P:Iesi.Collections.Set.IsEmpty">
            <summary>
            Returns <c>true</c> if this set contains no elements.
            </summary>
        </member>
        <member name="P:Iesi.Collections.Set.Count">
            <summary>
            The number of elements currently contained in this collection.
            </summary>
        </member>
        <member name="P:Iesi.Collections.Set.IsSynchronized">
            <summary>
            Returns <c>true</c> if the <c>Set</c> is synchronized across threads.  Note that
            enumeration is inherently not thread-safe.  Use the <c>SyncRoot</c> to lock the
            object during enumeration.
            </summary>
        </member>
        <member name="P:Iesi.Collections.Set.SyncRoot">
            <summary>
            An object that can be used to synchronize this collection to make it thread-safe.
            When implementing this, if your object uses a base object, like an <c>IDictionary</c>,
            or anything that has a <c>SyncRoot</c>, return that object instead of "<c>this</c>".
            </summary>
        </member>
        <member name="F:Iesi.Collections.DictionarySet.InternalDictionary">
            <summary>
            Provides the storage for elements in the <c>Set</c>, stored as the key-set
            of the <c>IDictionary</c> object.  Set this object in the constructor
            if you create your own <c>Set</c> class.  
            </summary>
        </member>
        <member name="M:Iesi.Collections.DictionarySet.Add(System.Object)">
            <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
            <param name="o">The object to add to the set.</param>
            <returns><c>true</c> is the object was added, <c>false</c> if it was already present.</returns>
        </member>
        <member name="M:Iesi.Collections.DictionarySet.AddAll(System.Collections.ICollection)">
            <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
            <param name="c">A collection of objects to add to the set.</param>
            <returns><c>true</c> is the set changed as a result of this operation, <c>false</c> if not.</returns>
        </member>
        <member name="M:Iesi.Collections.DictionarySet.Clear">
            <summary>
            Removes all objects from the set.
            </summary>
        </member>
        <member name="M:Iesi.Collections.DictionarySet.Contains(System.Object)">
            <summary>
            Returns <c>true</c> if this set contains the specified element.
            </summary>
            <param name="o">The element to look for.</param>
            <returns><c>true</c> if this set contains the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.DictionarySet.ContainsAll(System.Collections.ICollection)">
            <summary>
            Returns <c>true</c> if the set contains all the elements in the specified collection.
            </summary>
            <param name="c">A collection of objects.</param>
            <returns><c>true</c> if the set contains all the elements in the specified collection, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.DictionarySet.Remove(System.Object)">
            <summary>
            Removes the specified element from the set.
            </summary>
            <param name="o">The element to be removed.</param>
            <returns><c>true</c> if the set contained the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.DictionarySet.RemoveAll(System.Collections.ICollection)">
            <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
            <param name="c">A collection of elements to remove.</param>
            <returns><c>true</c> if the set was modified as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.DictionarySet.RetainAll(System.Collections.ICollection)">
            <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
            <param name="c">Collection that defines the set of elements to be retained.</param>
            <returns><c>true</c> if this set changed as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.DictionarySet.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements in the <c>Set</c> to an array.  The type of array needs
            to be compatible with the objects in the <c>Set</c>, obviously.
            </summary>
            <param name="array">An array that will be the target of the copy operation.</param>
            <param name="index">The zero-based index where copying will start.</param>
        </member>
        <member name="M:Iesi.Collections.DictionarySet.GetEnumerator">
            <summary>
            Gets an enumerator for the elements in the <c>Set</c>.
            </summary>
            <returns>An <c>IEnumerator</c> over the elements in the <c>Set</c>.</returns>
        </member>
        <member name="P:Iesi.Collections.DictionarySet.Placeholder">
            <summary>
            The placeholder object used as the value for the <c>IDictionary</c> instance.
            </summary>
            <remarks>
            There is a single instance of this object globally, used for all <c>Sets</c>.
            </remarks>
        </member>
        <member name="P:Iesi.Collections.DictionarySet.IsEmpty">
            <summary>
            Returns <c>true</c> if this set contains no elements.
            </summary>
        </member>
        <member name="P:Iesi.Collections.DictionarySet.Count">
            <summary>
            The number of elements contained in this collection.
            </summary>
        </member>
        <member name="P:Iesi.Collections.DictionarySet.IsSynchronized">
            <summary>
            None of the objects based on <c>DictionarySet</c> are synchronized.  Use the
            <c>SyncRoot</c> property instead.
            </summary>
        </member>
        <member name="P:Iesi.Collections.DictionarySet.SyncRoot">
            <summary>
            Returns an object that can be used to synchronize the <c>Set</c> between threads.
            </summary>
        </member>
        <member name="M:Iesi.Collections.HashedSet.#ctor">
            <summary>
            Creates a new set instance based on a hash table.
            </summary>
        </member>
        <member name="M:Iesi.Collections.HashedSet.#ctor(System.Collections.ICollection)">
            <summary>
            Creates a new set instance based on a hash table and
            initializes it based on a collection of elements.
            </summary>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
        </member>
        <member name="T:Iesi.Collections.Generic.EnumeratorWrapper`1">
            <summary>
            Simple Wrapper for wrapping an regular Enumerator as a generic Enumberator&lt;T&gt;
            </summary>
            <typeparam name="T"></typeparam>
            <exception cref="T:System.InvalidCastException">
            If the wrapped has any item that is not of Type T, InvalidCastException could be thrown at any time
            </exception>
        </member>
        <member name="M:Iesi.Collections.Generic.EnumeratorWrapper`1.#ctor(System.Collections.IEnumerator)">
            <summary>
            ER.. a wrapper for this enumerator?
            </summary>
            <param name="toWrap"></param>
        </member>
        <member name="M:Iesi.Collections.Generic.EnumeratorWrapper`1.Dispose">
            <summary>
            Disposes this object
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.EnumeratorWrapper`1.MoveNext">
            <summary>
            Advances to the next member
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.EnumeratorWrapper`1.Reset">
            <summary>
            Resets
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.EnumeratorWrapper`1.Current">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Utilities.TokenType">
            <summary>
            Represents the type of token created by the StreamTokenizer class.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Utilities.TokenType.Word">
            <summary>
            Indicates that the token is a word.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Utilities.TokenType.Number">
            <summary>
            Indicates that the token is a number. 
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Utilities.TokenType.Eol">
            <summary>
            Indicates that the end of line has been read. The field can only have this value if the eolIsSignificant method has been called with the argument true. 
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Utilities.TokenType.Eof">
            <summary>
            Indicates that the end of the input stream has been reached.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Utilities.TokenType.Whitespace">
            <summary>
            Indictaes that the token is white space (space, tab, newline).
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Utilities.TokenType.Symbol">
            <summary>
            Characters that are not whitespace, numbers, etc...
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Sweepline.ISweepLineOverlapAction">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Sweepline.ISweepLineOverlapAction.Overlap(MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineInterval,MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineInterval)">
            <summary>
            
            </summary>
            <param name="s0"></param>
            <param name="s1"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree">
            <summary>
            Base class for STRtree and SIRtree. STR-packed R-trees are described in:
            P. Rigaux, Michel Scholl and Agnes Voisard. Spatial Databases With
            Application To GIS. Morgan Kaufmann, San Francisco, 2002.
            <para>
            This implementation is based on Boundables rather than just AbstractNodes,
            because the STR algorithm operates on both nodes and
            data, both of which are treated here as Boundables.
            </para>
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.root">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.#ctor(System.Int32)">
            <summary> 
            Constructs an AbstractSTRtree with the specified maximum number of child
            nodes that a node may have.
            </summary>
            <param name="nodeCapacity"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.Build">
            <summary> 
            Creates parent nodes, grandparent nodes, and so forth up to the root
            node, for the data that has been inserted into the tree. Can only be
            called once, and thus can be called only after all of the data has been
            inserted into the tree.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.CreateNode(System.Int32)">
            <summary>
            
            </summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.CreateParentBoundables(System.Collections.IList,System.Int32)">
            <summary>
            Sorts the childBoundables then divides them into groups of size M, where
            M is the node capacity.
            </summary>
            <param name="childBoundables"></param>
            <param name="newLevel"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.LastNode(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="nodes"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.CompareDoubles(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.CreateHigherLevels(System.Collections.IList,System.Int32)">
            <summary>
            Creates the levels higher than the given level.
            </summary>
            <param name="boundablesOfALevel">The level to build on.</param>
            <param name="level">the level of the Boundables, or -1 if the boundables are item
            boundables (that is, below level 0).</param>
            <returns>The root, which may be a ParentNode or a LeafNode.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.GetSize(MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractNode)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.GetDepth(MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractNode)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.Insert(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="bounds"></param>
            <param name="item"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.Query(System.Object)">
            <summary>
            Also builds the tree, if necessary.
            </summary>
            <param name="searchBounds"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.Query(System.Object,MapWinGeoProc.NTS.Topology.Index.IItemVisitor)">
            <summary>
            Also builds the tree, if necessary.
            </summary>
            <param name="searchBounds"></param>
            <param name="visitor"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.Query(System.Object,MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractNode,System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="searchBounds"></param>
            <param name="node"></param>
            <param name="matches"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.Query(System.Object,MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractNode,MapWinGeoProc.NTS.Topology.Index.IItemVisitor)">
            <summary>
            
            </summary>
            <param name="searchBounds"></param>
            <param name="node"></param>
            <param name="visitor"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.Remove(System.Object,System.Object)">
            <summary>
            Also builds the tree, if necessary.
            </summary>
            <param name="searchBounds"></param>
            <param name="item"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.RemoveItem(MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractNode,System.Object)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.Remove(System.Object,MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractNode,System.Object)">
            <summary>
            
            </summary>
            <param name="searchBounds"></param>
            <param name="node"></param>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.BoundablesAtLevel(System.Int32)">
            <summary>
            
            </summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.BoundablesAtLevel(System.Int32,MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractNode,System.Collections.IList@)">
            <summary>
            
            </summary>
            <param name="level">-1 to get items.</param>
            <param name="top"></param>
            <param name="boundables"></param>      
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.GetComparer">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.Root">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.NodeCapacity">
            <summary> 
            Returns the maximum number of child nodes that a node may have.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.Depth">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.IntersectsOp">
            <returns>
            A test for intersection between two bounds, necessary because subclasses
            of AbstractSTRtree have different implementations of bounds.
            </returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.IIntersectsOp">
            <returns>
            A test for intersection between two bounds, necessary because subclasses
            of AbstractSTRtree have different implementations of bounds.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractSTRtree.IIntersectsOp.Intersects(System.Object,System.Object)">
            <summary>
            For STRtrees, the bounds will be Envelopes; 
            for SIRtrees, Intervals;
            for other subclasses of AbstractSTRtree, some other class.
            </summary>
            <param name="aBounds">The bounds of one spatial object.</param>
            <param name="bBounds">The bounds of another spatial object.</param>                        
            <returns>Whether the two bounds intersect.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Quadtree.IntervalSize">
            <summary>
            Provides a test for whether an interval is
            so small it should be considered as zero for the purposes of
            inserting it into a binary tree.
            The reason this check is necessary is that round-off error can
            cause the algorithm used to subdivide an interval to fail, by
            computing a midpoint value which does not lie strictly between the
            endpoints.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Index.Quadtree.IntervalSize.MinBinaryExponent">
            <summary> 
            This value is chosen to be a few powers of 2 less than the
            number of bits available in the double representation (i.e. 53).
            This should allow enough extra precision for simple computations to be correct,
            at least for comparison purposes.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.IntervalSize.#ctor">
            <summary>
            Only static methods!
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.IntervalSize.IsZeroWidth(System.Double,System.Double)">
            <summary> 
            Computes whether the interval [min, max] is effectively zero width.
            I.e. the width of the interval is so much less than the
            location of the interval that the midpoint of the interval cannot be
            represented precisely.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequence">
            <summary>
            The CoordinateSequence implementation that Geometries use by default. In
            this implementation, Coordinates returned by ToArray and GetCoordinates are live --
            parties that change them are actually changing the
            DefaultCoordinateSequence's underlying data.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequence.#ctor(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Constructs a DefaultCoordinateSequence based on the given array (the
            array is not copied).
            </summary>
            <param name="coordinates">Coordinate array that will be assimilated.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequence.#ctor(MapWindow.Interfaces.Geometries.ICoordinateSequence)">
            <summary>
            
            </summary>
            <param name="coordSeq"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequence.#ctor(System.Int32)">
            <summary>
            Constructs a sequence of a given size, populated with new Coordinates.
            </summary>
            <param name="size">The size of the sequence to create.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequence.GetCoordinate(System.Int32)">
            <summary>
            Returns the coordinate at specified index.
            </summary>
            <param name="i">Coordinate index.</param>
            <return>Coordinate specified.</return>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequence.GetCoordinateCopy(System.Int32)">
            <summary>
            Returns a copy of the coordinate at specified index.
            </summary>
            <param name="i">Coordinate index.</param>
            <return>The copy of the coordinate specified.</return>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequence.GetCoordinate(System.Int32,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Copies the i'th coordinate in the sequence to the supplied Coordinate.
            Only the first two dimensions are copied.
            </summary>
            <param name="index">The index of the coordinate to copy.</param>
            <param name="coord">A Coordinate to receive the value.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequence.GetX(System.Int32)">
            <summary>
            Returns ordinate X (0) of the specified coordinate.
            </summary>
            <param name="index"></param>
            <returns>
            The value of the X ordinate in the index'th coordinate.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequence.GetY(System.Int32)">
            <summary>
            Returns ordinate Y (1) of the specified coordinate.
            </summary>
            <param name="index"></param>
            <returns>
            The value of the Y ordinate in the index'th coordinate.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequence.GetOrdinate(System.Int32,MapWindow.Interfaces.Geometries.Ordinates)">
            <summary>
            Returns the ordinate of a coordinate in this sequence.
            Ordinate indices 0 and 1 are assumed to be X and Y.
            Ordinates indices greater than 1 have user-defined semantics
            (for instance, they may contain other dimensions or measure values).
            </summary>
            <param name="index">The coordinate index in the sequence.</param>
            <param name="ordinate">The ordinate index in the coordinate (in range [0, dimension-1]).</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequence.SetOrdinate(System.Int32,MapWindow.Interfaces.Geometries.Ordinates,System.Double)">
            <summary>
            Sets the value for a given ordinate of a coordinate in this sequence.
            </summary>
            <param name="index">The coordinate index in the sequence.</param>
            <param name="ordinate">The ordinate index in the coordinate (in range [0, dimension-1]).</param>
            <param name="value">The new ordinate value.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequence.ExpandEnvelope(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            Expands the given Envelope to include the coordinates in the sequence.
            Allows implementing classes to optimize access to coordinate values.
            </summary>
            <param name="env">The envelope to expand.</param>
            <returns>A reference to the expanded envelope.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequence.Clone">
            <summary>
            Returns a deep copy of the object passed.
            </summary>
            <returns>The copied object.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequence.ToCoordinateArray">
            <summary>
            This method exposes the internal Array of Coordinate Objects.
            </summary>
            <returns>Coordinate[] array.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequence.ToString">
            <summary>
            Returns the string Representation of the coordinate array
            </summary>
            <returns>A string.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequence.Dimension">
            <summary>
            Returns the dimension (number of ordinates in each coordinate) for this sequence.
            </summary>
            <value></value>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequence.Item(System.Int32)">
            <summary>
            Returns the coordinate at specified index.
            </summary>
            <param name="i">Coordinate index.</param>
            <return>Coordinate specified.</return>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequence.Count">
            <summary>
            Returns the elements number of the coordinate sequence.
            </summary>
            <value></value>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequence.Length">
            <summary>
            Returns the elements number of the coordinate sequence.
            </summary>
            <value>The length.</value>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.GraphComponent">
            <summary>
            A GraphComponent is the parent class for the objects'
            that form a graph.  Each GraphComponent can carry a
            Label.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.GraphComponent.label">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GraphComponent.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GraphComponent.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.Label)">
            <summary>
            
            </summary>
            <param name="label"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GraphComponent.ComputeIM(MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix)">
            <summary>
            Compute the contribution to an IM for this component.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GraphComponent.UpdateIM(MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix)">
            <summary>
            Update the IM with the contribution for this component.
            A component only contributes if it has a labelling for both parent geometries.
            </summary>
            <param name="im"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.GraphComponent.Label">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.GraphComponent.InResult">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.GraphComponent.IsInResult">
            <summary> 
            IsInResult indicates if this component has already been included in the result.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.GraphComponent.Covered">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.GraphComponent.IsCovered">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.GraphComponent.IsCoveredSet">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.GraphComponent.Visited">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.GraphComponent.IsVisited">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.GraphComponent.Coordinate">
            <summary>
            
            </summary>
            <returns>
            A coordinate in this component (or null, if there are none).
            </returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.GraphComponent.IsIsolated">
            <summary>
            An isolated component is one that does not intersect or touch any other
            component.  This is the case if the label has valid locations for
            only a single Geometry.
            </summary>
            <returns><c>true</c> if this component is isolated.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.DepthFactor(MapWindow.Interfaces.Geometries.Locations,MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            Computes the factor for the change in depth when moving from one location to another.
            E.g. if crossing from the Interior to the Exterior the depth decreases, so the factor is -1.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.isForward">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.depth">
            <summary> 
            The depth of each side (position) of this edge.
            The 0 element of the array is never used.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge,System.Boolean)">
            <summary>
            
            </summary>
            <param name="edge"></param>
            <param name="isForward"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.GetDepth(MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.SetDepth(MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions,System.Int32)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="depthVal"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.ComputeDirectedLabel">
            <summary>
            Compute the label in the appropriate orientation for this DirEdge.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.SetEdgeDepths(MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions,System.Int32)">
            <summary> 
            Set both edge depths.  
            One depth for a given side is provided.  
            The other is computed depending on the Location 
            transition and the depthDelta of the edge.
            </summary>
            <param name="depth"></param>
            <param name="position"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.OLDSetEdgeDepths(MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions,System.Int32)">
            <summary> 
            Set both edge depths.  One depth for a given side is provided.  The other is
            computed depending on the Location transition and the depthDelta of the edge.
            </summary>
            <param name="depth"></param>
            <param name="position"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.Write(System.IO.StreamWriter)">
            <summary>
            
            </summary>
            <param name="outstream"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.WriteEdge(System.IO.StreamWriter)">
            <summary>
            
            </summary>
            <param name="outstream"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.InResult">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.IsInResult">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.Visited">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.IsVisited">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.EdgeRing">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.MinEdgeRing">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.DepthDelta">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.VisitedEdge">
            <summary>
            VisitedEdge get property returns <c>true</c> if bot Visited 
            and Sym.Visited are <c>true</c>.
            VisitedEdge set property marks both DirectedEdges attached to a given Edge.
            This is used for edges corresponding to lines, which will only
            appear oriented in a single direction in the result.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.IsForward">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.Sym">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.Next">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.NextMin">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.IsLineEdge">
            <summary>
            This edge is a line edge if
            at least one of the labels is a line label
            any labels which are not line labels have all Locations = Exterior.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge.IsInteriorAreaEdge">
            <summary> 
            This is an interior Area edge if
            its label is an Area label for both Geometries
            and for each Geometry both sides are in the interior.
            </summary>
            <returns><c>true</c> if this is an interior Area edge.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Unit">
            <summary>
            Class for defining units
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Unit.#ctor(System.Double,System.String,System.String,System.Int64,System.String,System.String,System.String)">
            <summary>
            Initializes a new unit
            </summary>
            <param name="conversionFactor">Conversion factor to base unit</param>
            <param name="name">Name of unit</param>
            <param name="authority">Authority name</param>
            <param name="authorityCode">Authority-specific identification code.</param>
            <param name="alias">Alias</param>
            <param name="abbreviation">Abbreviation</param>
            <param name="remarks">Provider-supplied remarks</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Unit.#ctor(System.String,System.Double)">
            <summary>
            Initializes a new unit
            </summary>
            <param name="name">Name of unit</param>
            <param name="conversionFactor">Conversion factor to base unit</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Unit.EqualParams(System.Object)">
            <summary>
            Checks whether the values of this instance is equal to the values of another instance.
            Only parameters used for coordinate system are used for comparison.
            Name, abbreviation, authority, alias and remarks are ignored in the comparison.
            </summary>
            <param name="obj"></param>
            <returns>True if equal</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Unit.ConversionFactor">
            <summary>
            Gets or sets the number of units per base-unit.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Unit.WKT">
            <summary>
            Returns the Well-known text for this object
            as defined in the simple features specification.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Unit.XML">
            <summary>
            Gets an XML representation of this object [NOT IMPLEMENTED].
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransformFactory">
            <summary>
            Creates math transforms.
            </summary>
            <remarks>
            <para>CT_MathTransformFactory is a low level factory that is used to create CT_MathTransform objects. Many high level GIS applications will never need to use a CT_MathTransformFactory directly; they can use a CT_CoordinateTransformationFactory instead. However, the CT_MathTransformFactory interface is specified here, since it can be used directly by applications that wish to transform other types of coordinates (e.g. color coordinates, or image pixel coordinates).</para>
            <para>The following comments assume that the same vendor implements the math transform factory interfaces and math transform interfaces.</para>
            <para>A math transform is an object that actually does the work of applying formulae to coordinate values. The math transform does not know or care how the coordinates relate to positions in the real world. This lack of semantics makes implementing CT_MathTransformFactory significantly easier than it would be otherwise.</para>
            <para>For example CT_MathTransformFactory can create affine math transforms. The affine transform applies a matrix to the coordinates without knowing how what it is doing relates to the real world. So if the matrix scales Z values by a factor of 1000, then it could be converting meters into millimeters, or it could be converting kilometers into meters.</para>
            <para>Because math transforms have low semantic value (but high mathematical value), programmers who do not have much knowledge of how GIS applications use coordinate systems, or how those coordinate systems relate to the real world can implement CT_MathTransformFactory.</para>
            <para>The low semantic content of math transforms also means that they will be useful in applications that have nothing to do with GIS coordinates. For example, a math transform could be used to map color coordinates between different color spaces, such as converting (red, green, blue) colors into (hue, light, saturation) colors.</para>
            <para>Since a math transform does not know what its source and target coordinate systems mean, it is not necessary or desirable for a math transform object to keep information on its source and target coordinate systems.</para>
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransformFactory.CreateAffineTransform(System.Double[0:,0:])">
            <summary>
            Creates an affine transform from a matrix.
            </summary>
            <remarks>If the transform's input dimension is M, and output dimension is N, then the matrix will have size [N+1][M+1]. The +1 in the matrix dimensions allows the matrix to do a shift, as well as a rotation. The [M][j] element of the matrix will be the j'th ordinate of the moved origin. The [i][N] element of the matrix will be 0 for i less than M, and 1 for i equals M.</remarks>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransformFactory.CreateConcatenatedTransform(MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.MathTransform,MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.MathTransform)">
            <summary>
            Creates a transform by concatenating two existing transforms. A concatenated transform acts in the same way as applying two transforms, one after the other.
            </summary>
            <remarks>The dimension of the output space of the first transform must match the dimension of the input space in the second transform. If you wish to concatenate more than two transforms, then you can repeatedly use this method.</remarks>
            <param name="transform1"></param>
            <param name="transform2"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransformFactory.CreateFromWKT(System.String)">
            <summary>
            Creates a math transform from a Well-Known Text string.
            </summary>
            <param name="wkt"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransformFactory.CreateFromXML(System.String)">
            <summary>
            Creates a math transform from XML.
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransformFactory.CreateParameterizedTransform(System.String,System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.CoordinateSystems.Parameter})">
            <summary>
            Creates a transform from a classification name and parameters.
            </summary>
            <remarks>
            The client must ensure that all the linear parameters are expressed in meters, and all the angular parameters are expressed in degrees. Also, they must supply "semi_major" and "semi_minor" parameters for cartographic projection transforms.
            </remarks>
            <param name="classification"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransformFactory.CreatePassThroughTransform(System.Int32,MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.MathTransform)">
            <summary>
            Creates a transform which passes through a subset of ordinates to another transform.
            </summary>
            <remarks>
            This allows transforms to operate on a subset of ordinates. For example, if you have (Lat,Lon,Height) coordinates, then you may wish to convert the height values from meters to feet without affecting the (Lat,Lon) values. If you wanted to affect the (Lat,Lon) values and leave the Height values alone, then you would have to swap the ordinates around to (Height,Lat,Lon). You can do this with an affine map.
            </remarks>
            <param name="firstAffectedOrdinate"></param>
            <param name="subTransform"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransformFactory.IsParameterAngular(System.String)">
            <summary>
            Tests whether parameter is angular. Clients must ensure that all angular parameter values are in degrees.
            </summary>
            <param name="parameterName"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransformFactory.IsParameterLinear(System.String)">
            <summary>
            Tests whether parameter is linear. Clients must ensure that all linear parameter values are in meters.
            </summary>
            <param name="parameterName"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeometryTransform">
            <summary>
            Helper class for transforming <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeometryTransform.TransformBox(MapWindow.Interfaces.Geometries.IEnvelope,MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform)">
            <summary>
            Transforms a bounding box.
            </summary>
            <param name="box">BoundingBox to transform</param>
            <param name="transform">Math Transform</param>
            <returns>Transformed object</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeometryTransform.TransformGeometry(MapWinGeoProc.NTS.Topology.Geometries.Geometry,MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform)">
            <summary>
            Transforms a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>.
            </summary>
            <param name="g">Geometry to transform</param>
            <param name="transform">MathTransform</param>
            <returns>Transformed Geometry</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeometryTransform.TransformPoint(MapWinGeoProc.NTS.Topology.Geometries.Point,MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform)">
            <summary>
            Transforms a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Point"/>.
            </summary>
            <param name="p">Point to transform</param>
            <param name="transform">MathTransform</param>
            <returns>Transformed Point</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeometryTransform.TransformLineString(MapWinGeoProc.NTS.Topology.Geometries.LineString,MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform)">
            <summary>
            Transforms a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.LineString"/>.
            </summary>
            <param name="l">LineString to transform</param>
            <param name="transform">MathTransform</param>
            <returns>Transformed LineString</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeometryTransform.TransformLinearRing(MapWinGeoProc.NTS.Topology.Geometries.LinearRing,MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform)">
            <summary>
            Transforms a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.LinearRing"/>.
            </summary>
            <param name="r">LinearRing to transform</param>
            <param name="transform">MathTransform</param>
            <returns>Transformed LinearRing</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeometryTransform.ExtractCoordinates(MapWinGeoProc.NTS.Topology.Geometries.LineString,MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform)">
            <summary>
            
            </summary>
            <param name="ls"></param>
            <param name="transform"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeometryTransform.TransformPolygon(MapWinGeoProc.NTS.Topology.Geometries.Polygon,MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform)">
            <summary>
            Transforms a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Polygon"/>.
            </summary>
            <param name="p">Polygon to transform</param>
            <param name="transform">MathTransform</param>
            <returns>Transformed Polygon</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeometryTransform.TransformMultiPoint(MapWinGeoProc.NTS.Topology.Geometries.MultiPoint,MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform)">
            <summary>
            Transforms a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.MultiPoint"/>.
            </summary>
            <param name="points">MultiPoint to transform</param>
            <param name="transform">MathTransform</param>
            <returns>Transformed MultiPoint</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeometryTransform.TransformMultiLineString(MapWinGeoProc.NTS.Topology.Geometries.MultiLineString,MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform)">
            <summary>
            Transforms a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.MultiLineString"/>.
            </summary>
            <param name="lines">MultiLineString to transform</param>
            <param name="transform">MathTransform</param>
            <returns>Transformed MultiLineString</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeometryTransform.TransformMultiPolygon(MapWinGeoProc.NTS.Topology.Geometries.MultiPolygon,MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform)">
            <summary>
            Transforms a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.MultiPolygon"/>.
            </summary>
            <param name="polys">MultiPolygon to transform</param>
            <param name="transform">MathTransform</param>
            <returns>Transformed MultiPolygon</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeometryTransform.TransformGeometryCollection(MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection,MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform)">
            <summary>
            Transforms a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection"/>.
            </summary>
            <param name="geoms">GeometryCollection to transform</param>
            <param name="transform">MathTransform</param>
            <returns>Transformed GeometryCollection</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.Mercator">
            <summary>
            Implements the Mercator projection.
            </summary>
            <remarks>
            <para>This map projection introduced in 1569 by Gerardus Mercator. It is often described as a cylindrical projection,
            but it must be derived mathematically. The meridians are equally spaced, parallel vertical lines, and the
            parallels of latitude are parallel, horizontal straight lines, spaced farther and farther apart as their distance
            from the Equator increases. This projection is widely used for navigation charts, because any straight line
            on a Mercator-projection map is a line of constant true bearing that enables a navigator to plot a straight-line
            course. It is less practical for world maps because the scale is distorted; areas farther away from the equator
            appear disproportionately large. On a Mercator projection, for example, the landmass of Greenland appears to be
            greater than that of the continent of South America; in actual area, Greenland is smaller than the Arabian Peninsula.
            </para>
            </remarks>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection">
            <summary>
            Projections inherit from this abstract class to get access to useful mathematical functions.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IProjection">
            <summary>
            The IProjection interface defines the standard information stored with projection
            objects. A projection object implements a coordinate transformation from a geographic
            coordinate system to a projected coordinate system, given the ellipsoid for the
            geographic coordinate system. It is expected that each coordinate transformation of
            interest, e.g., Transverse Mercator, Lambert, will be implemented as a COM class of
            coType Projection, supporting the IProjection interface.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.IProjection.GetParameter(System.Int32)">
            <summary>
            Gets an indexed parameter of the projection.
            </summary>
            <param name="n">Index of parameter</param>
            <returns>n'th parameter</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.IProjection.GetParameter(System.String)">
            <summary>
            Gets an named parameter of the projection.
            </summary>
            <remarks>The parameter name is case insensitive</remarks>
            <param name="name">Name of parameter</param>
            <returns>parameter or null if not found</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IProjection.NumParameters">
            <summary>
            Gets number of parameters of the projection.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IProjection.ClassName">
            <summary>
            Gets the projection classification name (e.g. 'Transverse_Mercator').
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.PI">
            <summary>
            PI
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.HALF_PI">
            <summary>
            Half of PI
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.TWO_PI">
            <summary>
            PI * 2
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.EPSLN">
            <summary>
            EPSLN
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.S2R">
            <summary>
            S2R
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.MAX_VAL">
            <summary>
            MAX_VAL
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.prjMAXLONG">
            <summary>
            prjMAXLONG
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.DBLLONG">
            <summary>
            DBLLONG
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.GetParameter(System.String)">
            <summary>
            Gets an named parameter of the projection.
            </summary>
            <remarks>The parameter name is case insensitive</remarks>
            <param name="name">Name of parameter</param>
            <returns>parameter or null if not found</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.Invert">
            <summary>
            Reverses the transformation
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.EqualParams(System.Object)">
            <summary>
            Checks whether the values of this instance is equal to the values of another instance.
            Only parameters used for coordinate system are used for comparison.
            Name, abbreviation, authority, alias and remarks are ignored in the comparison.
            </summary>
            <param name="obj"></param>
            <returns>True if equal</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.CUBE(System.Double)">
            <summary>
            Returns the cube of a number.
            </summary>
            <param name="x"> </param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.QUAD(System.Double)">
            <summary>
            Returns the quad of a number.
            </summary>
            <param name="x"> </param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.GMAX(System.Double@,System.Double@)">
            <summary>
            
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.GMIN(System.Double@,System.Double@)">
            <summary>
            
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.IMOD(System.Double,System.Double)">
            <summary>
            IMOD
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.sign(System.Double)">
            <summary>
            Function to return the sign of an argument
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.adjust_lon(System.Double)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.msfnz(System.Double,System.Double,System.Double)">
            <summary>
            Function to compute the constant small m which is the radius of
            a parallel of latitude, phi, divided by the semimajor axis.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.qsfnz(System.Double,System.Double,System.Double)">
            <summary>
            Function to compute constant small q which is the radius of a 
            parallel of latitude, phi, divided by the semimajor axis. 
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.sincos(System.Double,System.Double@,System.Double@)">
            <summary>
            Function to calculate the sine and cosine in one call.  Some computer
            systems have implemented this function, resulting in a faster implementation
            than calling each function separately.  It is provided here for those
            computer systems which don`t implement this function
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.tsfnz(System.Double,System.Double,System.Double)">
            <summary>
            Function to compute the constant small t for use in the forward
            computations in the Lambert Conformal Conic and the Polar
            Stereographic projections.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.phi1z(System.Double,System.Double,System.Int64@)">
            <summary>
            
            
            </summary>
            <param name="eccent"></param>
            <param name="qs"></param>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.asinz(System.Double)">
            <summary>
            Function to eliminate roundoff errors in asin
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.phi2z(System.Double,System.Double,System.Int64@)">
            <summary>Function to compute the latitude angle, phi2, for the inverse of the
              Lambert Conformal Conic and Polar Stereographic projections.
              </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.e0fn(System.Double)">
            <summary>
            Functions to compute the constants e0, e1, e2, and e3 which are used
            in a series for calculating the distance along a meridian.  The
            input x represents the eccentricity squared.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.e1fn(System.Double)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.e2fn(System.Double)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.e3fn(System.Double)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.e4fn(System.Double)">
            <summary>
            Function to compute the constant e4 from the input of the eccentricity
            of the spheroid, x.  This constant is used in the Polar Stereographic
            projection.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.mlfn(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Function computes the value of M which is the distance along a meridian
            from the Equator to latitude phi.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.calc_utm_zone(System.Double)">
            <summary>
            Function to calculate UTM zone number--NOTE Longitude entered in DEGREES!!!
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.LongitudeToRadians(System.Double,System.Boolean)">
            <summary>
            Converts a longitude value in degrees to radians.
            </summary>
            <param name="x">The value in degrees to convert to radians.</param>
            <param name="edge">If true, -180 and +180 are valid, otherwise they are considered out of range.</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.LatitudeToRadians(System.Double,System.Boolean)">
            <summary>
            Converts a latitude value in degrees to radians.
            </summary>
            <param name="y">The value in degrees to to radians.</param>
            <param name="edge">If true, -90 and +90 are valid, otherwise they are considered out of range.</param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.Abbreviation">
            <summary>
            Gets or sets the abbreviation of the object.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.Alias">
            <summary>
            Gets or sets the alias of the object.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.Authority">
            <summary>
            Gets or sets the authority name for this object, e.g., "EPSG",
            is this is a standard object with an authority specific
            identity code. Returns "CUSTOM" if this is a custom object.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.AuthorityCode">
            <summary>
            Gets or sets the authority specific identification code of the object
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.Name">
            <summary>
            Gets or sets the name of the object.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.Remarks">
            <summary>
            Gets or sets the provider-supplied remarks for the object.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.WKT">
            <summary>
            Returns the Well-known text for this object
            as defined in the simple features specification.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.XML">
            <summary>
            Gets an XML representation of this object
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.MapProjection.IsInverse">
            <summary>
            Returns true if this projection is inverted.
            Most map projections define forward projection as "from geographic to projection", and backwards
            as "from projection to geographic". If this projection is inverted, this will be the other way around.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.Mercator.#ctor(System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectionParameter})">
            <summary>
            Initializes the MercatorProjection object with the specified parameters to project points. 
            </summary>
            <param name="parameters">ParameterList with the required parameters.</param>
            <remarks>
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.Mercator.#ctor(System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectionParameter},System.Boolean)">
            <summary>
            Initializes the MercatorProjection object with the specified parameters.
            </summary>
            <param name="parameters">List of parameters to initialize the projection.</param>
            <param name="isInverse">Indicates whether the projection forward (meters to degrees or degrees to meters).</param>
            <remarks>
            <para>The parameters this projection expects are listed below.</para>
            <list type="table">
            <listheader><term>Items</term><description>Descriptions</description></listheader>
            <item><term>central_meridian</term><description>The longitude of the point from which the values of both the geographical coordinates on the ellipsoid and the grid coordinates on the projection are deemed to increment or decrement for computational purposes. Alternatively it may be considered as the longitude of the point which in the absence of application of false coordinates has grid coordinates of (0,0).</description></item>
            <item><term>latitude_of_origin</term><description>The latitude of the point from which the values of both the geographical coordinates on the ellipsoid and the grid coordinates on the projection are deemed to increment or decrement for computational purposes. Alternatively it may be considered as the latitude of the point which in the absence of application of false coordinates has grid coordinates of (0,0).</description></item>
            <item><term>scale_factor</term><description>The factor by which the map grid is reduced or enlarged during the projection process, defined by its value at the natural origin.</description></item>
            <item><term>false_easting</term><description>Since the natural origin may be at or near the centre of the projection and under normal coordinate circumstances would thus give rise to negative coordinates over parts of the mapped area, this origin is usually given false coordinates which are large enough to avoid this inconvenience. The False Easting, FE, is the easting value assigned to the abscissa (east).</description></item>
            <item><term>false_northing</term><description>Since the natural origin may be at or near the centre of the projection and under normal coordinate circumstances would thus give rise to negative coordinates over parts of the mapped area, this origin is usually given false coordinates which are large enough to avoid this inconvenience. The False Northing, FN, is the northing value assigned to the ordinate.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.Mercator.DegreesToMeters(MapWinGeoProc.NTS.Topology.Geometries.Point)">
            <summary>
            Converts coordinates in decimal degrees to projected meters.
            </summary>
            <remarks>
            <para>The parameters this projection expects are listed below.</para>
            <list type="table">
            <listheader><term>Items</term><description>Descriptions</description></listheader>
            <item><term>longitude_of_natural_origin</term><description>The longitude of the point from which the values of both the geographical coordinates on the ellipsoid and the grid coordinates on the projection are deemed to increment or decrement for computational purposes. Alternatively it may be considered as the longitude of the point which in the absence of application of false coordinates has grid coordinates of (0,0).  Sometimes known as ""central meridian""."</description></item>
            <item><term>latitude_of_natural_origin</term><description>The latitude of the point from which the values of both the geographical coordinates on the ellipsoid and the grid coordinates on the projection are deemed to increment or decrement for computational purposes. Alternatively it may be considered as the latitude of the point which in the absence of application of false coordinates has grid coordinates of (0,0).</description></item>
            <item><term>scale_factor_at_natural_origin</term><description>The factor by which the map grid is reduced or enlarged during the projection process, defined by its value at the natural origin.</description></item>
            <item><term>false_easting</term><description>Since the natural origin may be at or near the centre of the projection and under normal coordinate circumstances would thus give rise to negative coordinates over parts of the mapped area, this origin is usually given false coordinates which are large enough to avoid this inconvenience. The False Easting, FE, is the easting value assigned to the abscissa (east).</description></item>
            <item><term>false_northing</term><description>Since the natural origin may be at or near the centre of the projection and under normal coordinate circumstances would thus give rise to negative coordinates over parts of the mapped area, this origin is usually given false coordinates which are large enough to avoid this inconvenience. The False Northing, FN, is the northing value assigned to the ordinate .</description></item>
            </list>
            </remarks>
            <param name="lonlat">The point in decimal degrees.</param>
            <returns>Point in projected meters</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.Mercator.MetersToDegrees(MapWinGeoProc.NTS.Topology.Geometries.Point)">
            <summary>
            Converts coordinates in projected meters to decimal degrees.
            </summary>
            <param name="p">Point in meters</param>
            <returns>Transformed point in decimal degrees</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.Mercator.Inverse">
            <summary>
            Returns the inverse of this projection.
            </summary>
            <returns>IMathTransform that is the reverse of the current projection.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.LambertConformalConic2SP">
            <summary>
            Implemetns the Lambert Conformal Conic 2SP Projection.
            </summary>
            <remarks>
            <para>The Lambert Conformal Conic projection is a standard projection for presenting maps
            of land areas whose East-West extent is large compared with their North-South extent.
            This projection is "conformal" in the sense that lines of latitude and longitude, 
            which are perpendicular to one another on the earth's surface, are also perpendicular
            to one another in the projected domain.</para>
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.LambertConformalConic2SP.#ctor(System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectionParameter})">
            <summary>
            Creates an instance of an LambertConformalConic2SPProjection projection object.
            </summary>
            <remarks>
            <para>The parameters this projection expects are listed below.</para>
            <list type="table">
            <listheader><term>Items</term><description>Descriptions</description></listheader>
            <item><term>latitude_of_false_origin</term><description>The latitude of the point which is not the natural origin and at which grid coordinate values false easting and false northing are defined.</description></item>
            <item><term>longitude_of_false_origin</term><description>The longitude of the point which is not the natural origin and at which grid coordinate values false easting and false northing are defined.</description></item>
            <item><term>latitude_of_1st_standard_parallel</term><description>For a conic projection with two standard parallels, this is the latitude of intersection of the cone with the ellipsoid that is nearest the pole.  Scale is true along this parallel.</description></item>
            <item><term>latitude_of_2nd_standard_parallel</term><description>For a conic projection with two standard parallels, this is the latitude of intersection of the cone with the ellipsoid that is furthest from the pole.  Scale is true along this parallel.</description></item>
            <item><term>easting_at_false_origin</term><description>The easting value assigned to the false origin.</description></item>
            <item><term>northing_at_false_origin</term><description>The northing value assigned to the false origin.</description></item>
            </list>
            </remarks>
            <param name="parameters">List of parameters to initialize the projection.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.LambertConformalConic2SP.#ctor(System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectionParameter},System.Boolean)">
            <summary>
            Creates an instance of an Albers projection object.
            </summary>
            <remarks>
            <para>The parameters this projection expects are listed below.</para>
            <list type="table">
            <listheader><term>Parameter</term><description>Description</description></listheader>
            <item><term>latitude_of_origin</term><description>The latitude of the point which is not the natural origin and at which grid coordinate values false easting and false northing are defined.</description></item>
            <item><term>central_meridian</term><description>The longitude of the point which is not the natural origin and at which grid coordinate values false easting and false northing are defined.</description></item>
            <item><term>standard_parallel_1</term><description>For a conic projection with two standard parallels, this is the latitude of intersection of the cone with the ellipsoid that is nearest the pole.  Scale is true along this parallel.</description></item>
            <item><term>standard_parallel_2</term><description>For a conic projection with two standard parallels, this is the latitude of intersection of the cone with the ellipsoid that is furthest from the pole.  Scale is true along this parallel.</description></item>
            <item><term>false_easting</term><description>The easting value assigned to the false origin.</description></item>
            <item><term>false_northing</term><description>The northing value assigned to the false origin.</description></item>
            </list>
            </remarks>
            <param name="parameters">List of parameters to initialize the projection.</param>
            <param name="isInverse">Indicates whether the projection forward (meters to degrees or degrees to meters).</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.LambertConformalConic2SP.DegreesToMeters(MapWinGeoProc.NTS.Topology.Geometries.Point)">
            <summary>
            Converts coordinates in decimal degrees to projected meters.
            </summary>
            <param name="lonlat">The point in decimal degrees.</param>
            <returns>Point in projected meters</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.LambertConformalConic2SP.MetersToDegrees(MapWinGeoProc.NTS.Topology.Geometries.Point)">
            <summary>
            Converts coordinates in projected meters to decimal degrees.
            </summary>
            <param name="p">Point in meters</param>
            <returns>Transformed point in decimal degrees</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.LambertConformalConic2SP.Inverse">
            <summary>
            Returns the inverse of this projection.
            </summary>
            <returns>IMathTransform that is the reverse of the current projection.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeodeticSpatialReference">
            <summary>
            The IGeodeticSpatialReference interface defines a root interface for all types of geodetic
            spatial references, it is a subclass of ICoordinateSystem.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.MCPointInRing">
            <summary>
            Implements <c>IPointInRing</c>
            using a <c>MonotoneChain</c>s and a <c>BinTree</c> index to increase performance.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.IPointInRing">
            <summary> 
            An interface for classes which test whether a <c>Coordinate</c> lies inside a ring.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.IPointInRing.IsInside(MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.MCPointInRing.#ctor(MapWinGeoProc.NTS.Topology.Geometries.LinearRing)">
            <summary>
            
            </summary>
            <param name="ring"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.MCPointInRing.BuildIndex">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.MCPointInRing.IsInside(MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.MCPointInRing.TestMonotoneChain(MapWinGeoProc.NTS.Topology.Geometries.Envelope,MapWinGeoProc.NTS.Topology.Algorithm.MCPointInRing.MCSelecter,MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain)">
            <summary>
            
            </summary>
            <param name="rayEnv"></param>
            <param name="mcSelecter"></param>
            <param name="mc"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.MCPointInRing.TestLineSegment(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ILineSegment)">
            <summary>
            
            </summary>
            <param name="p"></param>
            <param name="seg"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.MCPointInRing.MCSelecter">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainSelectAction">
            <summary>
            The action for the internal iterator for performing
            envelope select queries on a MonotoneChain.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainSelectAction.TempEnv1">
            <summary>
            These envelopes are used during the MonotoneChain search process.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainSelectAction.SelectedSegment">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainSelectAction.Select(MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain,System.Int32)">
            <summary> 
            This function can be overridden if the original chain is needed.
            </summary>
            <param name="mc"></param>
            <param name="start"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainSelectAction.Select(MapWinGeoProc.NTS.Topology.Geometries.LineSegment)">
            <summary>
            This is a convenience function which can be overridden to obtain the actual
            line segment which is selected.
            </summary>
            <param name="seg"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.MCPointInRing.MCSelecter.#ctor(MapWinGeoProc.NTS.Topology.Algorithm.MCPointInRing,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="container"></param>
            <param name="p"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.MCPointInRing.MCSelecter.Select(MapWinGeoProc.NTS.Topology.Geometries.LineSegment)">
            <summary>
            
            </summary>
            <param name="ls"></param>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.DialogElement">
            <summary>
            A modular component that can be inherited to retrieve parameters for functions.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.DialogElement.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.DialogElement.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.DialogElement.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.DialogElement.cmdHelp">
            <summary>
            Help button
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.DialogElement.lblLight">
            <summary>
            Status Light
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.DialogElement.groupBox1">
            <summary>
            A group box to surround individual components
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.DialogElement.#ctor">
            <summary>
            Initialization of the element.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.DialogElement.OnClick(System.EventArgs)">
            <summary>
            Called to fire the click event for this element
            </summary>
            <param name="e">A mouse event args thingy</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.DialogElement.OnHelpButtonPressed(MapWinGeoProc.Dialogs.HelpPannelEventArgs)">
            <summary>
            Called when the help button has been pressed
            </summary>
            <param name="e">A HelpPanelEventArgs parameter with a new help title, text and image.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.DialogElement.OnHelpContextChanged(MapWinGeoProc.Dialogs.HelpPannelEventArgs)">
            <summary>
            Called when the data entry field is entered to change a topic, but only if panel is visible
            </summary>
            <param name="e">A HelpPanelEventArgs parameter with a new help title, text and image.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.DialogElement.OnResizeStarted">
            <summary>
            Fires when someone uses the resize grip to resize the element
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.DialogElement.OnResizeEnded">
            <summary>
            Fires when someone has stopped resizing with the grip
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.DialogElement.HelpText_Append(System.String)">
            <summary>
            Appends a string to the end of the help content
            </summary>
            <param name="HelpText"></param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.DialogElement.HelpText_Clear(System.String)">
            <summary>
            Clears the existing help content.
            </summary>
            <param name="HelpText"></param>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.DialogElement.Clicked">
            <summary>
            Fires when the inactive areas around the controls are clicked on the element.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.DialogElement.HelpButtonPressed">
            <summary>
            Fires when the help button is clicked.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.DialogElement.HelpContextChanged">
            <summary>
            Fires when the the user enters a data entry region.  Changes help without opening panel.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.DialogElement.ResizeStarted">
            <summary>
            Fires when the element is being resized.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.DialogElement.ResizeEnded">
            <summary>
            Fires when the element is no longer being resized.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.DialogElement.Caption">
            <summary>
            Controls the caption for this element (the group box text)
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.DialogElement.HelpButtonVisible">
            <summary>
            Gets or sets whether or not the help button is visible.
            The help button that looks like a question mark will force open the help pannel
            and populate it with the help content from this control.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.DialogElement.ResizeGripVisible">
            <summary>
            Gets or sets whether a resize grip is provided for the user to change the dimensions of the control.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.DialogElement.LightVisible">
            <summary>
            Gets or sets whether the status light is visible for this element.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.DialogElement.LightMessage">
            <summary>
            Gets or sets the tool tip that shows when you hold the mouse over the light
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.DialogElement.Status">
            <summary>
            Indicates the current condition of this element.
            - Green = ok to continue
            - Yellow = not specified yet
            - Red = process halting error
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.DialogElement.AllowGripResize">
            <summary>
            Gets or sets a boolean.  True if the user is allowed to adjust the width of the 
            element to better display longer filenames.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.DialogElement.Halt">
            <summary>
            Boolean, true if either of the conditions that may prevent dialog completion are true 
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.DialogElement.HaltOnEmpty">
            <summary>
            Gets or sets a boolean.  True if an unspecified condition will prevent dialog completion.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.DialogElement.HaltOnError">
            <summary>
            Gets or sets a boolean.  True if an Error status will prevent dialog completion.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.DialogElement.MaxWidth">
            <summary>
            Gets or sets the maximum allowable width for dynamic resize.  The dialog form sets this
            dynamically to the size of the container panel.  This is because the behavior for
            resizing larger than the size of the panel is erratic because of the autoscrolling
            behavior.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.DialogElement.MinWidth">
            <summary>
            Gets or sets the minimum allowable width for dynamic resizing.  This specifically affects
            the behavior when the user uses the grip to resize the element.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.DialogElement.HelpImage">
            <summary>
            Gets or Sets the image that will appear after the help text in the panel, if any.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.DialogElement.HelpText">
            <summary>
            Gets or Sets the text to appear in the help pannel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.DialogElement.HelpTitle">
            <summary>
            Gets or Sets the title to be shown in the help panel.  Defaults to the Caption.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.DialogElement.WikiAddress">
            <summary>
            Gets or Sets the web address to use from the wiki button in the help panel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.DialogElement.DefaultImage">
            <summary>
            Gets or Sets the default image that will be used in the help panel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.DialogElement.AlternateImage">
            <summary>
            Gets or Sets the alternate image that can be used in the help panel instead.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.DialogElement.LightStatus">
            <summary>
            Indicates the allowed values for the status of the element, illustrated by the light
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.DialogElement.LightStatus.Empty">
            <summary>
            Indicates that no value has been set for this yet.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.DialogElement.LightStatus.Ok">
            <summary>
            Indicates that the element parameter is ok and won't halt.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.DialogElement.LightStatus.Error">
            <summary>
            Indicates that the element value will cause an error.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.DialogElement.HelpButtonHandler">
            <summary>
            Public delegate for when someone presses the help button
            </summary>
            <param name="sender">The element sending the event</param>
            <param name="e">HelpPannelEventArgs with help title, text and an image</param>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.DialogElement.ResizeStartedHandler">
            <summary>
            Delegate for the when someone starts resizing an element
            </summary>
            <param name="sender">The element being resized</param>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.DialogElement.ResizeEndedHandler">
            <summary>
            Fires when the element is no longer being resized.
            </summary>
            <param name="sender"></param>
        </member>
        <member name="T:MapWinGeoProc.Merge">
            <summary>
            Functions for merging two shapes of the same type into one (if possible).
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Merge.MergeShapes(MapWinGIS.Shapefile@,System.Int32,System.Int32,MapWinGIS.Shape@)">
            <summary>
            Merges two lines (at matching end points) or two polygons 
            (by dissolving the common border or by combining into a multi-part polygon) 
            to make one result shape.
            This version requires that both shapes be located in the same shapefile.
            </summary>
            <param name="shapes">The shapefile containing the two shapes to be merged.</param>
            <param name="indexOne">The index of the first shape.</param>
            <param name="indexTwo">The index of the second shape.</param>
            <param name="resultShp">The result of merging the shapes at indexOne and indexTwo together.</param>
            <returns>True if the shapes were merged, false otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Merge.MergePoints(MapWinGIS.Point@,MapWinGIS.Point@,MapWinGIS.ShpfileType,MapWinGIS.Shape@)">
            <summary>
            Will check to see if two points are identical.
            </summary>
            <param name="point1">The first point to consider.</param>
            <param name="point2">The second point to consider.</param>
            <param name="sfType">The type of shapefile the points belong to.</param>
            <param name="mergedShp">The result shape</param>
            <returns>True if the points were merged successfully, false otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Merge.MergeLines(MapWinGIS.Shape@,MapWinGIS.Shape@,MapWinGIS.ShpfileType,MapWinGIS.Shape@)">
            <summary>
            Merges two lines together if they share a common end point.
            </summary>
            <param name="line1">The first line to be considered.</param>
            <param name="line2">The second line to be considered.</param>
            <param name="sfType">The type of shapefile the lines are a part of.</param>
            <param name="resultShp">The two lines merged into one multipart line</param>
            <returns>True if merging was successful, false otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Merge.MergePolygons(MapWinGIS.Shape@,MapWinGIS.Shape@,MapWinGIS.ShpfileType,MapWinGIS.Shape@)">
            <summary>
            Merges two polygons together. If they touch, they will be UNIONed together, 
            If they do not touch, they will be combined into one multi-part shape.
            </summary>
            <param name="poly1">The first polygon to be considered.</param>
            <param name="poly2">The second polygon to be considered.</param>
            <param name="sfType">The type of shapefile the polygons are a part of.</param>
            <param name="resultShp">The polygon shape that results after merging.</param>
            <returns>True if merging was successful, false otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Merge.CombinePolygons(MapWinGIS.Shape@,MapWinGIS.Shape@,MapWinGIS.Shape@)">
            <summary>
            Creates one multi-part polygon out of two input polygons.
            </summary>
            <param name="poly1">The first polygon to be combined.</param>
            <param name="poly2">The second polygon to be combined.</param>
            <param name="resultShp">The resulting multi-part polygon.</param>
            <returns>True if combining was successful, false otherwise.</returns>
        </member>
        <member name="T:MapWinGeoProc.Interpolation">
            <summary>
            Class to hold interpolation functions
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Interpolation.IDW(System.String,System.Int32,System.String)">
            <summary>
            Inverse Distance Weighting Interpolation
            </summary>
            <param name="InPointsPath">Input point shapefile path to interpolate</param>
            <param name="InValueFieldIndex">Input field index where interpolation value is stored</param>
            <param name="OutGridPath">Output grid path where interpolation is stored</param>
        </member>
        <member name="M:MapWinGeoProc.Interpolation.IDW(System.String,System.Int32,System.String,System.Double)">
            <summary>
            Inverse Distance Weighting Interpolation
            </summary>
            <param name="InPointsPath">Input point shapefile path to interpolate</param>
            <param name="InValueFieldIndex">Input field index where interpolation value is stored</param>
            <param name="OutGridPath">Output grid path where interpolation is stored</param>
            <param name="CellSize">Cell Size for output grid. Default lower of points extent height or width divided by 250</param>
        </member>
        <member name="M:MapWinGeoProc.Interpolation.IDW(System.String,System.Int32,System.String,System.Double,MapWinGeoProc.Interpolation.IDWNeighborhoodType)">
            <summary>
            Inverse Distance Weighting Interpolation
            </summary>
            <param name="InPointsPath">Input point shapefile path to interpolate</param>
            <param name="InValueFieldIndex">Input field index where interpolation value is stored</param>
            <param name="OutGridPath">Output grid path where interpolation is stored</param>
            <param name="CellSize">Cell Size for output grid. Default lower of points extent height or width divided by 250</param>
            <param name="NeighborhoodType">Variable is a variable number of nearest points. Fixed is all points in a fixed distance</param>
        </member>
        <member name="M:MapWinGeoProc.Interpolation.IDW(System.String,System.Int32,System.String,System.Double,System.Double)">
            <summary>
            Inverse Distance Weighting Interpolation
            </summary>
            <param name="InPointsPath">Input point shapefile path to interpolate</param>
            <param name="InValueFieldIndex">Input field index where interpolation value is stored</param>
            <param name="OutGridPath">Output grid path where interpolation is stored</param>
            <param name="CellSize">Cell Size for output grid. Default lower of points extent height or width divided by 250</param>
            <param name="Power">Power variable for IDW algorithm. 0 lt p lt 1 will give sharp changes. >1 will give smoother. Default 2.</param>
        </member>
        <member name="M:MapWinGeoProc.Interpolation.IDW(System.String,System.Int32,System.String,System.Double,System.Double,MapWinGeoProc.Interpolation.IDWNeighborhoodType)">
            <summary>
            Inverse Distance Weighting Interpolation
            </summary>
            <param name="InPointsPath">Input point shapefile path to interpolate</param>
            <param name="InValueFieldIndex">Input field index where interpolation value is stored</param>
            <param name="OutGridPath">Output grid path where interpolation is stored</param>
            <param name="CellSize">Cell Size for output grid. Default lower of points extent height or width divided by 250</param>
            <param name="Power">Power variable for IDW algorithm. 0 lt p lt 1 will give sharp changes. >1 will give smoother. Default 2.</param>
            <param name="NeighborhoodType">Variable is a variable number of nearest points. Fixed is all points in a fixed distance</param>
        </member>
        <member name="M:MapWinGeoProc.Interpolation.IDW(System.String,System.Int32,System.String,System.Double,System.Double,MapWinGeoProc.Interpolation.IDWNeighborhoodType,System.Int32,System.Double,MapWinGIS.ICallback)">
            <summary>
            Inverse Distance Weighting Interpolation
            </summary>
            <param name="InPointsPath">Input point shapefile path to interpolate</param>
            <param name="InValueFieldIndex">Input field index where interpolation value is stored</param>
            <param name="OutGridPath">Output grid path where interpolation is stored</param>
            <param name="CellSize">Cell Size for output grid. Default lower of points extent height or width divided by 250</param>
            <param name="Power">Power variable for IDW algorithm. 0 lt p lt 1 will give sharp changes. >1 will give smoother. Default 2.</param>
            <param name="NeighborhoodType">Variable is a variable number of nearest points. Fixed is all points in a fixed distance</param>
            <param name="NeighborhoodCount">Variable Count is either number of nearest points to use. Fixed Count is minimum points needed to find valid interpolation</param>
            <param name="NeighborhoodDistance">Variable Distance is a maximum distance of nearest points. Fixed Distance is distance to use to select points</param>
            <param name="callback">A callback for progress information</param>
        </member>
        <member name="M:MapWinGeoProc.Interpolation.IDWBrute(System.String,System.Int32,System.String,System.Double,System.Double,MapWinGeoProc.Interpolation.IDWNeighborhoodType,System.Int32,System.Double,MapWinGIS.ICallback)">
            <summary>
            Inverse Distance Weighting Interpolation
            </summary>
            <param name="InPointsPath">Input point shapefile path to interpolate</param>
            <param name="InValueFieldIndex">Input field index where interpolation value is stored</param>
            <param name="OutGridPath">Output grid path where interpolation is stored</param>
            <param name="CellSize">Cell Size for output grid. Default lower of points extent height or width divided by 250</param>
            <param name="Power">Power variable for IDW algorithm. 0 lt p lt 1 will give sharp changes. >1 will give smoother. Default 2.</param>
            <param name="NeighborhoodType">Variable is a variable number of nearest points. Fixed is all points in a fixed distance</param>
            <param name="NeighborhoodCount">Variable Count is either number of nearest points to use. Fixed Count is minimum points needed to find valid interpolation</param>
            <param name="NeighborhoodDistance">Variable Distance is a maximum distance of nearest points. Fixed Distance is distance to use to select points</param>
            <param name="callback">A callback for progress information</param>
        </member>
        <member name="T:MapWinGeoProc.Interpolation.InterpolationPoint">
            <summary>
            A class to store interpolation point information
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Interpolation.InterpolationPoint.X">
            <summary>
            X value
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Interpolation.InterpolationPoint.Y">
            <summary>
            Y value
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Interpolation.InterpolationPoint.Value">
            <summary>
            Value to interpolate
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Interpolation.InterpolationPoint.Distance">
            <summary>
            Changing distance value used as a marker for sorting
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Interpolation.InterpolationPoint.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Interpolation.InterpolationPoint.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Populating constructor that autofills as it creates a new point
            </summary>
            <param name="inX"></param>
            <param name="inY"></param>
            <param name="inValue"></param>
            <param name="inDistance"></param>
        </member>
        <member name="T:MapWinGeoProc.Interpolation.InterpolationPointSorter">
            <summary>
            Sorter class for InterpolationPoint classes
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Interpolation.IDWNeighborhoodType">
            <summary>
            Type of neighborhood search to use. 
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Interpolation.IDWNeighborhoodType.Variable">
            <summary>
            Variable will search for a certain number of nearest points. 
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Interpolation.IDWNeighborhoodType.Fixed">
            <summary>
            Fixed will search for all points in a fixed radius.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Interpolation.IDWNeighborhoodType.Unknown">
            <summary>
            Unknown type
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Topology2D.LinearRing">
            <summary>
            A Line String that is closed and has the same first point and last point.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Topology2D.LineString">
            <summary>
            This represents a two dimensional collection of points that represent connected segments.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.LineString.m_Coordinates">
            <summary>
            List of points.  For normal use, please use Add_Point or Insert_Point to correctly
            handle extents and prevent duplicate entries
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.#ctor">
            <summary>
            Creates a new, empty instance of the Polyline class.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.#ctor(System.Object)">
            <summary>
            This will use the factory in order to create a linestring from a shape
            </summary>
            <param name="MapWinGIS_Shape">A MapWinGIS.Shape</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Contains(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Crosses(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Disjoint(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Equals(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Intersects(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Overlaps(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Touches(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Within(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.AsBinary">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.AsText">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Boundary">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Buffer(System.Double)">
            <summary>
            Not Implemented Yet
            </summary>
            <param name="Distance">The orthogonal distance of the buffer to this linestring</param>
            <returns>A Polygon representing a buffer around this Linestring</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.ConvexHull">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Difference(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Distance(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Equals(System.Object)">
            <summary>
            Not Implemented
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.GetHashCode">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Intersection(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Relate(MapWinGeoProc.Topology2D.Geometry,System.String)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <param name="IntersectionPatternMatrix"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.SymDifference(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.ShortestPathTo(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.ToString">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Union(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Currently only supports point and linestring unions.
            </summary>
            <param name="geom">A geometry</param>
            <returns>A linestring if the ends are connected, or a multilinestring if not</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Copy">
            <summary>
            Returns a new instance of the Polyline class with the same values as this object.
            </summary>
            <returns>Topology2D.Polyline with identical points.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Invalidate">
            <summary>
            Many properties are derived from the points.  Generally, these are calculated
            once and cached.  Most changes that can be made externally will automatically
            cause an invalidation to occur, so adding points, for instance, will force
            the perimeter to be recalculated.  This forces such an invalidation so that the
            next time derived properties are queried, they will be recalculated.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Add_Point(MapWinGeoProc.Topology2D.Point)">
            <summary>
            Adds a point to the list of points and adjusts the extents
            Invalidates derived properties so that they will be recalculated when
            queried.
            </summary>
            <param name="newPoint">A Point to add to the Polygon</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Add_Coordinate(MapWinGeoProc.Topology2D.Coordinate)">
            <summary>
            Adds a coordinate to the list of coordinates and
            invalidates the dependent properties
            </summary>
            <param name="newCoord">The new Topology.2D coordinate to add</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Insert_Point(System.Int32,MapWinGeoProc.Topology2D.Point)">
            <summary>
            Inserts a point in the list.  Remember that this list does not need to
            end with the first point.  Invalidates derived properties so that they
            will be recalculated when queried.
            </summary>
            <param name="Index">The index specifying where to insert the point</param>
            <param name="newPoint">The Point you want to insert into this polyline</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Insert_Coordinate(System.Int32,MapWinGeoProc.Topology2D.Coordinate)">
            <summary>
            Inserts a point in the list.  Remember that this list does not need to
            end with the first point.  Invalidates derived properties so that they
            will be recalculated when queried.
            </summary>
            <param name="Index">The index specifying where to insert the point</param>
            <param name="newCoord">The Point you want to insert into this polyline</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Add_LineSegment(MapWinGeoProc.Topology2D.LineSegment)">
            <summary>
            Appends the the givin line segment to the end of the polyline.
            We assume that if the first point in the segment is the same as the
            endpoint of the polygon, we don't need to add the first point.
            </summary>
            <param name="newLineSegment">LineSegment, the line segment to append</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Insert_LineSegment(System.Int32,MapWinGeoProc.Topology2D.LineSegment)">
            <summary>
            Inserts a segment into a polyline.
            This will check the points of the segment and only add the points if they are 
            not identical to what will become the adjacent points.
            </summary>
            <param name="Index">the position to add the segment in the list of points</param>
            <param name="newLineSegment">The LineSegment to insert</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.ToLineSegments">
            <summary>
            Will create a list of segment objects for the entire polygon
            </summary>
            <returns>A List of LineSegments representing the entire polygon</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.LineSegmentsWithin(MapWinGeoProc.Topology2D.Envelope)">
            <summary>
            Returns a list of segments from the Polyline that are within the
            submitted extents.
            </summary>
            <param name="Ext">Envelope to check for an intersection with.</param>
            <returns>Returns a list of possible Envelope within range.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.Simplified_DP(System.Single)">
            <summary>
            Returns a Douglas-Peuker simplification of the line string.
            http://softsurfer.com/Archive/algorithm_0205/algorithm_0205.htm
            D. H. Douglass and T. K. Peucker.  "Algorithms for the reduction of the nuber 
                of points required to represent a line or its caricature."
                The Canadian Cartographer 10(2):112-122 1973
            Warning... simplified is not the same as being Simple (Aka non-intersecting)
            Simplified in this case just means made up of only characteristic points
            </summary>
            <returns>Line String (A Simplified version of the linestring</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineString.LineSegmentsWithinDistanceOf(MapWinGeoProc.Topology2D.Point,System.Double)">
            <summary>
            Creates a list of segments from this polyline that are within the specified distance to a point
            </summary>
            <param name="Point">The point that represents the test location</param>
            <param name="Distance">Double, the maximum distance for selection</param>
            <returns>A List of LineSegments that are within Distance of the specified Point.</returns>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.LineString.Center">
            <summary>
            Returns a Point representing the midpoint between all the extents.
            This is not the same as the centroid, which is wieghted by the
            enclosed area.  Setting this will translate your entire polyline,
            so be careful.  The center will automatically correct itself if points are added.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.LineString.Envelope">
            <summary>
            The extents that form a bounding box around the polyline.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.LineString.Length">
            <summary>
            Gets a double specifying the length along the polyline
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.LineString.MaxRadius">
            <summary>
            Gets a double specifying the maximum distance any segment gets from the center
            where the center is defined as the middle of the extents.  Since it is not
            possible for the segments to be further away than the endpoints, the max radius
            must be defined by one of the vertecies.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.LineString.NetDistance">
            <summary>
            Gets a double representing the distance of the first point to the last point
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.LineString.Dimension">
            <summary>
            Returns the dimension of the geometry.  In this case, LineStrings are 1 dimensional
            so this property returns 1.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.LineString.Coordinates">
            <summary>
            A list of points within this polygon.  The last point is NOT the same
            as the first, so when adding points just add the last one.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LinearRing.#ctor">
            <summary>
            Constructs a blank instance of a linear ring
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LinearRing.#ctor(System.Collections.Generic.List{MapWinGeoProc.Topology2D.Coordinate})">
            <summary>
            Creates a new instance of a linear ring from a coordinate list
            </summary>
            <param name="Coords">A List of coordinates</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LinearRing.AsText">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LinearRing.AsBinary">
            <summary>
            Not implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LinearRing.Boundary">
            <summary>
            The boundary of a linear ring is the same as the linear ring itself.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LinearRing.Equals(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Tests if the geometry is equal
            </summary>
            <param name="geom">A geometry to test for equality</param>
            <returns>true if the other geometry is a linear ring and has the same points</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LinearRing.Disjoint(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LinearRing.Intersects(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LinearRing.Touches(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LinearRing.Crosses(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LinearRing.Within(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LinearRing.Contains(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LinearRing.Overlaps(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LinearRing.Relate(MapWinGeoProc.Topology2D.Geometry,System.String)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <param name="IntersectionPatternMatrix"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LinearRing.Distance(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LinearRing.Buffer(System.Double)">
            <summary>
            
            </summary>
            <param name="Distance"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LinearRing.ConvexHull">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LinearRing.Intersection(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LinearRing.Union(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LinearRing.Difference(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LinearRing.SymDifference(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LinearRing.ShortestPathTo(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.LinearRing.IsClosed">
            <summary>
            By definition LinearRings must be closed
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.LinearRing.Dimension">
            <summary>
            This shape is two dimensional
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.LinearRing.NumPoints">
            <summary>
            Returns the number of points in the ring
            </summary>
        </member>
        <member name="T:Iesi.Collections.Generic.HybridSet`1">
            <summary>
            Implements a <c>Set</c> that automatically changes from a list to a hash table
            when the size reaches a certain threshold.  This is good if you are unsure about
            whether you data-set will be tiny or huge.  Because this uses a dual implementation,
            iteration order is not guaranteed!
            </summary>
        </member>
        <member name="T:Iesi.Collections.Generic.DictionarySet`1">
             <summary>
             <p><c>DictionarySet</c> is an abstract class that supports the creation of new <c>Set</c>
             types where the underlying data store is an <c>IDictionary</c> instance.</p> 
              
             <p>You can use any object that implements the <c>IDictionary</c> interface to hold set data.
             You can define your own, or you can use one of the objects provided in the Framework.   
             The type of <c>IDictionary</c> you choose will affect both the performance and the behavior
             of the <c>Set</c> using it. </p>
            
             <p>To make a <c>Set</c> typed based on your own <c>IDictionary</c>, simply derive a
             new class with a constructor that takes no parameters.  Some <c>Set</c> implmentations
             cannot be defined with a default constructor.  If this is the case for your class, 
             you will need to override <c>Clone()</c> as well.</p>
            
             <p>It is also standard practice that at least one of your constructors takes an <c>ICollection</c> or 
             an <c>ISet</c> as an argument.</p>
             </summary>
        </member>
        <member name="T:Iesi.Collections.Generic.Set`1">
            <summary><p>A collection that contains no duplicate elements.  This class models the mathematical
            <c>Set</c> abstraction, and is the base class for all other <c>Set</c> implementations.  
            The order of elements in a set is dependant on (a)the data-structure implementation, and 
            (b)the implementation of the various <c>Set</c> methods, and thus is not guaranteed.</p>
             
            <p>None of the <c>Set</c> implementations in this library are guranteed to be thread-safe
            in any way.</p>
            
            <p>The following table summarizes the binary operators that are supported by the <c>Set</c> class.</p>
            <list type="table">
            	<listheader>
            		<term>Operation</term>
            		<term>Description</term>
            		<term>Method</term>
            		<term>Operator</term>
            	</listheader>
            	<item>
            		<term>Union (OR)</term>
            		<term>Element included in result if it exists in either <c>A</c> OR <c>B</c>.</term>
            		<term><c>Union()</c></term>
            		<term><c>|</c></term>
            	</item>
            	<item>
            		<term>Intersection (AND)</term>
            		<term>Element included in result if it exists in both <c>A</c> AND <c>B</c>.</term>
            		<term><c>InterSect()</c></term>
            		<term><c>&amp;</c></term>
            	</item>
            	<item>
            		<term>Exclusive Or (XOR)</term>
            		<term>Element included in result if it exists in one, but not both, of <c>A</c> and <c>B</c>.</term>
            		<term><c>ExclusiveOr()</c></term>
            		<term><c>^</c></term>
            	</item>
            	<item>
            		<term>Minus (n/a)</term>
            		<term>Take all the elements in <c>A</c>.  Now, if any of them exist in <c>B</c>, remove
            		them.  Note that unlike the other operators, <c>A - B</c> is not the same as <c>B - A</c>.</term>
            		<term><c>Minus()</c></term>
            		<term><c>-</c></term>
            	</item>
            </list>
            </summary>
            <remarks>
                Set&lt;T&gt; supports operator between Set&lt;T&gt; and ISet, however, the ISet must contains only elements of type T
            </remarks>
        </member>
        <member name="T:Iesi.Collections.Generic.ISet`1">
            <summary>
            <p>A collection that contains no duplicate elements.  This interface models the mathematical
            <c>Set</c> abstraction.    
            The order of elements in a set is dependant on (a)the data-structure implementation, and 
            (b)the implementation of the various <c>Set</c> methods, and thus is not guaranteed.</p>
            
            <p>None of the <c>Set</c> implementations in this library are guranteed to be thread-safe
            in any way.</p>
            
            <p>The following table summarizes the binary operators that are supported by the <c>Set</c> class.</p>
            <list type="table">
            	<listheader>
            		<term>Operation</term>
            		<term>Description</term>
            		<term>Method</term>
            	</listheader>
            	<item>
            		<term>Union (OR)</term>
            		<term>Element included in result if it exists in either <c>A</c> OR <c>B</c>.</term>
            		<term><c>Union()</c></term>
            	</item>
            	<item>
            		<term>Intersection (AND)</term>
            		<term>Element included in result if it exists in both <c>A</c> AND <c>B</c>.</term>
            		<term><c>InterSect()</c></term>
            	</item>
            	<item>
            		<term>Exclusive Or (XOR)</term>
            		<term>Element included in result if it exists in one, but not both, of <c>A</c> and <c>B</c>.</term>
            		<term><c>ExclusiveOr()</c></term>
            	</item>
            	<item>
            		<term>Minus (n/a)</term>
            		<term>Take all the elements in <c>A</c>.  Now, if any of them exist in <c>B</c>, remove
            		them.  Note that unlike the other operators, <c>A - B</c> is not the same as <c>B - A</c>.</term>
            		<term><c>Minus()</c></term>
            	</item>
            </list>
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.Union(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs a "union" of the two sets, where all the elements
            in both sets are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            Neither this set nor the input set are modified during the operation.  The return value
            is a <c>Clone()</c> of this set with the extra elements added in.
            </summary>
            <param name="a">A collection of elements.</param>
            <returns>A new <c>Set</c> containing the union of this <c>Set</c> with the specified collection.
            Neither of the input objects is modified by the union.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.Intersect(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included if it exists in
            both sets.  The <c>Intersect()</c> operation does not modify the input sets.  It returns
            a <c>Clone()</c> of this set with the appropriate elements removed.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>The intersection of this set with <c>a</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.Minus(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of this <c>Set</c> containing the elements from the operation.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>A set containing the elements from this set with the elements in <c>a</c> removed.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.ExclusiveOr(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of this set containing
            the elements from the exclusive-or operation.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>A set containing the result of <c>a ^ b</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.Contains(`0)">
            <summary>
            Returns <c>true</c> if this set contains the specified element.
            </summary>
            <param name="o">The element to look for.</param>
            <returns><c>true</c> if this set contains the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.ContainsAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Returns <c>true</c> if the set contains all the elements in the specified collection.
            </summary>
            <param name="c">A collection of objects.</param>
            <returns><c>true</c> if the set contains all the elements in the specified collection, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.Add(`0)">
            <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
            <param name="o">The object to add to the set.</param>
            <returns><c>true</c> is the object was added, <c>false</c> if it was already present.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.AddAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
            <param name="c">A collection of objects to add to the set.</param>
            <returns><c>true</c> is the set changed as a result of this operation, <c>false</c> if not.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.Remove(`0)">
            <summary>
            Removes the specified element from the set.
            </summary>
            <param name="o">The element to be removed.</param>
            <returns><c>true</c> if the set contained the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.RemoveAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
            <param name="c">A collection of elements to remove.</param>
            <returns><c>true</c> if the set was modified as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.RetainAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
            <param name="c">Collection that defines the set of elements to be retained.</param>
            <returns><c>true</c> if this set changed as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.Clear">
            <summary>
            Removes all objects from the set.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.ISet`1.Clone">
            <summary>
            Creates a new ISet
            </summary>
            <returns></returns>
        </member>
        <member name="P:Iesi.Collections.Generic.ISet`1.IsEmpty">
            <summary>
            Returns <c>true</c> if this set contains no elements.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.Union(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs a "union" of the two sets, where all the elements
            in both sets are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            Neither this set nor the input set are modified during the operation.  The return value
            is a <c>Clone()</c> of this set with the extra elements added in.
            </summary>
            <param name="a">A collection of elements.</param>
            <returns>A new <c>Set</c> containing the union of this <c>Set</c> with the specified collection.
            Neither of the input objects is modified by the union.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.Union(Iesi.Collections.Generic.ISet{`0},Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs a "union" of two sets, where all the elements
            in both are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            The return value is a <c>Clone()</c> of one of the sets (<c>a</c> if it is not <c>null</c>) with elements of the other set
            added in.  Neither of the input sets is modified by the operation.
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>A set containing the union of the input sets.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.op_BitwiseOr(Iesi.Collections.Generic.Set{`0},Iesi.Collections.Generic.Set{`0})">
            <summary>
            Performs a "union" of two sets, where all the elements
            in both are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            The return value is a <c>Clone()</c> of one of the sets (<c>a</c> if it is not <c>null</c>) with elements of the other set
            added in.  Neither of the input sets is modified by the operation.
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>A set containing the union of the input sets.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.Intersect(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included if it exists in
            both sets.  The <c>Intersect()</c> operation does not modify the input sets.  It returns
            a <c>Clone()</c> of this set with the appropriate elements removed.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>The intersection of this set with <c>a</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.Intersect(Iesi.Collections.Generic.ISet{`0},Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included only if it exists in
            both <c>a</c> and <c>b</c>.  Neither input object is modified by the operation.
            The result object is a <c>Clone()</c> of one of the input objects (<c>a</c> if it is not <c>null</c>) containing the
            elements from the intersect operation. 
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>The intersection of the two input sets.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.op_BitwiseAnd(Iesi.Collections.Generic.Set{`0},Iesi.Collections.Generic.Set{`0})">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included only if it exists in
            both <c>a</c> and <c>b</c>.  Neither input object is modified by the operation.
            The result object is a <c>Clone()</c> of one of the input objects (<c>a</c> if it is not <c>null</c>) containing the
            elements from the intersect operation. 
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>The intersection of the two input sets.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.Minus(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of this <c>Set</c> containing the elements from the operation.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>A set containing the elements from this set with the elements in <c>a</c> removed.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.Minus(Iesi.Collections.Generic.ISet{`0},Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of set <c>a</c> containing the elements from the operation. 
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>A set containing <c>A - B</c> elements.  <c>null</c> if <c>a</c> is <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.op_Subtraction(Iesi.Collections.Generic.Set{`0},Iesi.Collections.Generic.Set{`0})">
            <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of set <c>a</c> containing the elements from the operation. 
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>A set containing <c>A - B</c> elements.  <c>null</c> if <c>a</c> is <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.ExclusiveOr(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of this set containing
            the elements from the exclusive-or operation.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>A set containing the result of <c>a ^ b</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.ExclusiveOr(Iesi.Collections.Generic.ISet{`0},Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of one of the sets
            (<c>a</c> if it is not <c>null</c>) containing
            the elements from the exclusive-or operation.
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>A set containing the result of <c>a ^ b</c>.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.op_ExclusiveOr(Iesi.Collections.Generic.Set{`0},Iesi.Collections.Generic.Set{`0})">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of one of the sets
            (<c>a</c> if it is not <c>null</c>) containing
            the elements from the exclusive-or operation.
            </summary>
            <param name="a">A set of elements.</param>
            <param name="b">A set of elements.</param>
            <returns>A set containing the result of <c>a ^ b</c>.  <c>null</c> if both sets are <c>null</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.Add(`0)">
            <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
            <param name="o">The object to add to the set.</param>		
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.AddAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
            <param name="c">A collection of objects to add to the set.</param>
            <returns><c>true</c> is the set changed as a result of this operation, <c>false</c> if not.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.ContainsAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Returns <c>true</c> if the set contains all the elements in the specified collection.
            </summary>
            <param name="c">A collection of objects.</param>
            <returns><c>true</c> if the set contains all the elements in the specified collection, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.Remove(`0)">
            <summary>
            Removes the specified element from the set.
            </summary>
            <param name="o">The element to be removed.</param>
            <returns><c>true</c> if the set contained the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.RemoveAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
            <param name="c">A collection of elements to remove.</param>
            <returns><c>true</c> if the set was modified as
            a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.RetainAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
            <param name="c">Collection that defines the set of elements to be retained.</param>
            <returns><c>true</c> if this set changed as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.Clear">
            <summary>
            Removes all objects from the set.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.Contains(`0)">
            <summary>
            Returns <c>true</c> if this set contains the specified element.
            </summary>
            <param name="o">The element to look for.</param>
            <returns><c>true</c> if this set contains the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.Clone">
            <summary>
            Returns a clone of the <c>Set</c> instance.  This will work for derived <c>Set</c>
            classes if the derived class implements a constructor that takes no arguments.
            </summary>
            <returns>A clone of this object.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements in the <c>Set</c> to an array.  The type of array needs
            to be compatible with the objects in the <c>Set</c>, obviously.
            </summary>
            <param name="array">An array that will be the target of the copy operation.</param>
            <param name="index">The zero-based index where copying will start.</param>
        </member>
        <member name="M:Iesi.Collections.Generic.Set`1.GetEnumerator">
            <summary>
            Gets an enumerator for the elements in the <c>Set</c>.
            </summary>
            <returns>An <c>IEnumerator</c> over the elements in the <c>Set</c>.</returns>
        </member>
        <member name="P:Iesi.Collections.Generic.Set`1.IsEmpty">
            <summary>
            Returns <c>true</c> if this set contains no elements.
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.Set`1.Count">
            <summary>
            The number of elements currently contained in this collection.
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.Set`1.IsSynchronized">
            <summary>
            Returns <c>true</c> if the <c>Set</c> is synchronized across threads.  Note that
            enumeration is inherently not thread-safe.  Use the <c>SyncRoot</c> to lock the
            object during enumeration.
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.Set`1.SyncRoot">
            <summary>
            An object that can be used to synchronize this collection to make it thread-safe.
            When implementing this, if your object uses a base object, like an <c>IDictionary</c>,
            or anything that has a <c>SyncRoot</c>, return that object instead of "<c>this</c>".
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.Set`1.IsReadOnly">
            <summary>
            Returns whether this collection is readonly.
            </summary>
        </member>
        <member name="F:Iesi.Collections.Generic.DictionarySet`1.InternalDictionary">
            <summary>
            Provides the storage for elements in the <c>Set</c>, stored as the key-set
            of the <c>IDictionary</c> object.  Set this object in the constructor
            if you create your own <c>Set</c> class.  
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.DictionarySet`1.Add(`0)">
            <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
            <param name="o">The object to add to the set.</param>
            <returns><c>true</c> is the object was added, <c>false</c> if it was already present.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.DictionarySet`1.AddAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
            <param name="c">A collection of objects to add to the set.</param>
            <returns><c>true</c> is the set changed as a result of this operation, <c>false</c> if not.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.DictionarySet`1.Clear">
            <summary>
            Removes all objects from the set.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.DictionarySet`1.Contains(`0)">
            <summary>
            Returns <c>true</c> if this set contains the specified element.
            </summary>
            <param name="o">The element to look for.</param>
            <returns><c>true</c> if this set contains the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.DictionarySet`1.ContainsAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Returns <c>true</c> if the set contains all the elements in the specified collection.
            </summary>
            <param name="c">A collection of objects.</param>
            <returns><c>true</c> if the set contains all the elements in the specified collection, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.DictionarySet`1.Remove(`0)">
            <summary>
            Removes the specified element from the set.
            </summary>
            <param name="o">The element to be removed.</param>
            <returns><c>true</c> if the set contained the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.DictionarySet`1.RemoveAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
            <param name="c">A collection of elements to remove.</param>
            <returns><c>true</c> if the set was modified as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.DictionarySet`1.RetainAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
            <param name="c">Collection that defines the set of elements to be retained.</param>
            <returns><c>true</c> if this set changed as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.DictionarySet`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements in the <c>Set</c> to an array.  The type of array needs
            to be compatible with the objects in the <c>Set</c>, obviously.
            </summary>
            <param name="array">An array that will be the target of the copy operation.</param>
            <param name="index">The zero-based index where copying will start.</param>
        </member>
        <member name="M:Iesi.Collections.Generic.DictionarySet`1.GetEnumerator">
            <summary>
            Gets an enumerator for the elements in the <c>Set</c>.
            </summary>
            <returns>An <c>IEnumerator</c> over the elements in the <c>Set</c>.</returns>
        </member>
        <member name="P:Iesi.Collections.Generic.DictionarySet`1.Placeholder">
            <summary>
            The placeholder object used as the value for the <c>IDictionary</c> instance.
            </summary>
            <remarks>
            There is a single instance of this object globally, used for all <c>Sets</c>.
            </remarks>
        </member>
        <member name="P:Iesi.Collections.Generic.DictionarySet`1.IsEmpty">
            <summary>
            Returns <c>true</c> if this set contains no elements.
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.DictionarySet`1.Count">
            <summary>
            The number of elements contained in this collection.
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.DictionarySet`1.IsSynchronized">
            <summary>
            Boolean... Always false
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.DictionarySet`1.SyncRoot">
            <summary>
            NotImplemented
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.HybridSet`1.#ctor">
            <summary>
            Creates a new set instance based on either a list or a hash table, depending on which 
            will be more efficient based on the data-set size.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.HybridSet`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Creates a new set instance based on either a list or a hash table, depending on which 
            will be more efficient based on the data-set size, and
            initializes it based on a collection of elements.
            </summary>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Utilities.Global">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.Global.GetNfi">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge">
            <summary>
            Represents a directed edge in a <c>PlanarGraph</c>. A DirectedEdge may or
            may not have a reference to a parent Edge (some applications of
            planar graphs may not require explicit Edge objects to be created). Usually
            a client using a <c>PlanarGraph</c> will subclass <c>DirectedEdge</c>
            to add its own application-specific data and methods.    
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.ToEdges(System.Collections.IList)">
            <summary>
            Returns a List containing the parent Edge (possibly null) for each of the given
            DirectedEdges.
            </summary>
            <param name="dirEdges"></param>
            <returns></returns>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.parentEdge">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.from">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.to">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.p0">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.p1">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.sym">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.edgeDirection">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.quadrant">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.angle">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.#ctor(MapWinGeoProc.NTS.Topology.Planargraph.Node,MapWinGeoProc.NTS.Topology.Planargraph.Node,MapWindow.Interfaces.Geometries.ICoordinate,System.Boolean)">
            <summary>
            Constructs a DirectedEdge connecting the <c>from</c> node to the
            <c>to</c> node.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <param name="directionPt">
            Specifies this DirectedEdge's direction (given by an imaginary
            line from the <c>from</c> node to <c>directionPt</c>).
            </param>
            <param name="edgeDirection">
            Whether this DirectedEdge's direction is the same as or
            opposite to that of the parent Edge (if any).
            </param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.CompareTo(System.Object)">
            <summary>
            Returns 1 if this DirectedEdge has a greater angle with the
            positive x-axis than b", 0 if the DirectedEdges are collinear, and -1 otherwise.
            Using the obvious algorithm of simply computing the angle is not robust,
            since the angle calculation is susceptible to roundoff. A robust algorithm
            is:
            first compare the quadrants. If the quadrants are different, it it
            trivial to determine which vector is "greater".
            if the vectors lie in the same quadrant, the robust
            <c>RobustCGAlgorithms.ComputeOrientation(Coordinate, Coordinate, Coordinate)</c>
            function can be used to decide the relative orientation of the vectors.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.CompareDirection(MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge)">
            <summary>
            Returns 1 if this DirectedEdge has a greater angle with the
            positive x-axis than b", 0 if the DirectedEdges are collinear, and -1 otherwise.
            Using the obvious algorithm of simply computing the angle is not robust,
            since the angle calculation is susceptible to roundoff. A robust algorithm
            is:
            first compare the quadrants. If the quadrants are different, it it
            trivial to determine which vector is "greater".
            if the vectors lie in the same quadrant, the robust
            <c>RobustCGAlgorithms.ComputeOrientation(Coordinate, Coordinate, Coordinate)</c>
            function can be used to decide the relative orientation of the vectors.
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.Write(System.IO.StreamWriter)">
            <summary>
            Writes a detailed string representation of this DirectedEdge to the given PrintStream.
            </summary>
            <param name="outstream"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.Remove">
            <summary>
            Removes this directed edge from its containing graph.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.Edge">
            <summary>
            Returns this DirectedEdge's parent Edge, or null if it has none.
            Associates this DirectedEdge with an Edge (possibly null, indicating no associated
            Edge).
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.Quadrant">
            <summary>
            Returns 0, 1, 2, or 3, indicating the quadrant in which this DirectedEdge's
            orientation lies.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.DirectionPt">
            <summary>
            Returns a point to which an imaginary line is drawn from the from-node to
            specify this DirectedEdge's orientation.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.EdgeDirection">
            <summary>
            Returns whether the direction of the parent Edge (if any) is the same as that
            of this Directed Edge.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.FromNode">
            <summary>
            Returns the node from which this DirectedEdge leaves.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.ToNode">
            <summary>
            Returns the node to which this DirectedEdge goes.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.Coordinate">
            <summary>
            Returns the coordinate of the from-node.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.Angle">
            <summary>
            Returns the angle that the start of this DirectedEdge makes with the
            positive x-axis, in radians.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.Sym">
            <summary>
            Returns the symmetric DirectedEdge -- the other DirectedEdge associated with
            this DirectedEdge's parent Edge.
            Sets this DirectedEdge's symmetric DirectedEdge, which runs in the opposite
            direction.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge.IsRemoved">
            <summary>
            Tests whether this component has been removed from its containing graph.
            </summary>
            <value></value>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Overlay.EdgeSetNoder">
            <summary>
            Nodes a set of edges.
            Takes one or more sets of edges and constructs a
            new set of edges consisting of all the split edges created by
            noding the input edges together.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.EdgeSetNoder.#ctor(MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector)">
            <summary>
            
            </summary>
            <param name="li"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.EdgeSetNoder.AddEdges(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="edges"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Overlay.EdgeSetNoder.NodedEdges">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer">
            <summary>
            <para>
            Builds a sequence from a set of <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.LineString"/>s,
            so that they are ordered end to end.
            A sequence is a complete non-repeating list of the linear
            components of the input.  Each linestring is oriented
            so that identical endpoints are adjacent in the list.
            </para>
            <para>
            The input linestrings may form one or more connected sets.
            The input linestrings should be correctly noded, or the results may
            not be what is expected.
            The output of this method is a single <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.MultiLineString"/>,
            containing the ordered linestrings in the sequence.
            </para>
            <para>
            The sequencing employs the classic 'Eulerian path' graph algorithm.
            Since Eulerian paths are not uniquely determined, further rules are used to
            make the computed sequence preserve as much as possible of the input ordering.
            Within a connected subset of lines, the ordering rules are:    
             - If there is degree-1 node which is the start
            node of an linestring, use that node as the start of the sequence.
             - If there is a degree-1 node which is the end
            node of an linestring, use that node as the end of the sequence.
             - If the sequence has no degree-1 nodes, use any node as the start
            </para>
            <para>
            Not all arrangements of lines can be sequenced.
            For a connected set of edges in a graph,
            Euler's Theorem states that there is a sequence containing each edge once
            if and only if there are no more than 2 nodes of odd degree.
            If it is not possible to find a sequence, the <see cref="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer.IsSequenceable"/> 
            property will return <c>false</c>.
            </para>
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer.IsSequenced(MapWinGeoProc.NTS.Topology.Geometries.Geometry)">
            <summary>
            Tests whether a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/> is sequenced correctly.
            <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.LineString"/>s are trivially sequenced.
            <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.MultiLineString"/>s are checked for correct sequencing.
            Otherwise, <c>IsSequenced</c> is defined
            to be <c>true</c> for geometries that are not lineal.
            </summary>
            <param name="geom">The <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/> to test.</param>
            <returns>
            <c>true</c> if the <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/> is sequenced or is not lineal.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:LineSequencer"/> class.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer.Add(System.Collections.Generic.IEnumerable{MapWinGeoProc.NTS.Topology.Geometries.Geometry})">
            <summary>
            Adds a <see cref="T:System.Collections.IEnumerable"/> of <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>s to be sequenced.
            May be called multiple times.
            Any dimension of Geometry may be added; the constituent linework will be extracted.
            </summary>
            <param name="geometries">A <see cref="T:System.Collections.IEnumerable"/> of geometries to add.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer.Add(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Adds a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/> to be sequenced.
            May be called multiple times.
            Any dimension of <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/> may be added; 
            the constituent linework will be extracted.
            </summary>
            <param name="geometry"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer.AddLine(MapWinGeoProc.NTS.Topology.Geometries.LineString)">
            <summary>
            
            </summary>
            <param name="lineString"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer.IsSequenceable">
            <summary>
            Tests whether the arrangement of linestrings has a valid sequence.
            </summary>
            <returns><c>true</c> if a valid sequence exists.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer.GetSequencedLineStrings">
            <summary>
            Returns the <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.LineString"/> or <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.MultiLineString"/>
            built by the sequencing process, if one exists.
            </summary>
            <returns>The sequenced linestrings,
            or <c>null</c> if a valid sequence does not exist.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer.ComputeSequence">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer.FindSequences">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer.HasSequence(MapWinGeoProc.NTS.Topology.Planargraph.Subgraph)">
            <summary>
            Tests whether a complete unique path exists in a graph
            using Euler's Theorem.
            </summary>
            <param name="graph">The <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.Subgraph"/> containing the edges.</param>
            <returns><c>true</c> if a sequence exists.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer.FindSequence(MapWinGeoProc.NTS.Topology.Planargraph.Subgraph)">
            <summary>
            
            </summary>
            <param name="graph"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer.FindUnvisitedBestOrientedDE(MapWinGeoProc.NTS.Topology.Planargraph.Node)">
            <summary>
            Finds an <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge"/> for an unvisited edge (if any),
            choosing the <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge"/> which preserves orientation, if possible.
            </summary>
            <param name="node">The <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.Node"/> to examine.</param>
            <returns>
            The <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge"/> found, 
            or <c>null</c> if none were unvisited.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer.AddReverseSubpath(MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge,System.Collections.Generic.LinkedListNode{MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge},System.Collections.Generic.LinkedList{MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge},System.Boolean)">
            <summary>
            
            </summary>
            <param name="de"></param>
            <param name="pos"></param>
            <param name="list"></param>
            <param name="expectedClosed"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer.FindLowestDegreeNode(MapWinGeoProc.NTS.Topology.Planargraph.Subgraph)">
            <summary>
            
            </summary>
            <param name="graph"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer.Orient(System.Collections.IList)">
            <summary>
            Computes a version of the sequence which is optimally
            oriented relative to the underlying geometry.
            <para>
            Heuristics used are:   
             - If the path has a degree-1 node which is the start
            node of an linestring, use that node as the start of the sequence.
             - If the path has a degree-1 node which is the end
            node of an linestring, use that node as the end of the sequence.
             - If the sequence has no degree-1 nodes, use any node as the start
            (NOTE: in this case could orient the sequence according to the majority of the
            linestring orientations).
            </para>
            </summary>
            <param name="seq">A <see cref="T:System.Collections.IList"/> of <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge"/>s.</param>
            <returns>
            A <see cref="T:System.Collections.IList"/> of <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge"/>s oriented appropriately.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer.Reverse(System.Collections.IList)">
            <summary>
            Reverse the sequence.
            This requires reversing the order of the <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge"/>s, 
            and flipping each <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge"/> as well.
            </summary>
            <param name="seq">
            A <see cref="T:System.Collections.IList"/> of <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge"/>s, 
            in sequential order.
            </param>
            <returns>The reversed sequence.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer.BuildSequencedGeometry(System.Collections.IList)">
            <summary>
            Builds a geometry (<see cref="T:MapWinGeoProc.NTS.Topology.Geometries.LineString"/> or <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.MultiLineString"/>)
            representing the sequence.
            </summary>
            <param name="sequences">
            A <see cref="T:System.Collections.IList"/> of <see cref="T:System.Collections.IList"/>s of <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge"/>s
            with <see cref="T:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMergeEdge"/>s as their parent edges.
            </param>
            <returns>
            The sequenced geometry, or <c>null</c> if no sequence exists.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer.Reverse(MapWindow.Interfaces.Geometries.ILineStringBase)">
            <summary>
            
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer.GeometryComponentFilterImpl">
            <summary>
            A private implementation for <see cref="T:MapWindow.Interfaces.Geometries.IGeometryComponentFilter"/>
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer.GeometryComponentFilterImpl.#ctor(MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer)">
            <summary>
            Initializes a new instance of the <see cref="T:GeometryComponentFilterImpl"/> class.
            </summary>
            <param name="sequencer">The sequencer.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineSequencer.GeometryComponentFilterImpl.Filter(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Performs an operation with or on <paramref name="component"/>
            </summary>
            <param name="component">
            A <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/> to which the filter is applied.
            </param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.WktStreamTokenizer">
            <summary>
            Reads a stream of Well Known Text (wkt) string and returns a stream of tokens.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Utilities.GeoToolsStreamTokenizer">
            <summary>
            The StreamTokenizer class takes an input stream and parses it into "tokens", 
            allowing the tokens to be read one at a time. 
            The parsing process is controlled by a table and a number of flags that can be set to various states. 
            The stream tokenizer can recognize identifiers, numbers, quoted strings, and various comment style.
            </summary>
            <remarks>
            This is a crude c# implementation of Java's 
            <a href="http://java.sun.com/products/jdk/1.2/docs/api/java/io/StreamTokenizer.html">StreamTokenizer</a> class.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.GeoToolsStreamTokenizer.#ctor(System.IO.TextReader,System.Boolean)">
            <summary>
            Initializes a new instance of the StreamTokenizer class.
            </summary>
            <param name="reader">A TextReader with some text to read.</param>
            <param name="ignoreWhitespace">Flag indicating whether whitespace should be ignored.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.GeoToolsStreamTokenizer.GetNumericValue">
            <summary>
            If the current token is a number, this field contains the value of that number. 
            </summary>
            <remarks>
            If the current token is a number, this field contains the value of that number. The current token is a number when the value of the ttype field is TT_NUMBER.
            </remarks>
            <exception cref="T:System.FormatException">Current token is not a number in a valid format.</exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.GeoToolsStreamTokenizer.GetStringValue">
            <summary>
            If the current token is a word token, this field contains a string giving the characters of the word token. 
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.GeoToolsStreamTokenizer.GetTokenType">
            <summary>
            Gets the token type of the current token.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.GeoToolsStreamTokenizer.NextToken(System.Boolean)">
            <summary>
            Returns the next token.
            </summary>
            <param name="ignoreWhitespace">Determines is whitespace is ignored. True if whitespace is to be ignored.</param>
            <returns>The TokenType of the next token.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.GeoToolsStreamTokenizer.NextToken">
            <summary>
            Returns the next token.
            </summary>
            <returns>The TokenType of the next token.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.GeoToolsStreamTokenizer.NextTokenAny">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.GeoToolsStreamTokenizer.GetType(System.Char)">
            <summary>
            Determines a characters type (e.g. number, symbols, character).
            </summary>
            <param name="character">The character to determine.</param>
            <returns>The TokenType the character is.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.GeoToolsStreamTokenizer.NextNonWhitespaceToken">
            <summary>
            Returns next token that is not whitespace.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Utilities.GeoToolsStreamTokenizer.LineNumber">
            <summary>
            The current line number of the stream being read.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Utilities.GeoToolsStreamTokenizer.Column">
            <summary>
            The current column number of the stream being read.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WktStreamTokenizer.#ctor(System.IO.TextReader)">
            <summary>
            Initializes a new instance of the WktStreamTokenizer class.
            </summary>
            <remarks>The WktStreamTokenizer class ais in reading WKT streams.</remarks>
            <param name="reader">A TextReader that contains WKT.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WktStreamTokenizer.ReadToken(System.String)">
            <summary>
            Reads a token and checks it is what is expected.
            </summary>
            <param name="expectedToken">The expected token.</param>
            <exception cref="T:MapWinGeoProc.NTS.Topology.IO.ParseException">If the token is not what is expected.</exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WktStreamTokenizer.ReadDoubleQuotedWord">
            <summary>
            Reads a string inside double quotes.
            </summary>
            <remarks>
            White space inside quotes is preserved.
            </remarks>
            <returns>The string inside the double quotes.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WktStreamTokenizer.ReadAuthority(System.String@,System.String@)">
            <summary>
            Reads the authority and authority code.
            </summary>
            <param name="authority">String to place the authority in.</param>
            <param name="authorityCode">String to place the authority code in.</param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryTransformer">
            <summary>
            A framework for processes which transform an input <c>Geometry</c> into
            an output <c>Geometry</c>, possibly changing its structure and type(s).
            This class is a framework for implementing subclasses
            which perform transformations on
            various different Geometry subclasses.
            It provides an easy way of applying specific transformations
            to given point types, while allowing unhandled types to be simply copied.
            Also, the framework handles ensuring that if subcomponents change type
            the parent geometries types change appropriately to maintain valid structure.
            Subclasses will override whichever <c>TransformX</c> methods
            they need to to handle particular Geometry types.
            A typically usage would be a transformation that may transform Polygons into
            Polygons, LineStrings
            or Points.  This class would likely need to override the TransformMultiPolygon
            method to ensure that if input Polygons change type the result is a GeometryCollection,
            not a MultiPolygon.
            The default behaviour of this class is to simply recursively transform
            each Geometry component into an identical object by copying.
            Note that all <c>TransformX</c> methods may return <c>null</c>,
            to avoid creating empty point objects. This will be handled correctly
            by the transformer.
            The Transform method itself will always
            return a point object.
            </summary>    
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryTransformer.factory">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryTransformer.pruneEmptyGeometry">
            <summary>
            <c>true</c> if empty geometries should not be included in the result.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryTransformer.preserveGeometryCollectionType">
            <summary> 
            <c>true</c> if a homogenous collection result
            from a <c>GeometryCollection</c> should still
            be a general GeometryCollection.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryTransformer.preserveType">
            <summary> 
            <c>true</c> if the type of the input should be preserved.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryTransformer.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryTransformer.Transform(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="inputGeom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryTransformer.CreateCoordinateSequence(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[])">
            <summary> 
            Convenience method which provides standard way of
            creating a <c>CoordinateSequence</c>.
            </summary>
            <param name="coords">The coordinate array to copy.</param>
            <returns>A coordinate sequence for the array.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryTransformer.Copy(MapWindow.Interfaces.Geometries.ICoordinateSequence)">
            <summary> 
            Convenience method which provides statndard way of copying {CoordinateSequence}s
            </summary>
            <param name="seq">The sequence to copy.</param>
            <returns>A deep copy of the sequence.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryTransformer.TransformCoordinates(MapWindow.Interfaces.Geometries.ICoordinateSequence,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="coords"></param>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryTransformer.TransformPoint(MapWindow.Interfaces.Geometries.IPoint,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryTransformer.TransformMultiPoint(MapWindow.Interfaces.Geometries.IMultiPoint,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryTransformer.TransformLinearRing(MapWindow.Interfaces.Geometries.ILinearRing,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryTransformer.TransformLineString(MapWindow.Interfaces.Geometries.ILineString,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryTransformer.TransformMultiLineString(MapWindow.Interfaces.Geometries.IMultiLineString,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryTransformer.TransformPolygon(MapWindow.Interfaces.Geometries.IPolygon,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryTransformer.TransformMultiPolygon(MapWindow.Interfaces.Geometries.IMultiPolygon,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryTransformer.TransformGeometryCollection(MapWindow.Interfaces.Geometries.IGeometryCollection,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryTransformer.InputGeometry">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel">
            <summary> 
            Specifies the precision model of the <c>Coordinate</c>s in a <c>Geometry</c>.
            In other words, specifies the grid of allowable
            points for all <c>Geometry</c>s.
            The <c>makePrecise</c> method allows rounding a coordinate to
            a "precise" value; that is, one whose
            precision is known exactly.
            Coordinates are assumed to be precise in geometries.
            That is, the coordinates are assumed to be rounded to the
            precision model given for the point.
            NTS input routines automatically round coordinates to the precision model
            before creating Geometries.
            All internal operations
            assume that coordinates are rounded to the precision model.
            Constructive methods (such as bool operations) always round computed
            coordinates to the appropriate precision model.
            Currently three types of precision model are supported:
            <para>
            Floating: represents full double precision floating point.
            This is the default precision model used in NTS
            FloatingSingle: represents single precision floating point.
            Fixed: represents a model with a fixed number of decimal places.
            </para>
            A Fixed Precision Model is specified by a scale factor.
            The scale factor specifies the grid which numbers are rounded to.
            Input coordinates are mapped to fixed coordinates according to the following
            equations:
             jtsPt.x = round( (inputPt.x * scale ) / scale
             jtsPt.y = round( (inputPt.y * scale ) / scale
            Coordinates are represented internally as double-precision values.
            Since .NET uses the IEEE-394 floating point standard, this
            provides 53 bits of precision. (Thus the maximum precisely representable
            integer is 9,007,199,254,740,992).
            NTS methods currently do not handle inputs with different precision models.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.MaximumPreciseValue">
            <summary>  
            The maximum precise value representable in a double. Since IEE754
            double-precision numbers allow 53 bits of mantissa, the value is equal to
            2^53 - 1.  This provides <i>almost</i> 16 decimal digits of precision.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.modelType">
            <summary>
            The type of PrecisionModel this represents.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.scale">
            <summary> 
            The scale factor which determines the number of decimal places in fixed precision.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.#ctor">
            <summary> 
            Creates a <c>PrecisionModel</c> with a default precision
            of Floating.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.#ctor(MapWindow.Interfaces.Geometries.PrecisionModels)">
            <summary>
            Creates a <c>PrecisionModel</c> that specifies
            an explicit precision model type.
            If the model type is Fixed the scale factor will default to 1.
            </summary>
            <param name="modelType">
            The type of the precision model.
            </param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.#ctor(System.Double,System.Double,System.Double)">
            <summary>  
            Creates a <c>PrecisionModel</c> that specifies Fixed precision.
            Fixed-precision coordinates are represented as precise internal coordinates,
            which are rounded to the grid defined by the scale factor.        
            </summary>
            <param name="scale">
            Amount by which to multiply a coordinate after subtracting
            the offset, to obtain a precise coordinate
            </param>
            <param name="offsetX">Not used.</param>
            <param name="offsetY">Not used.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.#ctor(System.Double)">
            <summary>  
            Creates a <c>PrecisionModel</c> that specifies Fixed precision.
            Fixed-precision coordinates are represented as precise internal coordinates,
            which are rounded to the grid defined by the scale factor.
            </summary>
            <param name="scale">
            Amount by which to multiply a coordinate after subtracting
            the offset, to obtain a precise coordinate.
            </param>  
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.#ctor(MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel)">
            <summary> 
            Copy constructor to create a new <c>PrecisionModel</c>
            from an existing one.
            </summary>
            <param name="pm"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.GetHashCode">
            <summary>
            Return HashCode.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.GetPrecisionModelType">
            <summary> 
            Gets the type of this PrecisionModel.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.ToInternal(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>  
            Sets <c>internal</c> to the precise representation of <c>external</c>.
            </summary>
            <param name="cexternal">The original coordinate.</param>
            <param name="cinternal">
            The coordinate whose values will be changed to the
            precise representation of <c>external</c>.
            </param>        
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.ToInternal(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>  
            Returns the precise representation of <c>external</c>.
            </summary>
            <param name="cexternal">The original coordinate.</param>
            <returns>
            The coordinate whose values will be changed to the precise
            representation of <c>external</c>
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.ToExternal(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Returns the external representation of <c>internal</c>.
            </summary>
            <param name="cinternal">The original coordinate.</param>
            <returns>
            The coordinate whose values will be changed to the
            external representation of <c>internal</c>.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.ToExternal(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>  
            Sets <c>external</c> to the external representation of <c>internal</c>.
            </summary>
            <param name="cinternal">The original coordinate.</param>
            <param name="cexternal">
            The coordinate whose values will be changed to the
            external representation of <c>internal</c>.
            </param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.MakePrecise(System.Double)">
            <summary> 
            Rounds a numeric value to the PrecisionModel grid.
            Symmetric Arithmetic Rounding is used, to provide
            uniform rounding behaviour no matter where the number is
            on the number line.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.MakePrecise(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary> 
            Rounds a Coordinate to the PrecisionModel grid.
            </summary>
            <param name="coord"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.op_Equality(MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel,MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel)">
            <summary>
            
            </summary>
            <param name="obj1"></param>
            <param name="obj2"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.op_Inequality(MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel,MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel)">
            <summary>
            
            </summary>
            <param name="obj1"></param>
            <param name="obj2"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.CompareTo(System.Object)">
            <summary> 
            Compares this <c>PrecisionModel</c> object with the specified object for order.
            A PrecisionModel is greater than another if it provides greater precision.
            The comparison is based on the value returned by the
            {getMaximumSignificantDigits) method.
            This comparison is not strictly accurate when comparing floating precision models
            to fixed models; however, it is correct when both models are either floating or fixed.
            </summary>
            <param name="o">
            The <c>PrecisionModel</c> with which this <c>PrecisionModel</c>
            is being compared.
            </param>
            <returns>
            A negative integer, zero, or a positive integer as this <c>PrecisionModel</c>
            is less than, equal to, or greater than the specified <c>PrecisionModel</c>.
            </returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.IsFloating">
            <summary> 
            Tests whether the precision model supports floating point.
            </summary>
            <returns><c>true</c> if the precision model supports floating point.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.MaximumSignificantDigits">
            <summary>
            Returns the maximum number of significant digits provided by this
            precision model.
            Intended for use by routines which need to print out precise values.
            </summary>
            <returns>
            The maximum number of decimal places provided by this precision model.
            </returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.Scale">
            <summary>
            Returns the multiplying factor used to obtain a precise coordinate.
            This method is private because PrecisionModel is intended to
            be an immutable (value) type.
            </summary>
            <returns>    
            the amount by which to multiply a coordinate after subtracting
            the offset.
            </returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.OffsetX">
            <summary> 
            Returns the x-offset used to obtain a precise coordinate.
            </summary>
            <returns>
            The amount by which to subtract the x-coordinate before
            multiplying by the scale.
            </returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel.OffsetY">
            <summary> 
            Returns the y-offset used to obtain a precise coordinate.
            </summary>
            <returns> 
            The amount by which to subtract the y-coordinate before
            multiplying by the scale
            </returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix">
            <summary>  
            A Dimensionally Extended Nine-Intersection Model (DE-9IM) matrix. This class
            can used to represent both computed DE-9IM's (like 212FF1FF2) as well as
            patterns for matching them (like T*T******). 
            Methods are provided to:
            Set and query the elements of the matrix in a convenient fashion
            convert to and from the standard string representation (specified in
            SFS Section 2.1.13.2).
            Test to see if a matrix matches a given pattern string.
            For a description of the DE-9IM, see the <see href="http://www.opengis.org/techno/specs.htm"/>OpenGIS Simple Features
            Specification for SQL.
            </summary>       
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.matrix">
            <summary>  
            Internal representation of this <c>IntersectionMatrix</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.#ctor">
            <summary>  
            Creates an <c>IntersectionMatrix</c> with <c>Null</c> location values.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.#ctor(System.String)">
            <summary>
            Creates an <c>IntersectionMatrix</c> with the given dimension
            symbols.
            </summary>
            <param name="elements">A string of nine dimension symbols in row major order.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.#ctor(MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix)">
            <summary> 
            Creates an <c>IntersectionMatrix</c> with the same elements as
            <c>other</c>.
            </summary>
            <param name="other">An <c>IntersectionMatrix</c> to copy.</param>         
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.Add(MapWindow.Interfaces.Geometries.IIntersectionMatrix)">
            <summary> 
            Adds one matrix to another.
            Addition is defined by taking the maximum dimension value of each position
            in the summand matrices.
            </summary>
            <param name="im">The matrix to add.</param>        
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.Matches(MapWindow.Interfaces.Geometries.Dimensions,System.Char)">
            <summary>  
            Returns true if the dimension value satisfies the dimension symbol.
            </summary>
            <param name="actualDimensionValue">
            A number that can be stored in the <c>IntersectionMatrix</c>
            . Possible values are <c>True, False, Dontcare, 0, 1, 2</c>.
            </param>
            <param name="requiredDimensionSymbol">
            A character used in the string
            representation of an <c>IntersectionMatrix</c>. Possible values
            are <c>T, F, * , 0, 1, 2</c>.
            </param>
            <returns>
            True if the dimension symbol encompasses
            the dimension value.        
            </returns>        
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.Matches(System.String,System.String)">
            <summary>
            Returns true if each of the actual dimension symbols satisfies the
            corresponding required dimension symbol.
            </summary>
            <param name="actualDimensionSymbols">
            Nine dimension symbols to validate.
            Possible values are <c>T, F, * , 0, 1, 2</c>.
            </param>
            <param name="requiredDimensionSymbols">
            Nine dimension symbols to validate
            against. Possible values are <c>T, F, * , 0, 1, 2</c>.
            </param>
            <returns>
            True if each of the required dimension
            symbols encompass the corresponding actual dimension symbol.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.Set(MapWindow.Interfaces.Geometries.Locations,MapWindow.Interfaces.Geometries.Locations,MapWindow.Interfaces.Geometries.Dimensions)">
            <summary>
            Changes the value of one of this <c>IntersectionMatrix</c>s
            elements.
            </summary>
            <param name="row">
            The row of this <c>IntersectionMatrix</c>,
            indicating the interior, boundary or exterior of the first <c>Geometry</c>
            </param>
            <param name="column">
            The column of this <c>IntersectionMatrix</c>,
            indicating the interior, boundary or exterior of the second <c>Geometry</c>
            </param>
            <param name="dimensionValue">
            The new value of the element
            </param>        
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.Set(System.String)">
            <summary>
            Changes the elements of this <c>IntersectionMatrix</c> to the
            dimension symbols in <c>dimensionSymbols</c>.
            </summary>
            <param name="dimensionSymbols">
            Nine dimension symbols to which to set this <c>IntersectionMatrix</c>
            s elements. Possible values are <c>{T, F, * , 0, 1, 2}</c>
            </param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.SetAtLeast(MapWindow.Interfaces.Geometries.Locations,MapWindow.Interfaces.Geometries.Locations,MapWindow.Interfaces.Geometries.Dimensions)">
            <summary>
            Changes the specified element to <c>minimumDimensionValue</c> if the
            element is less.
            </summary>
            <param name="row">
            The row of this <c>IntersectionMatrix</c>
            , indicating the interior, boundary or exterior of the first <c>Geometry</c>.
            </param>
            <param name="column">
            The column of this <c>IntersectionMatrix</c>
            , indicating the interior, boundary or exterior of the second <c>Geometry</c>.
            </param>
            <param name="minimumDimensionValue">
            The dimension value with which to compare the
            element. The order of dimension values from least to greatest is
            <c>True, False, Dontcare, 0, 1, 2</c>.
            </param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.SetAtLeastIfValid(MapWindow.Interfaces.Geometries.Locations,MapWindow.Interfaces.Geometries.Locations,MapWindow.Interfaces.Geometries.Dimensions)">
            <summary>
            If row >= 0 and column >= 0, changes the specified element to <c>minimumDimensionValue</c>
            if the element is less. Does nothing if row is smaller to 0 or column is smaller to 0.
            </summary>
            <param name="row"></param>
            <param name="column"></param>
            <param name="minimumDimensionValue"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.SetAtLeast(System.String)">
            <summary>
            For each element in this <c>IntersectionMatrix</c>, changes the
            element to the corresponding minimum dimension symbol if the element is
            less.
            </summary>
            <param name="minimumDimensionSymbols"> 
            Nine dimension symbols with which to
            compare the elements of this <c>IntersectionMatrix</c>. The
            order of dimension values from least to greatest is <c>Dontcare, True, False, 0, 1, 2</c>.
            </param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.SetAll(MapWindow.Interfaces.Geometries.Dimensions)">
            <summary>  
            Changes the elements of this <c>IntersectionMatrix</c> to <c>dimensionValue</c>.
            </summary>
            <param name="dimensionValue">
            The dimension value to which to set this <c>IntersectionMatrix</c>
            s elements. Possible values <c>True, False, Dontcare, 0, 1, 2}</c>.
            </param>         
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.Get(MapWindow.Interfaces.Geometries.Locations,MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            Returns the value of one of this <c>IntersectionMatrix</c>s
            elements.
            </summary>
            <param name="row">
            The row of this <c>IntersectionMatrix</c>, indicating
            the interior, boundary or exterior of the first <c>Geometry</c>.
            </param>
            <param name="column">
            The column of this <c>IntersectionMatrix</c>,
            indicating the interior, boundary or exterior of the second <c>Geometry</c>.
            </param>
            <returns>The dimension value at the given matrix position.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.IsDisjoint">
            <summary>
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is
            FF*FF****.
            </summary>
            <returns>
            <c>true</c> if the two <c>Geometry</c>s related by
            this <c>IntersectionMatrix</c> are disjoint.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.IsIntersects">
            <summary>
            Returns <c>true</c> if <c>isDisjoint</c> returns false.
            </summary>
            <returns>
            <c>true</c> if the two <c>Geometry</c>s related by
            this <c>IntersectionMatrix</c> intersect.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.IsTouches(MapWindow.Interfaces.Geometries.Dimensions,MapWindow.Interfaces.Geometries.Dimensions)">
            <summary>
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is
            FT*******, F**T***** or F***T****.
            </summary>
            <param name="dimensionOfGeometryA">The dimension of the first <c>Geometry</c>.</param>
            <param name="dimensionOfGeometryB">The dimension of the second <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>
            s related by this <c>IntersectionMatrix</c> touch; Returns false
            if both <c>Geometry</c>s are points.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.IsCrosses(MapWindow.Interfaces.Geometries.Dimensions,MapWindow.Interfaces.Geometries.Dimensions)">
            <summary>
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is
             T*T****** (for a point and a curve, a point and an area or a line
            and an area) 0******** (for two curves).
            </summary>
            <param name="dimensionOfGeometryA">The dimension of the first <c>Geometry</c>.</param>
            <param name="dimensionOfGeometryB">The dimension of the second <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>
            s related by this <c>IntersectionMatrix</c> cross. For this
            function to return <c>true</c>, the <c>Geometry</c>s must
            be a point and a curve; a point and a surface; two curves; or a curve
            and a surface.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.IsWithin">
            <summary>  
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is
            T*F**F***.
            </summary>
            <returns><c>true</c> if the first <c>Geometry</c> is within the second.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.IsContains">
            <summary> 
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is
            T*****FF*.
            </summary>
            <returns><c>true</c> if the first <c>Geometry</c> contains the second.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.IsCovers">
            <summary>
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is <c>T*****FF*</c>
            or <c>*T****FF*</c> or <c>***T**FF*</c> or <c>****T*FF*</c>.
            </summary>
            <returns><c>true</c> if the first <c>Geometry</c> covers the second</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.IsEquals(MapWindow.Interfaces.Geometries.Dimensions,MapWindow.Interfaces.Geometries.Dimensions)">
            <summary> 
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is T*F**FFF*.
            </summary>
            <param name="dimensionOfGeometryA">The dimension of the first <c>Geometry</c>.</param>
            <param name="dimensionOfGeometryB">The dimension of the second <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>
            s related by this <c>IntersectionMatrix</c> are equal; the
            <c>Geometry</c>s must have the same dimension for this function
            to return <c>true</c>.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.IsOverlaps(MapWindow.Interfaces.Geometries.Dimensions,MapWindow.Interfaces.Geometries.Dimensions)">
            <summary>
            Returns <c>true</c> if this <c>IntersectionMatrix</c> is
             T*T***T** (for two points or two surfaces)
             1*T***T** (for two curves).
            </summary>
            <param name="dimensionOfGeometryA">The dimension of the first <c>Geometry</c>.</param>
            <param name="dimensionOfGeometryB">The dimension of the second <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>
            s related by this <c>IntersectionMatrix</c> overlap. For this
            function to return <c>true</c>, the <c>Geometry</c>s must
            be two points, two curves or two surfaces.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.Matches(System.String)">
            <summary> 
            Returns whether the elements of this <c>IntersectionMatrix</c>
            satisfies the required dimension symbols.
            </summary>
            <param name="requiredDimensionSymbols"> 
            Nine dimension symbols with which to
            compare the elements of this <c>IntersectionMatrix</c>. Possible
            values are <c>{T, F, * , 0, 1, 2}</c>.
            </param>
            <returns>
            <c>true</c> if this <c>IntersectionMatrix</c>
            matches the required dimension symbols.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.Transpose">
            <summary>  
            Transposes this IntersectionMatrix.
            </summary>
            <returns>This <c>IntersectionMatrix</c> as a convenience,</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.ToString">
            <summary>
            Returns a nine-character <c>String</c> representation of this <c>IntersectionMatrix</c>.
            </summary>
            <returns>
            The nine dimension symbols of this <c>IntersectionMatrix</c>
            in row-major order.
            </returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix.Item(MapWindow.Interfaces.Geometries.Locations,MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            See methods Get(int, int) and Set(int, int, int value)
            </summary>         
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.TransformType">
            <summary>
            Semantic type of transform used in coordinate transformation.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.TransformType.Other">
            <summary>
            Unknown or unspecified type of transform.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.TransformType.Conversion">
            <summary>
            Transform depends only on defined parameters. For example, a cartographic projection.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.TransformType.Transformation">
            <summary>
            Transform depends only on empirically derived parameters. For example a datum transformation.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.TransformType.ConversionAndTransformation">
            <summary>
            Transform depends on both defined and empirical parameters.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.ICoordinateTransformationFactory">
            <summary>
            Creates coordinate transformations.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.ICoordinateTransformationFactory.CreateFromCoordinateSystems(MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystem,MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystem)">
            <summary>
            Creates a transformation between two coordinate systems.
            </summary>
            <remarks>
            This method will examine the coordinate systems in order to construct
            a transformation between them. This method may fail if no path between 
            the coordinate systems is found, using the normal failing behavior of 
            the DCP (e.g. throwing an exception).</remarks>
            <param name="sourceCS">Source coordinate system</param>
            <param name="targetCS">Target coordinate system</param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IPrimeMeridian">
            <summary>
            The IPrimeMeridian interface defines the standard information stored with prime
            meridian objects. Any prime meridian object must implement this interface as
            well as the ISpatialReferenceInfo interface.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IPrimeMeridian.Longitude">
            <summary>
            Gets or sets the longitude of the prime meridian (relative to the Greenwich prime meridian).
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IPrimeMeridian.AngularUnit">
            <summary>
            Gets or sets the AngularUnits.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.NotRepresentableException">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.NotRepresentableException.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.MinimumDiameter">
            <summary>
            Computes the minimum diameter of a <c>Geometry</c>.
            The minimum diameter is defined to be the
            width of the smallest band that contains the point,
            where a band is a strip of the plane defined
            by two parallel lines.
            This can be thought of as the smallest hole that the point can be
            moved through, with a single rotation.
            The first step in the algorithm is computing the convex hull of the Geometry.
            If the input Geometry is known to be convex, a hint can be supplied to
            avoid this computation.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.MinimumDiameter.#ctor(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary> 
            Compute a minimum diameter for a giver <c>Geometry</c>.
            </summary>
            <param name="inputGeom">a Geometry.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.MinimumDiameter.#ctor(MapWindow.Interfaces.Geometries.IGeometry,System.Boolean)">
            <summary> 
            Compute a minimum diameter for a giver <c>Geometry</c>,
            with a hint if
            the Geometry is convex
            (e.g. a convex Polygon or LinearRing,
            or a two-point LineString, or a Point).
            </summary>
            <param name="inputGeom">a Geometry which is convex.</param>
            <param name="isConvex"><c>true</c> if the input point is convex.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.MinimumDiameter.ComputeMinimumDiameter">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.MinimumDiameter.ComputeWidthConvex(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.MinimumDiameter.ComputeConvexRingMinDiameter(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary> 
            Compute the width information for a ring of <c>Coordinate</c>s.
            Leaves the width information in the instance variables.
            </summary>
            <param name="pts"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.MinimumDiameter.FindMaxPerpDistance(MapWindow.Interfaces.Geometries.ICoordinate[],MapWinGeoProc.NTS.Topology.Geometries.LineSegment,System.Int32)">
            <summary>
            
            </summary>
            <param name="pts"></param>
            <param name="seg"></param>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.MinimumDiameter.NextIndex(MapWindow.Interfaces.Geometries.ICoordinate[],System.Int32)">
            <summary>
            
            </summary>
            <param name="pts"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Algorithm.MinimumDiameter.Length">
            <summary> 
            Gets the length of the minimum diameter of the input Geometry.
            </summary>
            <returns>The length of the minimum diameter.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Algorithm.MinimumDiameter.WidthCoordinate">
            <summary>
            Gets the <c>Coordinate</c> forming one end of the minimum diameter.
            </summary>
            <returns>A coordinate forming one end of the minimum diameter.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Algorithm.MinimumDiameter.SupportingSegment">
            <summary>
            Gets the segment forming the base of the minimum diameter.
            </summary>
            <returns>The segment forming the base of the minimum diameter.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Algorithm.MinimumDiameter.Diameter">
            <summary>
            Gets a <c>LineString</c> which is a minimum diameter.
            </summary>
            <returns>A <c>LineString</c> which is a minimum diameter.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.CentroidPoint">
            <summary> 
            Computes the centroid of a point point.
            Algorithm:
            Compute the average of all points.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CentroidPoint.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CentroidPoint.Add(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary> 
            Adds the point(s) defined by a Geometry to the centroid total.
            If the point is not of dimension 0 it does not contribute to the centroid.
            </summary>
            <param name="geom">The point to add.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CentroidPoint.Add(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary> 
            Adds the length defined by a coordinate.
            </summary>
            <param name="pt">A coordinate.</param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Algorithm.CentroidPoint.Centroid">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.ProgressDialog">
            <summary>
            A class allowing progress messages to be displayed while long algorithms are taking place.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.ProgressDialog.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.ProgressDialog.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.ProgressDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.ProgressDialog.#ctor">
            <summary>
            Initializer for a Progress Dialog
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.ProgressDialog.init(System.String,System.String,MapWinGeoProc.Pitfill.Framework)">
            <summary>
            Sets values to be displayed for this object.
            </summary>
            <param name="Source">A String specifying the source file</param>
            <param name="Dest">A String specifying the destination file</param>
            <param name="Target">The Framework that has the status information</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.ProgressDialog.WriteMessage(System.String)">
            <summary>
            Writes a message to this dialog, and echos the message to the CallBack interface if one is specified.
            </summary>
            <param name="Message">A String message to be written to the dialog or callback</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.ProgressDialog.ReDraw">
            <summary>
            If we are showing this dialog, redraw the graphical progress display
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.ProgressDialog.DoEvents">
            <summary>
            Causes the progress dialog to allow itself to be redrawn
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ProgressDialog.ICallBack">
            <summary>
            A MapWinGIS.ICallback for messags etc.  Messages will be forwarded to this ICallBack.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ProgressDialog.CallBack">
            <summary>
            This is an optional callback object to report progress to.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ProgressDialog.Progress">
            <summary>
            Shows the progress of the dialog
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ProgressDialog.IsCanceled">
            <summary>
            Tests whether the cancel button has been pressed or not.
            </summary>
            <returns>True if the cancel button has been pressed.</returns>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.ProgressDialog.IsPaused">
            <summary>
            Boolean.  Returns true if the program should pause, and false otherwise.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.HelpPannelEventArgs">
            <summary>
            Contain a package of information for changing the help pannel to reflect
            information appropriate for the element responding to a help button click.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.HelpPannelEventArgs.#ctor(System.String,System.String,System.Drawing.Image)">
            <summary>
            Creates a new instance of the HelpPannelEventArgs class
            </summary>
            <param name="HelpTitle">A New help title for the pannel</param>
            <param name="HelpText">A paragraph of explaining text</param>
            <param name="HelpImage">An image for the pannel</param>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.HelpPannelEventArgs.Title">
            <summary>
            The string caption associated with the element
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.HelpPannelEventArgs.Text">
            <summary>
            The string text giving help for the element.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.HelpPannelEventArgs.Image">
            <summary>
            The System.Drawing.Image providing a picture for the help panel.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.ClipPolyWithLine">
            <summary>
            Functions for clipping a polygon with a line.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.ClipPolyWithLine.Fast_ClipPolygonWithLine(MapWinGIS.Shape@,MapWinGIS.Shape@,MapWinGIS.Shapefile@)">
            <summary>
            For faster clipping of polygons with lines. Limits the finding of intersections to
            outside->inside or inside->outside 2pt segments. Assumes only one intersections exists
            per segment, that a segment of two inside points or two outside points will not intersect
            the polygon.
            </summary>
            <param name="polygon">The polygon that will be sectioned by the line.</param>
            <param name="line">The line that will clip the polygon into multiple parts.</param>
            <param name="resultSF">The in-memory shapefile where the polygon sections will be saved.</param>
            <returns>False if errors are encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.ClipPolyWithLine.Fast_ClipPolygonWithLine(MapWinGIS.Shape@,MapWinGIS.Shape@,System.String@)">
            <summary>
            For faster clipping of polygons with lines. Limits the finding of intersections to
            outside->inside or inside->outside 2pt segments. Assumes only one intersections exists
            per segment, that a segment of two inside points or two outside points will not intersect
            the polygon.
            </summary>
            <param name="polygon">The polygon that will be sectioned by the line.</param>
            <param name="line">The line that will clip the polygon into multiple parts.</param>
            <param name="resultSFPath">The path to the file where the polygon sections will be saved.</param>
            <returns>False if errors are encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.ClipPolyWithLine.Fast_ProcessPartInAndOut(System.Boolean[]@,MapWinGIS.Shape@,MapWinGIS.Shape@,MapWinGIS.Shapefile@)">
            <summary>
            Given a line that contains portion both inside and outside of the polygon, this
            function will split the polygon based only on the segments that completely bisect
            the polygon. It assumes: out->out, and in->in 2pt segments do not intersect the
            polygon, and out->in, in->out 2pt segments have only one point of intersection.
            </summary>
            <param name="insidePts">A boolean array indicating if a point is inside the polygon or not.</param>
            <param name="line">The line that intersects the polygon.</param>
            <param name="polygon">The polygon that will be split by the intersecting line.</param>
            <param name="resultSF">The shapefile that the polygon sections will be saved to.</param>
            <returns>False if errors were encountered or an assumption violated, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.ClipPolyWithLine.ProcessPartInAndOut(System.Boolean[]@,MapWinGIS.Shape@,MapWinGIS.Shape@,MapWinGIS.Shapefile@)">
            <summary>
            Given a line that contains portions both inside and outside of the polygon, this
            function will split the polygon based only on the segments that completely bisect
            the polygon. The possibility of mutliple intersections for any 2pt segment is taken
            into account.
            </summary>
            <param name="insidePts">A boolean array indicating if a point is inside the polygon or not.</param>
            <param name="line">The line that intersects the polygon.</param>
            <param name="polygon">The polygon that will be split by the intersecting line.</param>
            <param name="resultSF">The shapefile that the polygon sections will be saved to.</param>
            <returns>False if errors were encountered or an assumption violated, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.ClipPolyWithLine.ProcessAllOutside(MapWinGIS.Shape@,MapWinGIS.Shape@,MapWinGIS.Shapefile@)">
            <summary>
            For lines where every point lies outside the polygon, this function will
            find if any 2pt segment crosses through the polygon. If so, it will split
            the polygon into mutliple parts using the intersecting line segments.
            </summary>
            <param name="line">The line whose points are all inside the polygon.</param>
            <param name="polygon">The polygon being checked for intersection.</param>
            <param name="resultSF">The file where new polygon sections should be saved to.</param>
            <returns>False if errors were encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.ClipPolyWithLine.ProcessAllInside(MapWinGIS.Shape@,MapWinGIS.Shape@,MapWinGIS.Shapefile@)">
            <summary>
            For lines where every point lies within the polygon, this function will
            find if any 2pt segment crosses through the polygon. If so, it will split
            the polygon into mutliple parts using the intersecting line segments.
            </summary>
            <param name="line">The line whose points are all inside the polygon.</param>
            <param name="polygon">The polygon being checked for intersection.</param>
            <param name="resultSF">The file where new polygon sections should be saved to.</param>
            <returns>False if errors were encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.ClipPolyWithLine.SectionPolygonWithLine(MapWinGIS.Shape@,MapWinGIS.Shape@,System.Int32,System.Int32,MapWinGIS.Shapefile@)">
            <summary>
            Sections a polygon into multiple parts depending on where line crosses it and if previous sectioning has occured.
            </summary>
            <param name="line">The line that splits the polygon. First and last points are intersect points.</param>
            <param name="polygon">The polygon that is to be split by the line.</param>
            <param name="polyStart">Index to polygon segment where the first intersect point is found.</param>
            <param name="polyEnd">Index to polygon segment where last intersect point is found.</param>
            <param name="resultSF">Reference to result shapefile where new polygon sections will be saved.</param>
            <returns>False if an error occurs, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.ClipPolyWithLine.SplitPolyInTwo(MapWinGIS.Shape@,MapWinGIS.Shape@,System.Int32,System.Int32,MapWinGIS.Shape@,MapWinGIS.Shape@)">
            <summary>
            Splits original polygon into two portions depending on where line crosses it.
            </summary>
            <param name="line">The line the crosses the polygon. First and last points are intersects.</param>
            <param name="polygon">The polygon that is split by the line.</param>
            <param name="beginPolySeg">The section of the polygon where the first intersect point is found.</param>
            <param name="endPolySeg">The section of the polygon where the last intersect point is found.</param>
            <param name="poly1">First portion of polygon returned after splitting.</param>
            <param name="poly2">Second portion of polygon returned after splitting.</param>
        </member>
        <member name="T:MapWinGeoProc.Pitfill.Algorithm">
            <summary>
            A class for storing the meat of the PitFill algorithm
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Pitfill.Algorithm.FloodDependencies(MapWinGIS.Grid,MapWinGIS.Grid,System.Collections.Generic.List{MapWinGeoProc.Pitfill.Frame.Loc},MapWinGeoProc.Pitfill.Frame,System.Boolean[],MapWinGeoProc.Dialogs.ProgressDialog)">
            <summary>
            This is the core algorithm to fill the depressions in an image
            This concept is masterminded by the self proclaimed genius Ted Dunsford
            and is being prepared for publication.
            </summary>
            <param name="mwSourceGrid">The MapWinGIS.Grid to read the actual elevation values from</param>
            <param name="mwDestGrid">The MapWinGIS.Grid to write the elevations to</param>
            <param name="SpawnPoints">A list of points on the edges where the algorithm will start </param>
            <param name="myFrame">The current sub-division of the overall grid</param>
            <param name="DepsExist">A list of booleans for each direction indicating if dependencies were found in neighboring frames</param>
            <param name="myProgress">A Dialogs.ProgressDialog indicating the current progress of the algorithm.</param>
            <returns>TimeSpan indicating the time the function took to run the algorithm</returns>
        </member>
        <member name="T:MapWinGeoProc.Pitfill.Algorithm.mPoint">
            <summary>
            Public structure for storing a row, column and Z value
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Pitfill.Algorithm.mPoint.Row">
            <summary>
            The Y coordinate or Row value
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Pitfill.Algorithm.mPoint.Col">
            <summary>
            The X coordinate or Column value
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Pitfill.Algorithm.mPoint.Z">
            <summary>
            The Z coordinate or elevation value
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Pitfill.Algorithm.mPoint.#ctor(System.Int32,System.Int32,System.Single)">
            <summary>
            Creates a new instance of the mPoint structure
            </summary>
            <param name="NewRow">The Row or Y coordinate</param>
            <param name="NewCol">The Column or X coordinate</param>
            <param name="NewZ">The Z or elevation value</param>
        </member>
        <member name="T:MapWinGeoProc.Topology2D.MultiLineString">
            <summary>
            This is a collection of line-strings, similar to a multipart polyline.
            In reality, this just exposes a convenient list of linestrings with some
            simple methods.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Topology2D.GeometryCollection">
            <summary>
            An abstract class for groups of simpler geometric shapes
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.GeometryCollection.GeometryN">
            <summary>
            A list of geometries stored in this geometry collection
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.GeometryCollection.NumGeometries">
            <summary>
            Returns the number of geometries in the collection
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.MultiLineString.#ctor">
            <summary>
            Creates a new empty instance of a geometry collection specifically for linestrings
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.MultiLineString.#ctor(System.Object)">
            <summary>
            Creates a MultiLineString instance using a Late-bound MapWinGIS.Shape object
            </summary>
            <param name="MapWinGIS_Shape">A MapWinGIS.Shape to turn into a multi-line string</param>
        </member>
        <member name="T:RTools.Util.Finder">
            <summary>
            This class provides some static methods which are useful
            for file system "find" types of operations, similar to the *nix find
            command.
            </summary>
        </member>
        <member name="M:RTools.Util.Finder.ChangeBackSlashes(System.String)">
            <summary>
            Switch from backslashes to forward slashes.
            Zip file format specifies only forward slashes.
            </summary>
            <param name="s">The input string.</param>
            <returns>string - with backslashes replaced by forward.</returns>
        </member>
        <member name="M:RTools.Util.Finder.FindFiles(System.String,System.Collections.ArrayList,System.Collections.SortedList@,System.Boolean)">
            <summary>
            Find files under a specified directory and matching any of
            a set of regular expressions. Return them by putting
            (string -> null) entries into the input SortedList.
            The regular expressions are Command Prompt dir command 
            type (like *.cs), not normal regular expressions.
            This optionally puts the directory name itself into the list.
            </summary>
            <remarks>This uses SortedList to get the insertion sort.</remarks>
            <param name="dirName">The directory to find files under. "." works.</param>
            <param name="regexps">List of directory regexp strings, for example *.cs
            and *.bat</param>
            <param name="list">The SortedList to fill.</param>
            <param name="addDirItself">Whether to add the dir name into the list.</param>
            <returns>bool - true for success, false for failure</returns>
        </member>
        <member name="M:RTools.Util.Finder.FindFiles(System.String,System.String,System.Collections.SortedList@,System.Boolean)">
            <summary>
            Overload with single regular expression.
            </summary>
        </member>
        <member name="M:RTools.Util.Finder.AddParents(System.Collections.SortedList)">
            <summary>
            For each entry in the input SortedList (where the keys in the
            list entries are strings, the file paths) add all parent 
            directories into the list.  So given a list with an entry
            with key "a/b/c", put "a/b" and "a" in the list.
            </summary>
            <remarks>The new entries are string dir name with value null.
            </remarks>
            <param name="list">The SortedList of DictionaryEntry's, with
            string file path keys.</param>
            <returns>true</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Simplify.TaggedLinesSimplifier">
            <summary>
            Simplifies a collection of TaggedLineStrings, preserving topology
            (in the sense that no new intersections are introduced).
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLinesSimplifier.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLinesSimplifier.Simplify(System.Collections.IList)">
            <summary>
            Simplify a collection of <c>TaggedLineString</c>s.
            </summary>
            <param name="taggedLines">The collection of lines to simplify.</param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Simplify.TaggedLinesSimplifier.DistanceTolerance">
            <summary>
            Gets/Sets the distance tolerance for the simplification.
            Points closer than this tolerance to a simplified segment may
            be removed.
            </summary>        
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Simplify.DouglasPeuckerSimplifier">
            <summary>
            Simplifies a <c>Geometry</c> using the standard Douglas-Peucker algorithm.
            Ensures that any polygonal geometries returned are valid.
            Simple lines are not guaranteed to remain simple after simplification.
            Note that in general D-P does not preserve topology -
            e.g. polygons can be split, collapse to lines or disappear
            holes can be created or disappear,
            and lines can cross.
            To simplify point while preserving topology use TopologySafeSimplifier.
            (However, using D-P is significantly faster).
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.DouglasPeuckerSimplifier.Simplify(MapWinGeoProc.NTS.Topology.Geometries.Geometry,System.Double)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <param name="distanceTolerance"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.DouglasPeuckerSimplifier.#ctor(MapWinGeoProc.NTS.Topology.Geometries.Geometry)">
            <summary>
            
            </summary>
            <param name="inputGeom"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.DouglasPeuckerSimplifier.GetResultGeometry">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Simplify.DouglasPeuckerSimplifier.DistanceTolerance">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Simplify.DouglasPeuckerSimplifier.DPTransformer">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.DouglasPeuckerSimplifier.DPTransformer.#ctor(MapWinGeoProc.NTS.Topology.Simplify.DouglasPeuckerSimplifier)">
            <summary>
            
            </summary>
            <param name="container"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.DouglasPeuckerSimplifier.DPTransformer.TransformCoordinates(MapWindow.Interfaces.Geometries.ICoordinateSequence,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="coords"></param>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.DouglasPeuckerSimplifier.DPTransformer.TransformPolygon(MapWindow.Interfaces.Geometries.IPolygon,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.DouglasPeuckerSimplifier.DPTransformer.TransformMultiPolygon(MapWindow.Interfaces.Geometries.IMultiPolygon,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.DouglasPeuckerSimplifier.DPTransformer.CreateValidArea(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Creates a valid area point from one that possibly has
            bad topology (i.e. self-intersections).
            Since buffer can handle invalid topology, but always returns
            valid point, constructing a 0-width buffer "corrects" the
            topology.
            Note this only works for area geometries, since buffer always returns
            areas.  This also may return empty geometries, if the input
            has no actual area.
            </summary>
            <param name="roughAreaGeom">An area point possibly containing self-intersections.</param>
            <returns>A valid area point.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Predicate.RectangleContains">
            <summary>
            Optimized implementation of spatial predicate "contains"
            for cases where the first <c>Geometry</c> is a rectangle.    
            As a further optimization,
            this class can be used directly to test many geometries against a single rectangle.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.RectangleContains.Contains(MapWinGeoProc.NTS.Topology.Geometries.Polygon,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="rectangle"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.RectangleContains.#ctor(MapWinGeoProc.NTS.Topology.Geometries.Polygon)">
            <summary>
            Create a new contains computer for two geometries.
            </summary>
            <param name="rectangle">A rectangular geometry.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.RectangleContains.Contains(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.RectangleContains.IsContainedInBoundary(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.RectangleContains.IsPointContainedInBoundary(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Given any valid implementation of ICoordinate, which
            will basically provide an X, Y or Z values, this will determine
            if the rectangle contains the point.
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.RectangleContains.IsLineStringContainedInBoundary(MapWinGeoProc.NTS.Topology.Geometries.LineString)">
            <summary>
            
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.RectangleContains.IsLineSegmentContainedInBoundary(MapWinGeoProc.NTS.Topology.Geometries.Coordinate,MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Overlay.PolygonBuilder">
            <summary>
            Forms <c>Polygon</c>s out of a graph of {DirectedEdge}s.
            The edges to use are marked as being in the result Area.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.PolygonBuilder.#ctor(MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            
            </summary>
            <param name="geometryFactory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.PolygonBuilder.Add(MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph)">
            <summary>
            Add a complete graph.
            The graph is assumed to contain one or more polygons,
            possibly with holes.
            </summary>
            <param name="graph"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.PolygonBuilder.Add(System.Collections.IList,System.Collections.IList)">
            <summary> 
            Add a set of edges and nodes, which form a graph.
            The graph is assumed to contain one or more polygons,
            possibly with holes.
            </summary>
            <param name="dirEdges"></param>
            <param name="nodes"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.PolygonBuilder.BuildMaximalEdgeRings(System.Collections.IList)">
            <summary> 
            For all DirectedEdges in result, form them into MaximalEdgeRings.
            </summary>
            <param name="dirEdges"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.PolygonBuilder.BuildMinimalEdgeRings(System.Collections.IList,System.Collections.IList,System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="maxEdgeRings"></param>
            <param name="shellList"></param>
            <param name="freeHoleList"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.PolygonBuilder.FindShell(System.Collections.IList)">
            <summary>
            This method takes a list of MinimalEdgeRings derived from a MaximalEdgeRing,
            and tests whether they form a Polygon.  This is the case if there is a single shell
            in the list.  In this case the shell is returned.
            The other possibility is that they are a series of connected holes, in which case
            no shell is returned.
            </summary>
            <returns>The shell EdgeRing, if there is one.</returns>
            <returns><c>null</c>, if all the rings are holes.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.PolygonBuilder.PlacePolygonHoles(MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing,System.Collections.IList)">
            <summary>
            This method assigns the holes for a Polygon (formed from a list of
            MinimalEdgeRings) to its shell.
            Determining the holes for a MinimalEdgeRing polygon serves two purposes:
            it is faster than using a point-in-polygon check later on.
            it ensures correctness, since if the PIP test was used the point
            chosen might lie on the shell, which might return an incorrect result from the
            PIP test.
            </summary>
            <param name="shell"></param>
            <param name="minEdgeRings"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.PolygonBuilder.SortShellsAndHoles(System.Collections.IList,System.Collections.IList,System.Collections.IList)">
            <summary> 
            For all rings in the input list,
            determine whether the ring is a shell or a hole
            and add it to the appropriate list.
            Due to the way the DirectedEdges were linked,
            a ring is a shell if it is oriented CW, a hole otherwise.
            </summary>
            <param name="edgeRings"></param>
            <param name="shellList"></param>
            <param name="freeHoleList"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.PolygonBuilder.PlaceFreeHoles(System.Collections.IList,System.Collections.IList)">
            <summary>
            This method determines finds a containing shell for all holes
            which have not yet been assigned to a shell.
            These "free" holes should
            all be properly contained in their parent shells, so it is safe to use the
            <c>findEdgeRingContaining</c> method.
            (This is the case because any holes which are NOT
            properly contained (i.e. are connected to their
            parent shell) would have formed part of a MaximalEdgeRing
            and been handled in a previous step).
            </summary>
            <param name="shellList"></param>
            <param name="freeHoleList"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.PolygonBuilder.FindEdgeRingContaining(MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing,System.Collections.IList)">
            <summary> 
            Find the innermost enclosing shell EdgeRing containing the argument EdgeRing, if any.
            The innermost enclosing ring is the <i>smallest</i> enclosing ring.
            The algorithm used depends on the fact that:
            ring A contains ring B iff envelope(ring A) contains envelope(ring B).
            This routine is only safe to use if the chosen point of the hole
            is known to be properly contained in a shell
            (which is guaranteed to be the case if the hole does not touch its shell).
            </summary>
            <param name="testEr"></param>
            <param name="shellList"></param>
            <returns>Containing EdgeRing, if there is one, OR
            null if no containing EdgeRing is found.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.PolygonBuilder.ComputePolygons(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="shellList"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.PolygonBuilder.ContainsPoint(MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary> 
            Checks the current set of shells (with their associated holes) to
            see if any of them contain the point.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Overlay.PolygonBuilder.Polygons">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Buffer.SubgraphDepthLocater">
            <summary>
            Locates a subgraph inside a set of subgraphs,
            in order to determine the outside depth of the subgraph.
            The input subgraphs are assumed to have had depths
            already calculated for their edges.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.SubgraphDepthLocater.#ctor(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="subgraphs"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.SubgraphDepthLocater.GetDepth(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.SubgraphDepthLocater.FindStabbedSegments(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Finds all non-horizontal segments intersecting the stabbing line.
            The stabbing line is the ray to the right of stabbingRayLeftPt.
            </summary>
            <param name="stabbingRayLeftPt">The left-hand origin of the stabbing line.</param>
            <returns>A List of {DepthSegments} intersecting the stabbing line.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.SubgraphDepthLocater.FindStabbedSegments(MapWindow.Interfaces.Geometries.ICoordinate,System.Collections.IList,System.Collections.IList)">
            <summary>
            Finds all non-horizontal segments intersecting the stabbing line
            in the list of dirEdges.
            The stabbing line is the ray to the right of stabbingRayLeftPt.
            </summary>
            <param name="stabbingRayLeftPt">The left-hand origin of the stabbing line.</param>
            <param name="dirEdges"></param>
            <param name="stabbedSegments">The current list of DepthSegments intersecting the stabbing line.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.SubgraphDepthLocater.FindStabbedSegments(MapWindow.Interfaces.Geometries.ICoordinate,MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge,System.Collections.IList)">
            <summary>
            Finds all non-horizontal segments intersecting the stabbing line
            in the input dirEdge.
            The stabbing line is the ray to the right of stabbingRayLeftPt.
            </summary>
            <param name="stabbingRayLeftPt">The left-hand origin of the stabbing line.</param>
            <param name="dirEdge"></param>
            <param name="stabbedSegments">The current list of DepthSegments intersecting the stabbing line.</param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Buffer.SubgraphDepthLocater.DepthSegment">
            <summary>
            A segment from a directed edge which has been assigned a depth value
            for its sides.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.SubgraphDepthLocater.DepthSegment.#ctor(MapWinGeoProc.NTS.Topology.Geometries.LineSegment,System.Int32)">
            <summary>
            
            </summary>
            <param name="seg"></param>
            <param name="depth"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.SubgraphDepthLocater.DepthSegment.CompareTo(System.Object)">
            <summary>
            Defines a comparision operation on DepthSegments
            which orders them left to right:
            DS1 smaller DS2   if   DS1.seg is left of DS2.seg.
            DS1 bigger  DS2   if   DS1.seg is right of DS2.seg.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.SubgraphDepthLocater.DepthSegment.CompareX(MapWinGeoProc.NTS.Topology.Geometries.LineSegment,MapWinGeoProc.NTS.Topology.Geometries.LineSegment)">
            <summary>
            Compare two collinear segments for left-most ordering.
            If segs are vertical, use vertical ordering for comparison.
            If segs are equal, return 0.
            Segments are assumed to be directed so that the second coordinate is >= to the first
            (e.g. up and to the right).
            </summary>
            <param name="seg0">A segment to compare.</param>
            <param name="seg1">A segment to compare.</param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Buffer.SubgraphDepthLocater.DepthSegment.LeftDepth">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.Octants">
            <summary>
            Octants in the Cartesian plane.
            Octants are numbered as follows:
             <para>
              \2|1/
             3 \|/ 0
             ---+--
             4 /|\ 7
              /5|6\ 
            </para>
             If line segments lie along a coordinate axis, the octant is the lower of the two possible values.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Noding.Octants.Null">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Noding.Octants.Zero">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Noding.Octants.One">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Noding.Octants.Two">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Noding.Octants.Three">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Noding.Octants.Four">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Noding.Octants.Five">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Noding.Octants.Six">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Noding.Octants.Seven">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.Octant">
            <summary>
             Methods for computing and working with <see cref="T:MapWinGeoProc.NTS.Topology.Noding.Octants"/> of the Cartesian plane.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Octant.GetOctant(System.Double,System.Double)">
            <summary>
            Returns the octant of a directed line segment (specified as x and y
            displacements, which cannot both be 0).
            </summary>
            <param name="dx"></param>
            <param name="dy"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Octant.GetOctant(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Returns the octant of a directed line segment from p0 to p1.
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.WKTWriter">
            <summary> 
            Outputs the textual representation of a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>.
            The <see cref="T:MapWinGeoProc.NTS.Topology.IO.WKTWriter"/> outputs coordinates rounded to the precision
            model. No more than the maximum number of necessary decimal places will be
            output.
            The Well-known Text format is defined in the <A HREF="http://www.opengis.org/techno/specs.htm">OpenGIS Simple Features
            Specification for SQL</A>.
            A non-standard "LINEARRING" tag is used for LinearRings. The WKT spec does
            not define a special tag for LinearRings. The standard tag to use is
            "LINESTRING".
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.ToPoint(MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            Generates the WKT for a <c>Point</c>.
            </summary>
            <param name="p0">The point coordinate.</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.ToLineString(MapWindow.Interfaces.Geometries.ICoordinateSequence)">
            <summary>
            Generates the WKT for a N-point <c>LineString</c>.
            </summary>
            <param name="seq">The sequence to output.</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.ToLineString(MapWinGeoProc.NTS.Topology.Geometries.Coordinate,MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            Generates the WKT for a 2-point <c>LineString</c>.
            </summary>
            <param name="p0">The first coordinate.</param>
            <param name="p1">The second coordinate.</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.CreateFormatter(MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel)">
            <summary>  
            Creates the <c>NumberFormatInfo</c> used to write <c>double</c>s
            with a sufficient number of decimal places.
            </summary>
            <param name="precisionModel"> 
            The <c>PrecisionModel</c> used to determine
            the number of decimal places to write.
            </param>
            <returns>
            A <c>NumberFormatInfo</c> that write <c>double</c>
            s without scientific notation.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.StringOfChar(System.Char,System.Int32)">
            <summary>
            Returns a <c>String</c> of repeated characters.
            </summary>
            <param name="ch">The character to repeat.</param>
            <param name="count">The number of times to repeat the character.</param>
            <returns>A <c>string</c> of characters.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.Write(MapWinGeoProc.NTS.Topology.Geometries.Geometry)">
            <summary>
            Converts a <c>Geometry</c> to its Well-known Text representation.
            </summary>
            <param name="geometry">A <c>Geometry</c> to process.</param>
            <returns>A Geometry Tagged Text string (see the OpenGIS Simple Features Specification).</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.Write(MapWinGeoProc.NTS.Topology.Geometries.Geometry,System.IO.TextWriter)">
            <summary>
            Converts a <c>Geometry</c> to its Well-known Text representation.
            </summary>
            <param name="geometry">A <c>Geometry</c> to process.</param>
            <param name="writer"></param>
            <returns>A "Geometry Tagged Text" string (see the OpenGIS Simple Features Specification)</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.WriteFormatted(MapWinGeoProc.NTS.Topology.Geometries.Geometry)">
            <summary>
            Same as <c>write</c>, but with newlines and spaces to make the
            well-known text more readable.
            </summary>
            <param name="geometry">A <c>Geometry</c> to process</param>
            <returns>
            A "Geometry Tagged Text" string (see the OpenGIS Simple
            Features Specification), with newlines and spaces.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.WriteFormatted(MapWinGeoProc.NTS.Topology.Geometries.Geometry,System.IO.TextWriter)">
            <summary>
            Same as <c>write</c>, but with newlines and spaces to make the
            well-known text more readable.
            </summary>
            <param name="geometry">A <c>Geometry</c> to process</param>
            <param name="writer"></param>
            <returns>
            A Geometry Tagged Text string (see the OpenGIS Simple
            Features Specification), with newlines and spaces.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.WriteFormatted(MapWinGeoProc.NTS.Topology.Geometries.Geometry,System.Boolean,System.IO.TextWriter)">
            <summary>
            Converts a <c>Geometry</c> to its Well-known Text representation.
            </summary>
            <param name="geometry">A <c>Geometry</c> to process</param>
            <param name="isFormatted"></param>
            <param name="writer"></param>
            <returns>
            A "Geometry Tagged Text" string (see the OpenGIS Simple
            Features Specification).
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.AppendGeometryTaggedText(MapWindow.Interfaces.Geometries.IGeometry,System.Int32,System.IO.TextWriter)">
            <summary>
            Converts a <c>Geometry</c> to &lt;Geometry Tagged Text format,
            then appends it to the writer.
            </summary>
            <param name="geometry">/he <c>Geometry</c> to process.</param>
            <param name="level"></param>
            <param name="writer">/he output writer to append to.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.AppendPointTaggedText(MapWindow.Interfaces.Geometries.ICoordinate,System.Int32,System.IO.TextWriter,MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel)">
            <summary>
            Converts a <c>Coordinate</c> to Point Tagged Text format,
            then appends it to the writer.
            </summary>
            <param name="coordinate">The <c>Coordinate</c> to process.</param>
            <param name="level"></param>
            <param name="writer">The output writer to append to.</param>
            <param name="precisionModel"> 
            The <c>PrecisionModel</c> to use to convert
            from a precise coordinate to an external coordinate.
            </param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.AppendLineStringTaggedText(MapWindow.Interfaces.Geometries.ILineString,System.Int32,System.IO.TextWriter)">
            <summary>
            Converts a <c>LineString</c> to &lt;LineString Tagged Text
            format, then appends it to the writer.
            </summary>
            <param name="lineString">The <c>LineString</c> to process.</param>
            <param name="level"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.AppendLinearRingTaggedText(MapWindow.Interfaces.Geometries.ILinearRing,System.Int32,System.IO.TextWriter)">
            <summary>
            Converts a <c>LinearRing</c> to &lt;LinearRing Tagged Text
            format, then appends it to the writer.
            </summary>
            <param name="linearRing">The <c>LinearRing</c> to process.</param>
            <param name="level"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.AppendPolygonTaggedText(MapWindow.Interfaces.Geometries.IPolygon,System.Int32,System.IO.TextWriter)">
            <summary>
            Converts a <c>Polygon</c> to Polygon Tagged Text format,
            then appends it to the writer.
            </summary>
            <param name="polygon">The <c>Polygon</c> to process.</param>
            <param name="level"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.AppendMultiPointTaggedText(MapWindow.Interfaces.Geometries.IMultiPoint,System.Int32,System.IO.TextWriter)">
            <summary>
            Converts a <c>MultiPoint</c> to &lt;MultiPoint Tagged Text
            format, then appends it to the writer.
            </summary>
            <param name="multipoint">The <c>MultiPoint</c> to process.</param>
            <param name="level"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.AppendMultiLineStringTaggedText(MapWindow.Interfaces.Geometries.IMultiLineString,System.Int32,System.IO.TextWriter)">
            <summary>
            Converts a <c>MultiLineString</c> to MultiLineString Tagged
            Text format, then appends it to the writer.
            </summary>
            <param name="multiLineString">The <c>MultiLineString</c> to process.</param>
            <param name="level"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.AppendMultiPolygonTaggedText(MapWindow.Interfaces.Geometries.IMultiPolygon,System.Int32,System.IO.TextWriter)">
            <summary>
            Converts a <c>MultiPolygon</c> to MultiPolygon Tagged Text
            format, then appends it to the writer.
            </summary>
            <param name="multiPolygon">The <c>MultiPolygon</c> to process.</param>
            <param name="level"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.AppendGeometryCollectionTaggedText(MapWindow.Interfaces.Geometries.IGeometryCollection,System.Int32,System.IO.TextWriter)">
            <summary>
            Converts a <c>GeometryCollection</c> to GeometryCollection
            Tagged Text format, then appends it to the writer.
            </summary>
            <param name="geometryCollection">The <c>GeometryCollection</c> to process.</param>
            <param name="level"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.AppendPointText(MapWindow.Interfaces.Geometries.ICoordinate,System.Int32,System.IO.TextWriter,MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel)">
            <summary>
            Converts a <c>Coordinate</c> to Point Text format, then
            appends it to the writer.
            </summary>
            <param name="coordinate">The <c>Coordinate</c> to process.</param>
            <param name="level"></param>
            <param name="writer">The output writer to append to.</param>
            <param name="precisionModel">
            The <c>PrecisionModel</c> to use to convert
            from a precise coordinate to an external coordinate.
            </param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.AppendCoordinate(MapWindow.Interfaces.Geometries.ICoordinate,System.IO.TextWriter,MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel)">
            <summary>
            Converts a <c>Coordinate</c> to Point format, then appends
            it to the writer.
            </summary>
            <param name="coordinate">The <c>Coordinate</c> to process.</param>
            <param name="writer">The output writer to append to.</param>
            <param name="precisionModel">
            The <c>PrecisionModel</c> to use to convert
            from a precise coordinate to an external coordinate.
            </param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.WriteNumber(System.Double)">
            <summary>
            Converts a <see cref="T:System.Double"/> to a <see cref="T:System.String"/>, 
            not in scientific notation.
            </summary>
            <param name="d">The <see cref="T:System.Double"/> to convert.</param>
            <returns>
            The <see cref="T:System.Double"/> as a <see cref="T:System.String"/>, 
            not in scientific notation.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.AppendLineStringText(MapWindow.Interfaces.Geometries.ILineString,System.Int32,System.Boolean,System.IO.TextWriter)">
            <summary>
            Converts a <c>LineString</c> to &lt;LineString Text format, then
            appends it to the writer.
            </summary>
            <param name="lineString">The <c>LineString</c> to process.</param>
            <param name="level"></param>
            <param name="doIndent"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.AppendPolygonText(MapWindow.Interfaces.Geometries.IPolygon,System.Int32,System.Boolean,System.IO.TextWriter)">
            <summary>
            Converts a <c>Polygon</c> to Polygon Text format, then
            appends it to the writer.
            </summary>
            <param name="polygon">The <c>Polygon</c> to process.</param>
            <param name="level"></param>
            <param name="indentFirst"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.AppendMultiPointText(MapWindow.Interfaces.Geometries.IMultiPoint,System.Int32,System.IO.TextWriter)">
            <summary>
            Converts a <c>MultiPoint</c> to &lt;MultiPoint Text format, then
            appends it to the writer.
            </summary>
            <param name="multiPoint">The <c>MultiPoint</c> to process.</param>
            <param name="level"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.AppendMultiLineStringText(MapWindow.Interfaces.Geometries.IMultiLineString,System.Int32,System.Boolean,System.IO.TextWriter)">
            <summary>
            Converts a <c>MultiLineString</c> to &lt;MultiLineString Text
            format, then appends it to the writer.
            </summary>
            <param name="multiLineString">The <c>MultiLineString</c> to process.</param>
            <param name="level"></param>
            <param name="indentFirst"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.AppendMultiPolygonText(MapWindow.Interfaces.Geometries.IMultiPolygon,System.Int32,System.IO.TextWriter)">
            <summary>
            Converts a <c>MultiPolygon</c> to &lt;MultiPolygon Text format,
            then appends it to the writer.
            </summary>
            <param name="multiPolygon">The <c>MultiPolygon</c> to process.</param>
            <param name="level"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.AppendGeometryCollectionText(MapWindow.Interfaces.Geometries.IGeometryCollection,System.Int32,System.IO.TextWriter)">
            <summary>
            Converts a <c>GeometryCollection</c> to GeometryCollectionText
            format, then appends it to the writer.
            </summary>
            <param name="geometryCollection">The <c>GeometryCollection</c> to process.</param>
            <param name="level"></param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTWriter.Indent(System.Int32,System.IO.TextWriter)">
            <summary>
            
            </summary>
            <param name="level"></param>
            <param name="writer"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.WKTReader">
            <summary>  
            Converts a Well-Known Text string to a <c>Geometry</c>.
            
            The <c>WKTReader</c> allows
            extracting <c>Geometry</c> objects from either input streams or
            internal strings. This allows it to function as a parser to read <c>Geometry</c>
            objects from text blocks embedded in other data formats (e.g. XML). 
            
            The Well-known
            Text format is defined in the <A HREF="http://www.opengis.org/techno/specs.htm">
            OpenGIS Simple Features Specification for SQL</A> . 
            
            NOTE:  There is an inconsistency in the SFS. 
            The WKT grammar states that <c>MultiPoints</c> are represented by 
            <c>MULTIPOINT ( ( x y), (x y) )</c>, 
            but the examples show <c>MultiPoint</c>s as <c>MULTIPOINT ( x y, x y )</c>. 
            Other implementations follow the latter syntax, so NTS will adopt it as well.
            A <c>WKTReader</c> is parameterized by a <c>GeometryFactory</c>, 
            to allow it to create <c>Geometry</c> objects of the appropriate
            implementation. In particular, the <c>GeometryFactory</c> will
            determine the <c>PrecisionModel</c> and <c>SRID</c> that is used. 
            The <c>WKTReader</c> will convert the input numbers to the precise
            internal representation.
            <remarks>
            <see cref="T:MapWinGeoProc.NTS.Topology.IO.WKTReader"/> reads also non-standard "LINEARRING" tags.
            </remarks>
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTReader.#ctor">
            <summary> 
            Creates a <c>WKTReader</c> that creates objects using a basic GeometryFactory.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTReader.#ctor(MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>  
            Creates a <c>WKTReader</c> that creates objects using the given
            <c>GeometryFactory</c>.
            </summary>
            <param name="geometryFactory">The factory used to create <c>Geometry</c>s.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTReader.Read(System.String)">
            <summary>
            Converts a Well-known Text representation to a <c>Geometry</c>.
            </summary>
            <param name="wellKnownText">
            one or more Geometry Tagged Text strings (see the OpenGIS
            Simple Features Specification) separated by whitespace.
            </param>
            <returns>
            A <c>Geometry</c> specified by <c>wellKnownText</c>
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTReader.Read(System.IO.TextReader)">
            <summary>  
            Converts a Well-known Text representation to a <c>Geometry</c>.
            </summary>
            <param name="reader"> 
            A Reader which will return a "Geometry Tagged Text"
            string (see the OpenGIS Simple Features Specification).
            </param>
            <returns>A <c>Geometry</c> read from <c>reader</c>.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTReader.GetCoordinates(System.Collections.IList)">
            <summary>
            Returns the next array of <c>Coordinate</c>s in the stream.
            </summary>
            <param name="tokens">
            Tokenizer over a stream of text in Well-known Text
            format. The next element returned by the stream should be "(" (the
            beginning of "(x1 y1, x2 y2, ..., xn yn)") or "EMPTY".
            </param>
            <returns>
            The next array of <c>Coordinate</c>s in the
            stream, or an empty array if "EMPTY" is the next element returned by
            the stream.        
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTReader.GetPreciseCoordinate(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="tokens"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTReader.IsNumberNext(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="tokens"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTReader.GetNextNumber(System.Collections.IList)">
            <summary>
            Returns the next number in the stream.
            </summary>
            <param name="tokens">
            Tokenizer over a stream of text in Well-known Text
            format. The next token must be a number.
            </param>
            <returns>The next number in the stream.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTReader.GetNextEmptyOrOpener(System.Collections.IList)">
            <summary>
            Returns the next "EMPTY" or "(" in the stream as uppercase text.
            </summary>
            <param name="tokens">
            Tokenizer over a stream of text in Well-known Text
            format. The next token must be "EMPTY" or "(".
            </param>
            <returns>
            The next "EMPTY" or "(" in the stream as uppercase text.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTReader.GetNextCloserOrComma(System.Collections.IList)">
            <summary>
            Returns the next ")" or "," in the stream.
            </summary>
            <param name="tokens">
            Tokenizer over a stream of text in Well-known Text
            format. The next token must be ")" or ",".
            </param>
            <returns>
            The next ")" or "," in the stream.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTReader.GetNextCloser(System.Collections.IList)">
            <summary>
            Returns the next ")" in the stream.
            </summary>
            <param name="tokens">
            Tokenizer over a stream of text in Well-known Text
            format. The next token must be ")".
            </param>
            <returns>
            The next ")" in the stream.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTReader.GetNextWord(System.Collections.IList)">
            <summary>
            Returns the next word in the stream as uppercase text.
            </summary>
            <param name="tokens">
            Tokenizer over a stream of text in Well-known Text
            format. The next token must be a word.
            </param>
            <returns>The next word in the stream as uppercase text.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTReader.ReadGeometryTaggedText(System.Collections.IList)">
            <summary>
            Creates a <c>Geometry</c> using the next token in the stream.
            </summary>
            <param name="tokens">
            Tokenizer over a stream of text in Well-known Text
            format. The next tokens must form a &lt;Geometry Tagged Text.
            </param>
            <returns>A <c>Geometry</c> specified by the next token
            in the stream.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTReader.ReadPointText(System.Collections.IList)">
            <summary>
            Creates a <c>Point</c> using the next token in the stream.
            </summary>
            <param name="tokens">
            Tokenizer over a stream of text in Well-known Text
            format. The next tokens must form a &lt;Point Text.
            </param>
            <returns>A <c>Point</c> specified by the next token in
            the stream.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTReader.ReadLineStringText(System.Collections.IList)">
            <summary>
            Creates a <c>LineString</c> using the next token in the stream.
            </summary>
            <param name="tokens">
            Tokenizer over a stream of text in Well-known Text
            format. The next tokens must form a &lt;LineString Text.
            </param>
            <returns>
            A <c>LineString</c> specified by the next
            token in the stream.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTReader.ReadLinearRingText(System.Collections.IList)">
            <summary>
            Creates a <c>LinearRing</c> using the next token in the stream.
            </summary>
            <param name="tokens">
            Tokenizer over a stream of text in Well-known Text
            format. The next tokens must form a &lt;LineString Text.
            </param>
            <returns>A <c>LinearRing</c> specified by the next
            token in the stream.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTReader.ReadMultiPointText(System.Collections.IList)">
            <summary>
            Creates a <c>MultiPoint</c> using the next token in the stream.
            </summary>
            <param name="tokens">
            Tokenizer over a stream of text in Well-known Text
            format. The next tokens must form a &lt;MultiPoint Text.
            </param>
            <returns>
            A <c>MultiPoint</c> specified by the next
            token in the stream.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTReader.ToPoints(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[])">
            <summary> 
            Creates an array of <c>Point</c>s having the given <c>Coordinate</c>s.
            </summary>
            <param name="coordinates">
            The <c>Coordinate</c>s with which to create the <c>Point</c>s
            </param>
            <returns>
            <c>Point</c>s created using this <c>WKTReader</c>
            s <c>GeometryFactory</c>.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTReader.ReadPolygonText(System.Collections.IList)">
            <summary>  
            Creates a <c>Polygon</c> using the next token in the stream.
            </summary>
            <param name="tokens">
            Tokenizer over a stream of text in Well-known Text
            format. The next tokens must form a Polygon Text.
            </param>
            <returns>
            A <c>Polygon</c> specified by the next token
            in the stream.        
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTReader.ReadMultiLineStringText(System.Collections.IList)">
            <summary>
            Creates a <c>MultiLineString</c> using the next token in the stream.
            </summary>
            <param name="tokens">
            Tokenizer over a stream of text in Well-known Text
            format. The next tokens must form a MultiLineString Text.
            </param>
            <returns>
            A <c>MultiLineString</c> specified by the
            next token in the stream.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTReader.ReadMultiPolygonText(System.Collections.IList)">
            <summary>  
            Creates a <c>MultiPolygon</c> using the next token in the stream.
            </summary>
            <param name="tokens">Tokenizer over a stream of text in Well-known Text
            format. The next tokens must form a MultiPolygon Text.
            </param>
            <returns>
            A <c>MultiPolygon</c> specified by the next
            token in the stream, or if if the coordinates used to create the
            <c>Polygon</c> shells and holes do not form closed linestrings.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKTReader.ReadGeometryCollectionText(System.Collections.IList)">
            <summary>
            Creates a <c>GeometryCollection</c> using the next token in the
            stream.
            </summary>
            <param name="tokens">
            Tokenizer over a stream of text in Well-known Text
            format. The next tokens must form a &lt;GeometryCollection Text.
            </param>
            <returns>
            A <c>GeometryCollection</c> specified by the
            next token in the stream.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.TokenType">
            <summary>
            Represents the type of token created by the StreamTokenizer class.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.TokenType.Word">
            <summary>
            Indicates that the token is a word.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.TokenType.Number">
            <summary>
            Indicates that the token is a number. 
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.TokenType.Eol">
            <summary>
            Indicates that the end of line has been read. The field can only have this value if the eolIsSignificant method has been called with the argument true. 
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.TokenType.Eof">
            <summary>
            Indicates that the end of the input stream has been reached.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.TokenType.Whitespace">
            <summary>
            Indictaes that the token is white space (space, tab, newline).
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.TokenType.Symbol">
            <summary>
            Characters that are not whitespace, numbers, etc...
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.MultiLineHandler">
            <summary>
            Converts a Shapefile multi-line to a OGIS LineString/MultiLineString.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MultiLineHandler.#ctor">
            <summary>
            Initializes a new instance of the MultiLineHandler class.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MultiLineHandler.Read(MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryReader,MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            Reads a stream and converts the shapefile record to an equilivent geometry object.
            </summary>
            <param name="file">The stream to read.</param>
            <param name="geometryFactory">The geometry factory to use when making the object.</param>
            <returns>The Geometry object that represents the shape file record.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MultiLineHandler.Write(MapWindow.Interfaces.Geometries.IGeometry,System.IO.BinaryWriter,MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            Writes to the given stream the equilivent shape file record given a Geometry object.
            </summary>
            <param name="geometry">The geometry object to write.</param>
            <param name="file">The stream to write to.</param>
            <param name="geometryFactory">The geometry factory to use.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MultiLineHandler.GetLength(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Gets the length in bytes the Geometry will need when written as a shape file record.
            </summary>
            <param name="geometry">The Geometry object to use.</param>
            <returns>The length in bytes the Geometry will use when represented as a shape file record.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MultiLineHandler.GetNumParts(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.MultiLineHandler.ShapeType">
            <summary>
            Returns the ShapeType the handler handles.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.RowStructure">
            <summary>
            Implements ICustomTypeDescriptor so we can simulate a row object having a property for every field.
            </summary>
            <remarks>
            For an explaination of ICustomTypeDescriptor see http://www.devx.com/dotnet/Article/7874
            By implementing this interface, we are able to simulate that an object has lots of properties.
            These properties are determined dynamically at run-time. When enumerating throught the 
            ShapefileDataReader, RowStructure is the object that gets returned. 
            <code>
            foreach(object obj in shpDataReader)
            {
            	if (obj.GetType().Name!="RowStructure")
            	{
            		// this proves the type returned by shpDataReader
            	} 
            }
            </code>
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.RowStructure.#ctor(MapWinGeoProc.NTS.Topology.IO.DbaseFieldDescriptor[],System.Collections.ArrayList)">
            <summary>
            
            </summary>
            <param name="dbaseFields"></param>
            <param name="columnValues"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.RowStructure.GetAttributes">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.RowStructure.GetClassName">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.RowStructure.GetComponentName">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.RowStructure.GetConverter">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.RowStructure.GetEditor(System.Type)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.RowStructure.GetDefaultEvent">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.RowStructure.GetEvents(System.Attribute[])">
            <summary>
            
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.RowStructure.GetEvents">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.RowStructure.GetPropertyOwner(System.ComponentModel.PropertyDescriptor)">
            <summary>
            
            </summary>
            <param name="pd"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.RowStructure.GetDefaultProperty">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.RowStructure.GetProperties(System.Attribute[])">
            <summary>
            
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.RowStructure.GetProperties">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.RowStructure.ColumnValues">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineEvents">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineEvents.Insert">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineEvents.Delete">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineEvent">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineEvent.#ctor(System.Double,MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineEvent,MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineInterval)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="insertEvent"></param>
            <param name="sweepInt"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineEvent.CompareTo(System.Object)">
            <summary>
            ProjectionEvents are ordered first by their x-value, and then by their eventType.
            It is important that Insert events are sorted before Delete events, so that
            items whose Insert and Delete events occur at the same x-value will be
            correctly handled.
            </summary>
            <param name="o"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineEvent.IsInsert">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineEvent.IsDelete">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineEvent.InsertEvent">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineEvent.DeleteEventIndex">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineEvent.Interval">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.Utilities.PointExtracter">
            <summary> 
            Extracts all the 0-dimensional (<c>Point</c>) components from a <c>Geometry</c>.    
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.PointExtracter.GetPoints(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary> 
            Returns the Point components from a single point.
            If more than one point is to be processed, it is more
            efficient to create a single <c>PointExtracterFilter</c> instance
            and pass it to multiple geometries.
            </summary>
            <param name="geom"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.PointExtracter.#ctor(System.Collections.IList)">
            <summary> 
            Constructs a PointExtracterFilter with a list in which to store Points found.
            </summary>
            <param name="pts"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.PointExtracter.Filter(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleEdgeSetIntersector">
            <summary>
            Finds all intersections in one or two sets of edges,
            using the straightforward method of
            comparing all segments.
            This algorithm is too slow for production use, but is useful for testing purposes.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.EdgeSetIntersector">
            <summary>
            An <c>EdgeSetIntersector</c> computes all the intersections between the
            edges in the set.  It adds the computed intersections to each edge
            they are found on.  It may be used in two scenarios:
            determining the internal intersections between a single set of edges
            determining the mutual intersections between two different sets of edges
            It uses a <c>SegmentIntersector</c> to compute the intersections between
            segments and to record statistics about what kinds of intersections were found.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.EdgeSetIntersector.#ctor">
            <summary>
            Default empty constructor.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.EdgeSetIntersector.ComputeIntersections(System.Collections.IList,MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector,System.Boolean)">
            <summary>
            Computes all self-intersections between edges in a set of edges,
            allowing client to choose whether self-intersections are computed.
            </summary>
            <param name="edges">A list of edges to test for intersections.</param>
            <param name="si">The SegmentIntersector to use.</param>
            <param name="testAllSegments"><c>true</c> if self-intersections are to be tested as well.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.EdgeSetIntersector.ComputeIntersections(System.Collections.IList,System.Collections.IList,MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector)">
            <summary> 
            Computes all mutual intersections between two sets of edges.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleEdgeSetIntersector.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleEdgeSetIntersector.ComputeIntersections(System.Collections.IList,MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector,System.Boolean)">
            <summary>
            
            </summary>
            <param name="edges"></param>
            <param name="si"></param>
            <param name="testAllSegments"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleEdgeSetIntersector.ComputeIntersections(System.Collections.IList,System.Collections.IList,MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector)">
            <summary>
            
            </summary>
            <param name="edges0"></param>
            <param name="edges1"></param>
            <param name="si"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleEdgeSetIntersector.ComputeIntersects(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge,MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge,MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector)">
            <summary>
            Performs a brute-force comparison of every segment in each Edge.
            This has n^2 performance, and is about 100 times slower than using
            monotone chains.
            </summary>
            <param name="e0"></param>
            <param name="e1"></param>
            <param name="si"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.ICoordinateTransformation">
            <summary>
            Describes a coordinate transformation. This interface only describes a 
            coordinate transformation, it does not actually perform the transform 
            operation on points. To transform points you must use a math transform.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.ICoordinateTransformation.AreaOfUse">
            <summary>
            Human readable description of domain in source coordinate system.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.ICoordinateTransformation.Authority">
            <summary>
            Authority which defined transformation and parameter values.
            </summary>
            <remarks>
            An Authority is an organization that maintains definitions of Authority Codes. For example the European Petroleum Survey Group (EPSG) maintains a database of coordinate systems, and other spatial referencing objects, where each object has a code number ID. For example, the EPSG code for a WGS84 Lat/Lon coordinate system is ‘4326’
            </remarks>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.ICoordinateTransformation.AuthorityCode">
            <summary>
            Code used by authority to identify transformation. An empty string is used for no code.
            </summary>
            <remarks>The AuthorityCode is a compact string defined by an Authority to reference a particular spatial reference object. For example, the European Survey Group (EPSG) authority uses 32 bit integers to reference coordinate systems, so all their code strings will consist of a few digits. The EPSG code for WGS84 Lat/Lon is ‘4326’.</remarks>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.ICoordinateTransformation.MathTransform">
            <summary>
            Gets math transform.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.ICoordinateTransformation.Name">
            <summary>
            Name of transformation.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.ICoordinateTransformation.Remarks">
            <summary>
            Gets the provider-supplied remarks.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.ICoordinateTransformation.SourceCS">
            <summary>
            Source coordinate system.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.ICoordinateTransformation.TargetCS">
            <summary>
            Target coordinate system.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.ICoordinateTransformation.TransformType">
            <summary>
            Semantic type of transform. For example, a datum transformation or a coordinate conversion.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.AlbersProjection">
            <summary>
            	Implements the Albers projection.
            </summary>
            <remarks>
            	<para>Implements the Albers projection. The Albers projection is most commonly
            	used to project the United States of America. It gives the northern
            	border with Canada a curved appearance.</para>
            	
            	<para>The <a href="http://www.geog.mcgill.ca/courses/geo201/mapproj/naaeana.gif">Albers Equal Area</a>
            	projection has the property that the area bounded
            	by any pair of parallels and meridians is exactly reproduced between the 
            	image of those parallels and meridians in the projected domain, that is,
            	the projection preserves the correct area of the earth though distorts
            	direction, distance and shape somewhat.</para>
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.AlbersProjection.#ctor(System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectionParameter})">
            <summary>
            Creates an instance of an Albers projection object.
            </summary>
            <param name="parameters">List of parameters to initialize the projection.</param>
            <remarks>
            <para>The parameters this projection expects are listed below.</para>
            <list type="table">
            <listheader><term>Items</term><description>Descriptions</description></listheader>
            <item><term>latitude_of_false_origin</term><description>The latitude of the point which is not the natural origin and at which grid coordinate values false easting and false northing are defined.</description></item>
            <item><term>longitude_of_false_origin</term><description>The longitude of the point which is not the natural origin and at which grid coordinate values false easting and false northing are defined.</description></item>
            <item><term>latitude_of_1st_standard_parallel</term><description>For a conic projection with two standard parallels, this is the latitude of intersection of the cone with the ellipsoid that is nearest the pole.  Scale is true along this parallel.</description></item>
            <item><term>latitude_of_2nd_standard_parallel</term><description>For a conic projection with two standard parallels, this is the latitude of intersection of the cone with the ellipsoid that is furthest from the pole.  Scale is true along this parallel.</description></item>
            <item><term>easting_at_false_origin</term><description>The easting value assigned to the false origin.</description></item>
            <item><term>northing_at_false_origin</term><description>The northing value assigned to the false origin.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.AlbersProjection.#ctor(System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectionParameter},System.Boolean)">
            <summary>
            Creates an instance of an Albers projection object.
            </summary>
            <remarks>
            <para>The parameters this projection expects are listed below.</para>
            <list type="table">
            <listheader><term>Items</term><description>Descriptions</description></listheader>
            <item><term>latitude_of_center</term><description>The latitude of the point which is not the natural origin and at which grid coordinate values false easting and false northing are defined.</description></item>
            <item><term>longitude_of_center</term><description>The longitude of the point which is not the natural origin and at which grid coordinate values false easting and false northing are defined.</description></item>
            <item><term>standard_parallel_1</term><description>For a conic projection with two standard parallels, this is the latitude of intersection of the cone with the ellipsoid that is nearest the pole.  Scale is true along this parallel.</description></item>
            <item><term>standard_parallel_2</term><description>For a conic projection with two standard parallels, this is the latitude of intersection of the cone with the ellipsoid that is furthest from the pole.  Scale is true along this parallel.</description></item>
            <item><term>false_easting</term><description>The easting value assigned to the false origin.</description></item>
            <item><term>false_northing</term><description>The northing value assigned to the false origin.</description></item>
            </list>
            </remarks>
            <param name="parameters">List of parameters to initialize the projection.</param>
            <param name="isInverse">Indicates whether the projection forward (meters to degrees or degrees to meters).</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.AlbersProjection.DegreesToMeters(MapWinGeoProc.NTS.Topology.Geometries.Point)">
            <summary>
            Converts coordinates in decimal degrees to projected meters.
            </summary>
            <param name="lonlat">The point in decimal degrees.</param>
            <returns>Point in projected meters</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.AlbersProjection.MetersToDegrees(MapWinGeoProc.NTS.Topology.Geometries.Point)">
            <summary>
            Converts coordinates in projected meters to decimal degrees.
            </summary>
            <param name="p">Point in meters</param>
            <returns>Transformed point in decimal degrees</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.AlbersProjection.Inverse">
            <summary>
            Returns the inverse of this projection.
            </summary>
            <returns>IMathTransform that is the reverse of the current projection.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisOrientationEnum">
            <summary>
            Orientation of axis. Some coordinate systems use non-standard orientations. 
            For example, the first axis in South African grids usually points West, 
            instead of East. This information is obviously relevant for algorithms
            converting South African grid coordinates into Lat/Long.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisOrientationEnum.Other">
            <summary>
            Unknown or unspecified axis orientation. This can be used for local or fitted coordinate systems.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisOrientationEnum.North">
            <summary>
            Increasing ordinates values go North. This is usually used for Grid Y coordinates and Latitude.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisOrientationEnum.South">
            <summary>
            Increasing ordinates values go South. This is rarely used.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisOrientationEnum.East">
            <summary>
            Increasing ordinates values go East. This is rarely used.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisOrientationEnum.West">
            <summary>
            Increasing ordinates values go West. This is usually used for Grid X coordinates and Longitude.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisOrientationEnum.Up">
            <summary>
            Increasing ordinates values go up. This is used for vertical coordinate systems.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisOrientationEnum.Down">
            <summary>
            Increasing ordinates values go down. This is used for vertical coordinate systems.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.AngularUnit">
            <summary>
            Definition of angular units.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.AngularUnit.#ctor(System.Double)">
            <summary>
            Initializes a new instance of a angular unit
            </summary>
            <param name="radiansPerUnit">Radians per unit</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.AngularUnit.#ctor(System.Double,System.String,System.String,System.Int64,System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of a angular unit
            </summary>
            <param name="radiansPerUnit">Radians per unit</param>
            <param name="name">Name</param>
            <param name="authority">Authority name</param>
            <param name="authorityCode">Authority-specific identification code.</param>
            <param name="alias">Alias</param>
            <param name="abbreviation">Abbreviation</param>
            <param name="remarks">Provider-supplied remarks</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.AngularUnit.EqualParams(System.Object)">
            <summary>
            Checks whether the values of this instance is equal to the values of another instance.
            Only parameters used for coordinate system are used for comparison.
            Name, abbreviation, authority, alias and remarks are ignored in the comparison.
            </summary>
            <param name="obj"></param>
            <returns>True if equal</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.AngularUnit.Degrees">
            <summary>
            The angular degrees are PI/180 = 0.017453292519943295769236907684886 radians
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.AngularUnit.Radian">
            <summary>
            SI standard unit
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.AngularUnit.Grad">
            <summary>
            Pi / 200 = 0.015707963267948966192313216916398 radians
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.AngularUnit.Gon">
            <summary>
            Pi / 200 = 0.015707963267948966192313216916398 radians
            </summary>		
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.AngularUnit.RadiansPerUnit">
            <summary>
            Gets or sets the number of radians per <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.AngularUnit"/>.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.AngularUnit.WKT">
            <summary>
            Returns the Well-known text for this object
            as defined in the simple features specification.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.AngularUnit.XML">
            <summary>
            Gets an XML representation of this object.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.SimplePointInRing">
            <summary> 
            Tests whether a <c>Coordinate</c> lies inside
            a ring, using a linear-time algorithm.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Algorithm.SimplePointInRing.pts">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.SimplePointInRing.#ctor(MapWinGeoProc.NTS.Topology.Geometries.LinearRing)">
            <summary>
            
            </summary>
            <param name="ring"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.SimplePointInRing.IsInside(MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.RobustDeterminant">
            <summary> 
            Implements an algorithm to compute the
            sign of a 2x2 determinant for double precision values robustly.
            It is a direct translation of code developed by Olivier Devillers.
            
            The original code carries the following copyright notice:
            ************************************************************************
            Author : Olivier Devillers
            Olivier.Devillers@sophia.inria.fr
            http:/www.inria.fr:/prisme/personnel/devillers/anglais/determinant.html
            *************************************************************************
            *************************************************************************
            Copyright (c) 1995  by  INRIA Prisme Project
            BP 93 06902 Sophia Antipolis Cedex, France.
            All rights reserved
            *************************************************************************
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.RobustDeterminant.SignOfDet2x2(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <returns>
            returns -1 if the determinant is negative,
            returns  1 if the determinant is positive,
            retunrs  0 if the determinant is null.
            </returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.CentroidLine">
            <summary> 
            Computes the centroid of a linear point.
            Algorithm:
            Compute the average of the midpoints
            of all line segments weighted by the segment length.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CentroidLine.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CentroidLine.Add(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary> 
            Adds the linestring(s) defined by a Geometry to the centroid total.
            If the point is not linear it does not contribute to the centroid.
            </summary>
            <param name="geom">The point to add.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CentroidLine.Add(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary> 
            Adds the length defined by an array of coordinates.
            </summary>
            <param name="pts">An array of <c>Coordinates</c>.</param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Algorithm.CentroidLine.Centroid">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.UnitConverter">
            <summary>
            Class for converting between different distance / area units
            </summary>
        </member>
        <member name="M:MapWinGeoProc.UnitConverter.ConvertLength(MapWindow.Interfaces.UnitOfMeasure,MapWindow.Interfaces.UnitOfMeasure,System.Double)">
            <summary>
            Distance unit conversion
            </summary>
            <param name="convertFrom">The original unit to convert from</param>
            <param name="convertTo">The new unit to convert to</param>
            <param name="orgMeasurement">The measured distance to convert from (in original units)</param>
            <returns>The conversion result (in the new units)</returns>
        </member>
        <member name="M:MapWinGeoProc.UnitConverter.ConvertArea(MapWindow.Interfaces.UnitOfMeasure,MapWindow.Interfaces.UnitOfMeasure,System.Double)">
            <summary>
            Area unit conversion
            </summary>
            <param name="convertFrom">The original unit to convert from</param>
            <param name="convertTo">The new unit to convert to</param>
            <param name="orgMeasurement">The measured area to convert from (in original units)</param>
            <returns>The conversion result (in the new units)</returns>
        </member>
        <member name="M:MapWinGeoProc.UnitConverter.GetShapefileUnits(System.String)">
            <summary>
            Try to detect the units from a "proj4" string
            </summary>
            <param name="prj4"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.UnitConverter.StringToUOM(System.String)">
            <summary>
            try to detect the distance/area unit name from it's type
            </summary>
            <param name="unitName">the unit name (must be MapWindow.Interfaces.UnitOfMeasure.ToString()</param>
            <returns>the unit as a MapWindow.Interfaces.UnitOfMeasure enumeration member</returns>
        </member>
        <member name="M:MapWinGeoProc.UnitConverter.CalcConversionFactor(MapWindow.Interfaces.UnitOfMeasure,MapWindow.Interfaces.UnitOfMeasure,MapWinGeoProc.UnitConverter.MeasurementTypes)">
            <summary>
            Calculate a conversion factor between the units
            (Original code by Paul Meems)
            </summary>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.UnitConverter.ConversionFactorsSQUnits">
            <summary>
            The unit conversion factors
            (original code by Paul Meems)
            </summary>
        </member>
        <member name="T:KDTreeDLL.KeyDuplicateException">
            <summary>
            KeyDuplicateException is thrown when the <TT>KDTree.insert</TT> method
            is invoked on a key already in the KDTree.
            
            @author Simon Levy
            Translation by Marco A. Alvarez
            </summary> 
        </member>
        <member name="M:KDTreeDLL.KeyDuplicateException.#ctor">
            <summary>
            KeyDuplicateException
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Pitfill.Framework">
            <summary>
            This class is a collection object for all the frames that cover a specific grid.
            It contains information about the positions of frames as well as functions for
            iterating through frames.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Pitfill.Framework.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a new Framework to keep track of the multiple frames that make up an image.
            </summary>
            <param name="NumberCols">The number of rows in the entire image</param>
            <param name="NumberRows">the number of columns in the entire image</param>
            <param name="FrameWidth">The maximum number of columns for each frame</param>
            <param name="FrameHeight">The maximum number of rows for each frame</param>
        </member>
        <member name="M:MapWinGeoProc.Pitfill.Framework.get_Frame(System.Int32,System.Int32)">
            <summary>
            This is the function to obtain a specific frame based on its location in the framework.
            </summary>
            <param name="X">The horrizontal offset in frames (not pixels)</param>
            <param name="Y">The vertical offset in frames (not pixels)</param>
            <returns>A Pitfill.Frame</returns>
        </member>
        <member name="M:MapWinGeoProc.Pitfill.Framework.First_Time(System.Int32,System.Int32)">
            <summary>
            First time through
            </summary>
            <param name="X"></param>
            <param name="Y"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Pitfill.Framework.set_First_Time(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets first time through
            </summary>
            <param name="X"></param>
            <param name="Y"></param>
            <param name="value"></param>
        </member>
        <member name="M:MapWinGeoProc.Pitfill.Framework.Next_Frame">
            <summary>
            Returns the next frame in the list, or the first frame once
            the end of the list is reached.
            </summary>
            <returns>the next frame.</returns>
        </member>
        <member name="M:MapWinGeoProc.Pitfill.Framework.First_Frame">
            <summary>
            Returns the first frame in the list
            </summary>
            <returns>The first frame in the list.</returns>
        </member>
        <member name="M:MapWinGeoProc.Pitfill.Framework.set_Status(System.Int32,System.Int32,System.Int32,MapWinGeoProc.Pitfill.Frame.StatusType)">
            <summary>
            Assigns a particular status to a frame based on its location in the framework.
            The Direction allows the appropriate "HasDependencies" 
            </summary>
            <param name="X">The horizontal offset in frames (not pixels).</param>
            <param name="Y">The vertical offset in frames (not pixels)</param>
            <param name="Direction">Sets the direction for HasDependencies to be changed.</param>
            <param name="Status">The new status of the frame</param>
            <remarks>This is generally not used to </remarks>
        </member>
        <member name="M:MapWinGeoProc.Pitfill.Framework.InitDependencyFiles(System.String)">
            <summary>
            Will create a pair of temporary binary files with names similar to the destination file.
            The file named HZ stores dependencies in the rows that are shared by vertically stacked frames
            The file named VT stores dependencies in the columns shared by adjacent frames
            </summary>
            <param name="DestFile">The string filename of the filled output grid being created.</param>
        </member>
        <member name="M:MapWinGeoProc.Pitfill.Framework.DeleteFiles">
            <summary>
            Remove temporary binary files for storing dependencies
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Pitfill.Framework.numRows">
            <summary>
            The number of rowas in the entire grid
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Pitfill.Framework.numCols">
            <summary>
            The number of columns in the entire grid
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Pitfill.Framework.FrameWidth">
            <summary>
            The maximum number of columms to devote to an individual frame
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Pitfill.Framework.FrameHeight">
            <summary>
            The maximum number of rows to devote to an individual frame
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Pitfill.Framework.NumFramesTall">
            <summary>
            The entire grid is divided into this number of frames vertically.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Pitfill.Framework.NumFramesWide">
            <summary>
            The entire grid is divided into this number of frames horizontally.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Pitfill.Framework.TempFileHZ">
            <summary>
            This is the temporary file to write the horizontal dependencies to.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Pitfill.Framework.TempFileVT">
            <summary>
            This is the temporary file to write vertical dependencies to.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Pitfill.Framework.HasFrames">
            <summary>
            Gets a boolean value indicating whether any frames exist in the framework
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Pitfill.Framework.HasDependencies">
            <summary>
            Gets a boolean value indicating whether or not any dependencies exist
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Topology2D.Enums">
            <summary>
            Contains enumerations for Topology operations
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Topology2D.Enums.BufferSide">
            <summary>
            Specifies which side of a vector to buffer.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.Enums.BufferSide.Left">
            <summary>
            The left side of the vector
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.Enums.BufferSide.Right">
            <summary>
            The right side of the vector
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.Enums.BufferSide.Both">
            <summary>
            Both sides of the vector
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Topology2D.Coordinate">
            <summary>
            A basic set of coordinates with no methods 
            This is not an actual geometry in and of itself
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.Coordinate.X">
            <summary>
            The X, or horizontal coordinate
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.Coordinate.Y">
            <summary>
            The Y, or vertical coordinate
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Coordinate.#ctor">
            <summary>
            Constructs a (0,0) coordinate
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Coordinate.#ctor(System.Object)">
            <summary>
            Creates a new instance from a MapWinGIS.Point
            </summary>
            <param name="mwPoint">Creates a new instance from a MapWinGIS.Point</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Coordinate.#ctor(System.Double,System.Double)">
            <summary>
            Creates a new instance of a Coordinate using doubles
            </summary>
            <param name="Xval">The X, or horizontal location</param>
            <param name="Yval">The Y, or vertical location</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Coordinate.#ctor(MapWinGeoProc.Topology2D.Point)">
            <summary>
            Creates a new instance of a Coordinate using a Topology2D.Point
            </summary>
            <param name="Location">A Topology2D Point</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Coordinate.Copy">
            <summary>
            Returns a duplicate coordinate
            </summary>
            <returns>A Coordinate with the same X and Y values</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Coordinate.ToVector">
            <summary>
            Exports this location as the tip of a vector starting at the origin.
            </summary>
            <returns>Vector, this coordinate is the tip of the vector.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Coordinate.ToPoint">
            <summary>
            Returns a Point with the same X, Y values as this coordinate
            </summary>
            <returns>A Point with the same X and Y values.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Coordinate.Equals(System.Object)">
            <summary>
            Tests if the locations are equal
            </summary>
            <param name="obV">Either a Point or Coordinate</param>
            <returns>Boolean, true if the X and Y values are equal</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Coordinate.GetHashCode">
            <summary>
            Not sure what this is all about
            </summary>
            <returns>A hash code?</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Coordinate.op_Equality(MapWinGeoProc.Topology2D.Coordinate,System.Object)">
            <summary>
            Returns true if X and Y coordinates are equal
            </summary>
            <param name="U">A Point to compare</param>
            <param name="objV">Any object to compare with the point</param>
            <returns>Boolean, true if the vectors are the same</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Coordinate.op_Inequality(MapWinGeoProc.Topology2D.Coordinate,System.Object)">
            <summary>
            Returns true if X and Y coordinates are different
            </summary>
            <param name="U">A Point to compare</param>
            <param name="objV">An object to compare</param>
            <returns>Boolean, true if the vectors are the different</returns>
        </member>
        <member name="T:RTools.Util.ParseUtil">
            <summary>
            A start on some utility methods for parsing in conjunction with
            StreamTokenizer.  These currently use Token[] but could be adapted
            for ArrayList.
            </summary>
        </member>
        <member name="M:RTools.Util.ParseUtil.BuildArray(System.Collections.ArrayList,System.Int32@,System.Type,RTools.Util.Token,System.Int32,RTools.Util.Logger)">
            <summary>
            Build an Array of a particular type from a list of tokens.  
            The Type must be one that can be built with Convert.ChangeType.
            There are various ways to specify how many elements to parse.
            WARNING: This will throw an exception if any tokens cannot be
            converted.
            </summary>
            <param name="tokens">The ArrayList of tokens.</param>
            <param name="i">The starting (and ending) index.  This is
            modified, and left pointing at the last used token.</param>
            <param name="type">The Type of the array elements.</param>
            <param name="endToken">An optional end Token to look for.
            Parsing stops when a token equal to this is found.
            If this is null, then it is not used.</param>
            <param name="maxLength">The maximum number of array elements
            to parse.  If this is negative, then it is not used.</param>
            <param name="log">A Logger to use for messages.</param>
            <returns>The Array, or null for error.</returns>
        </member>
        <member name="M:RTools.Util.ParseUtil.SkipToWord(RTools.Util.Token[],System.Int32@)">
            <summary>
            Given a Token[] and a reference int, skip forward
            in the token array until a WordToken is found,
            and leave the reference int at that index.
            </summary>
            <param name="tokens">The token array.</param>
            <param name="i">The start index, and the result index.</param>
            <returns>bool - true for success, false for 
            hit the end of the tokens.</returns>
        </member>
        <member name="M:RTools.Util.ParseUtil.SkipToStringValue(RTools.Util.Token[],System.Int32@,System.String)">
            <summary>
            Given a Token[], a reference int and a string, skip forward
            in the token array until a token matches the string
            and leave the reference int at that index.
            </summary>
            <param name="tokens">The token array.</param>
            <param name="i">The start index, and the result index.</param>
            <param name="s">The string to look for.</param>
            <returns>bool - true for success, false for 
            hit the end of the tokens.</returns>
        </member>
        <member name="M:RTools.Util.ParseUtil.SkipToChar(RTools.Util.Token[],System.Int32@,System.Char)">
            <summary>
            Given a Token[] and a reference int, skip forward
            in the token array until a WordToken is found,
            and leave the reference int at that index.
            </summary>
            <param name="tokens">The token array.</param>
            <param name="i">The start index, and the result index.</param>
            <param name="c">The char to look for.</param>
            <returns>bool - true for success, false for 
            hit the end of the tokens.</returns>
        </member>
        <member name="M:RTools.Util.ParseUtil.SkipWs(RTools.Util.Token[],System.Int32@)">
            <summary>
            Given a Token[] and a reference int, skip forward
            in the token array until a WordToken is found,
            and leave the reference int at that index.
            </summary>
            <param name="tokens">The token array.</param>
            <param name="i">The start index, and the result index.</param>
            <returns>bool - true for success, false for 
            hit the end of the tokens.</returns>
        </member>
        <member name="M:RTools.Util.ParseUtil.SkipToEol(RTools.Util.Token[],System.Int32@)">
            <summary>
            Given a Token[] and a reference int, skip forward
            in the token array until a WordToken is found,
            and leave the reference int at that index.
            </summary>
            <param name="tokens">The token array.</param>
            <param name="i">The start index, and the result index.</param>
            <returns>bool - true for success, false for 
            hit the end of the tokens.</returns>
        </member>
        <member name="M:RTools.Util.ParseUtil.DropTokens(RTools.Util.Token[],RTools.Util.Token[])">
            <summary>
            Given a Token[] and a reference int, skip forward
            in the token array until a WordToken is found,
            and leave the reference int at that index.
            </summary>
            <param name="tokens">The token array.</param>
            <param name="dropTokens">The tokens to drop.</param>
            <returns>bool - true for success, false for 
            hit the end of the tokens.</returns>
        </member>
        <member name="M:RTools.Util.ParseUtil.FindMatch(RTools.Util.Token[],System.Int32@,System.Char)">
            <summary>
            Find matching closing character.
            The matchable pairs of characters are parenthesis (), 
            square brackets [], and curly braces {}.
            Given a Token[] and a reference int containing the index
            in the Token[] of a matchable? char, skip forward
            in the token array until the matching character is found.
            </summary>
            <remarks>
            This implicitly skips matching characters in quotes and
            comments if they are hidden in the tokens.  So if you grab
            comments and quotes when you tokenize, the characters in those
            tokens are not looked at by this function.
            </remarks>
            <param name="tokens">The token array.</param>
            <param name="i">The start index, and the result index.</param>
            <param name="c">The start character whose match is to be found.</param>
            <returns>bool - true for success, false for 
            hit the end of the tokens.</returns>
        </member>
        <member name="M:RTools.Util.ParseUtil.TestSelf">
            <summary>
            Simple test of some ParseUtil methods.
            </summary>
            <returns>bool - true for all passed, false otherwise</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Simplify.TopologyPreservingSimplifier">
            <summary>
            Simplifies a point, ensuring that
            the result is a valid point having the
            same dimension and number of components as the input.
            The simplification uses a maximum distance difference algorithm
            similar to the one used in the Douglas-Peucker algorithm.
            In particular, if the input is an areal point
            ( <c>Polygon</c> or <c>MultiPolygon</c> )
            The result has the same number of shells and holes (rings) as the input,
            in the same order
            The result rings touch at no more than the number of touching point in the input
            (although they may touch at fewer points).
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TopologyPreservingSimplifier.Simplify(MapWindow.Interfaces.Geometries.IGeometry,System.Double)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <param name="distanceTolerance"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TopologyPreservingSimplifier.#ctor(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="inputGeom"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TopologyPreservingSimplifier.GetResultGeometry">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Simplify.TopologyPreservingSimplifier.DistanceTolerance">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Simplify.TopologyPreservingSimplifier.LineStringTransformer">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TopologyPreservingSimplifier.LineStringTransformer.#ctor(MapWinGeoProc.NTS.Topology.Simplify.TopologyPreservingSimplifier)">
            <summary>
            
            </summary>
            <param name="container"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TopologyPreservingSimplifier.LineStringTransformer.TransformCoordinates(MapWindow.Interfaces.Geometries.ICoordinateSequence,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="coords"></param>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Simplify.TopologyPreservingSimplifier.LineStringMapBuilderFilter">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TopologyPreservingSimplifier.LineStringMapBuilderFilter.#ctor(MapWinGeoProc.NTS.Topology.Simplify.TopologyPreservingSimplifier)">
            <summary>
            
            </summary>
            <param name="container"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TopologyPreservingSimplifier.LineStringMapBuilderFilter.Filter(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Precision.CommonBitsRemover">
            <summary>
            Allow computing and removing common mantissa bits from one or more Geometries.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBitsRemover.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBitsRemover.Add(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Add a point to the set of geometries whose common bits are
            being computed.  After this method has executed the
            common coordinate reflects the common bits of all added
            geometries.
            </summary>
            <param name="geom">A Geometry to test for common bits.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBitsRemover.RemoveCommonBits(MapWinGeoProc.NTS.Topology.Geometries.Geometry)">
            <summary>
            Removes the common coordinate bits from a Geometry.
            The coordinates of the Geometry are changed.
            </summary>
            <param name="geom">The Geometry from which to remove the common coordinate bits.</param>
            <returns>The shifted Geometry.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBitsRemover.AddCommonBits(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Adds the common coordinate bits back into a Geometry.
            The coordinates of the Geometry are changed.
            </summary>
            <param name="geom">The Geometry to which to add the common coordinate bits.</param>
            <returns>The shifted Geometry.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Precision.CommonBitsRemover.CommonCoordinate">
            <summary>
            The common bits of the Coordinates in the supplied Geometries.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Precision.CommonBitsRemover.CommonCoordinateFilter">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBitsRemover.CommonCoordinateFilter.Filter(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="coord"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Precision.CommonBitsRemover.CommonCoordinateFilter.CommonCoordinate">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Precision.CommonBitsRemover.Translater">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBitsRemover.Translater.#ctor(MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            
            </summary>
            <param name="trans"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBitsRemover.Translater.Filter(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="coord"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Planargraph.Algorithm.ConnectedSubgraphFinder">
            <summary>
            Finds all connected <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.Subgraph"/>s of a <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph"/>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Algorithm.ConnectedSubgraphFinder.#ctor(MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph)">
            <summary>
            Initializes a new instance of the <see cref="T:ConnectedSubgraphFinder"/> class.
            </summary>
            <param name="graph">The <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph"/>.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Algorithm.ConnectedSubgraphFinder.GetConnectedSubgraphs">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Algorithm.ConnectedSubgraphFinder.AddReachable(MapWinGeoProc.NTS.Topology.Planargraph.Node,MapWinGeoProc.NTS.Topology.Planargraph.Subgraph)">
            <summary>
            Adds all nodes and edges reachable from this node to the subgraph.
            Uses an explicit stack to avoid a large depth of recursion.
            </summary>
            <param name="startNode"></param>
            <param name="subgraph"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Algorithm.ConnectedSubgraphFinder.AddEdges(MapWinGeoProc.NTS.Topology.Planargraph.Node,System.Collections.Stack,MapWinGeoProc.NTS.Topology.Planargraph.Subgraph)">
            <summary>
            Adds the argument node and all its out edges to the subgraph.
            </summary>
            <param name="node"></param>
            <param name="nodeStack"></param>
            <param name="subgraph"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Valid.RepeatedPointTester">
            <summary> 
            Implements the appropriate checks for repeated points
            (consecutive identical coordinates) as defined in the
            NTS spec.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.RepeatedPointTester.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.RepeatedPointTester.HasRepeatedPoint(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="g"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.RepeatedPointTester.HasRepeatedPoint(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            
            </summary>
            <param name="coord"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.RepeatedPointTester.HasRepeatedPoint(MapWindow.Interfaces.Geometries.IPolygon)">
            <summary>
            
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.RepeatedPointTester.HasRepeatedPoint(MapWindow.Interfaces.Geometries.IGeometryCollection)">
            <summary>
            
            </summary>
            <param name="gc"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Valid.RepeatedPointTester.Coordinate">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp">
            <summary>
            Implements the algorithsm required to compute the <see cref="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.IsValid"/>
            method for <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>s.
            See the documentation for the various geometry types for a specification of validity.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.IsValidCoordinate(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Checks whether a coordinate is valid for processing.
            Coordinates are valid iff their x and y ordinates are in the
            range of the floating point representation.
            </summary>
            <param name="coord">The coordinate to validate.</param>
            <returns><c>true</c> if the coordinate is valid.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.FindPointNotNode(MapWindow.Interfaces.Geometries.ICoordinate[],MapWinGeoProc.NTS.Topology.Geometries.LinearRing,MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            Find a point from the list of testCoords
            that is NOT a node in the edge for the list of searchCoords.
            </summary>
            <param name="testCoords"></param>
            <param name="searchRing"></param>
            <param name="graph"></param>
            <returns>The point found, or <c>null</c> if none found.</returns>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.isSelfTouchingRingFormingHoleValid">
            If the following condition is TRUE JTS will validate inverted shells and exverted holes (the ESRI SDE model).
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.#ctor(MapWinGeoProc.NTS.Topology.Geometries.Geometry)">
            <summary>
            
            </summary>
            <param name="parentGeometry"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.CheckValid(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.CheckValid(MapWindow.Interfaces.Geometries.IPoint)">
            <summary>
            Checks validity of a Point.
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.CheckValid(MapWindow.Interfaces.Geometries.IMultiPoint)">
            <summary>
            Checks validity of a MultiPoint.
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.CheckValid(MapWinGeoProc.NTS.Topology.Geometries.LineString)">
            <summary>
            Checks validity of a LineString.  
            Almost anything goes for lineStrings!
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.CheckValid(MapWinGeoProc.NTS.Topology.Geometries.LinearRing)">
            <summary>
            Checks validity of a LinearRing.
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.CheckValid(MapWinGeoProc.NTS.Topology.Geometries.Polygon)">
            <summary>
            Checks the validity of a polygon and sets the validErr flag.
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.CheckValid(MapWinGeoProc.NTS.Topology.Geometries.MultiPolygon)">
            <summary>
            
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.CheckValid(MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection)">
            <summary>
            
            </summary>
            <param name="gc"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.CheckInvalidCoordinates(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            
            </summary>
            <param name="coords"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.CheckInvalidCoordinates(MapWindow.Interfaces.Geometries.IPolygon)">
            <summary>
            
            </summary>
            <param name="poly"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.CheckClosedRings(MapWindow.Interfaces.Geometries.IPolygon)">
            <summary>
            
            </summary>
            <param name="poly"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.CheckClosedRing(MapWindow.Interfaces.Geometries.ILinearRing)">
            <summary>
            
            </summary>
            <param name="ring"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.CheckTooFewPoints(MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            
            </summary>
            <param name="graph"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.CheckConsistentArea(MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            
            </summary>
            <param name="graph"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.CheckNoSelfIntersectingRings(MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            Check that there is no ring which self-intersects (except of course at its endpoints).
            This is required by OGC topology rules (but not by other models
            such as ESRI SDE, which allow inverted shells and exverted holes).
            </summary>
            <param name="graph"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.CheckNoSelfIntersectingRing(MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersectionList)">
            <summary>
            Check that a ring does not self-intersect, except at its endpoints.
            Algorithm is to count the number of times each node along edge occurs.
            If any occur more than once, that must be a self-intersection.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.CheckHolesInShell(MapWinGeoProc.NTS.Topology.Geometries.Polygon,MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            Tests that each hole is inside the polygon shell.
            This routine assumes that the holes have previously been tested
            to ensure that all vertices lie on the shell or inside it.
            A simple test of a single point in the hole can be used,
            provide the point is chosen such that it does not lie on the
            boundary of the shell.
            </summary>
            <param name="p">The polygon to be tested for hole inclusion.</param>
            <param name="graph">A GeometryGraph incorporating the polygon.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.CheckHolesNotNested(MapWinGeoProc.NTS.Topology.Geometries.Polygon,MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            Tests that no hole is nested inside another hole.
            This routine assumes that the holes are disjoint.
            To ensure this, holes have previously been tested
            to ensure that:
            They do not partially overlap
            (checked by <c>checkRelateConsistency</c>).
            They are not identical
            (checked by <c>checkRelateConsistency</c>).
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.CheckShellsNotNested(MapWinGeoProc.NTS.Topology.Geometries.MultiPolygon,MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            Tests that no element polygon is wholly in the interior of another element polygon.
            Preconditions:
            Shells do not partially overlap.
            Shells do not touch along an edge.
            No duplicate rings exists.
            This routine relies on the fact that while polygon shells may touch at one or
            more vertices, they cannot touch at ALL vertices.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.CheckShellNotNested(MapWinGeoProc.NTS.Topology.Geometries.LinearRing,MapWinGeoProc.NTS.Topology.Geometries.Polygon,MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            Check if a shell is incorrectly nested within a polygon.  This is the case
            if the shell is inside the polygon shell, but not inside a polygon hole.
            (If the shell is inside a polygon hole, the nesting is valid.)
            The algorithm used relies on the fact that the rings must be properly contained.
            E.g. they cannot partially overlap (this has been previously checked by
            <c>CheckRelateConsistency</c>).
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.CheckShellInsideHole(MapWinGeoProc.NTS.Topology.Geometries.LinearRing,MapWinGeoProc.NTS.Topology.Geometries.LinearRing,MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph)">
            <summary> 
            This routine checks to see if a shell is properly contained in a hole.
            It assumes that the edges of the shell and hole do not
            properly intersect.
            </summary>
            <param name="shell"></param>
            <param name="hole"></param>
            <param name="graph"></param>
            <returns>
            <c>null</c> if the shell is properly contained, or
            a Coordinate which is not inside the hole if it is not.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.CheckConnectedInteriors(MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            
            </summary>
            <param name="graph"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.IsSelfTouchingRingFormingHoleValid">
            <summary>
            <para>
            Gets/Sets whether polygons using Self-Touching Rings to form
            holes are reported as valid.
            If this flag is set, the following Self-Touching conditions
            are treated as being valid:
            - The shell ring self-touches to create a hole touching the shell.
            - A hole ring self-touches to create two holes touching at a point.
            </para>
            <para>
            The default (following the OGC SFS standard)
            is that this condition is not valid (<c>false</c>).
            </para>
            <para>
            This does not affect whether Self-Touching Rings
            disconnecting the polygon interior are considered valid
            (these are considered to be invalid under the SFS, and many other
            spatial models as well).
            This includes "bow-tie" shells,
            which self-touch at a single point causing the interior to be disconnected,
            and "C-shaped" holes which self-touch at a single point causing an island to be formed.
            </para>
            </summary>
            <value>States whether geometry with this condition is valid.</value>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.IsValid">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Valid.IsValidOp.ValidationError">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeEdge">
            <summary>
            An edge of a polygonization graph.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeEdge.#ctor(MapWinGeoProc.NTS.Topology.Geometries.LineString)">
            <summary>
            
            </summary>
            <param name="line"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeEdge.Line">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Linemerge.EdgeString">
            <summary>
            A sequence of <c>LineMergeDirectedEdge</c>s forming one of the lines that will
            be output by the line-merging process.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.EdgeString.#ctor(MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            Constructs an EdgeString with the given factory used to convert this EdgeString
            to a LineString.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.EdgeString.Add(MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMergeDirectedEdge)">
            <summary>
            Adds a directed edge which is known to form part of this line.
            </summary>
            <param name="directedEdge"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.EdgeString.ToLineString">
            <summary>
            Converts this EdgeString into a LineString.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Linemerge.EdgeString.Coordinates">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.IntersectionFinderAdder">
            <summary>
            Finds proper and interior intersections in a set of <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s,
            and adds them as nodes.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.ISegmentIntersector">
            <summary>
            Computes the intersections between two line segments in <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s
            and adds them to each string.
            The <see cref="T:MapWinGeoProc.NTS.Topology.Noding.ISegmentIntersector"/> is passed to a <see cref="T:MapWinGeoProc.NTS.Topology.Noding.INoder"/>.
            The <see cref="M:MapWinGeoProc.NTS.Topology.Noding.SegmentString.AddIntersections(MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector,System.Int32,System.Int32)"/>  method is called whenever the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.INoder"/>
            detects that two <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/> s might intersect.
            This class is an example of the Strategy pattern.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.ISegmentIntersector.ProcessIntersections(MapWinGeoProc.NTS.Topology.Noding.SegmentString,System.Int32,MapWinGeoProc.NTS.Topology.Noding.SegmentString,System.Int32)">
            <summary>
            This method is called by clients
            of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.ISegmentIntersector"/> interface to process
            intersections for two segments of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s being intersected.
            </summary>
            <param name="e0"></param>
            <param name="segIndex0"></param>
            <param name="e1"></param>
            <param name="segIndex1"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.IntersectionFinderAdder.#ctor(MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector)">
            <summary>
            Creates an intersection finder which finds all proper intersections.
            </summary>
            <param name="li">The <see cref="T:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector"/> to use.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.IntersectionFinderAdder.ProcessIntersections(MapWinGeoProc.NTS.Topology.Noding.SegmentString,System.Int32,MapWinGeoProc.NTS.Topology.Noding.SegmentString,System.Int32)">
            <summary>
            This method is called by clients
            of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.ISegmentIntersector"/> class to process
            intersections for two segments of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s being intersected.
            Note that some clients (such as <see cref="T:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain"/>s) may optimize away
            this call for segment pairs which they have determined do not intersect
            (e.g. by an disjoint envelope test).
            </summary>
            <param name="e0"></param>
            <param name="segIndex0"></param>
            <param name="e1"></param>
            <param name="segIndex1"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.IntersectionFinderAdder.InteriorIntersections">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearGeometryBuilder">
            <summary>
            Builds a linear geometry (<see cref="T:MapWinGeoProc.NTS.Topology.Geometries.LineString"/> or <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.MultiLineString"/>)
            incrementally (point-by-point).
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearGeometryBuilder.#ctor(MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            
            </summary>
            <param name="geomFact"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearGeometryBuilder.Add(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Adds a point to the current line.
            </summary>
            <param name="pt">The <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> to add.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearGeometryBuilder.Add(MapWindow.Interfaces.Geometries.ICoordinate,System.Boolean)">
            <summary>
            Adds a point to the current line.
            </summary>
            <param name="pt">The <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> to add.</param>
            <param name="allowRepeatedPoints">If <c>true</c>, allows the insertions of repeated points.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearGeometryBuilder.EndLine">
            <summary>
            Terminate the current <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.LineString"/>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearGeometryBuilder.ValidCoordinateSequence(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[])">
            <summary>
            
            </summary>
            <param name="pts"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearGeometryBuilder.GetGeometry">
            <summary>
            Builds and returns the <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearGeometryBuilder.FixInvalidLines">
            <summary>
            Allows invalid lines to be fixed rather than causing Exceptions.
            An invalid line is one which has only one unique point.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearGeometryBuilder.IgnoreInvalidLines">
            <summary>
            Allows invalid lines to be ignored rather than causing Exceptions.
            An invalid line is one which has only one unique point.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearGeometryBuilder.LastCoordinate">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.BEBinaryWriter">
            <summary>
            Extends the <see cref="T:System.IO.BinaryWriter"/> class to allow writing values in the BigEndian format.    
            </summary>
            <remarks>
            While <see cref="T:MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryWriter"/> extends <see cref="T:System.IO.BinaryWriter"/> 
            adding methods for writing integer values (<see cref="M:MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryWriter.WriteIntBE(System.Int32)"/>)
            and double values (<see cref="M:MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryWriter.WriteDoubleBE(System.Double)"/>) in the BigEndian format,
            this implementation overrides methods, such <see cref="M:System.IO.BinaryWriter.Write(System.Int32)"/> 
            and <see cref="M:System.IO.BinaryWriter.Write(System.Double)"/> and more, 
            for writing <see cref="T:ByteOrder.BigEndian"/> values in the BigEndian format.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryWriter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BEBinaryWriter"/> class.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryWriter.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:BEBinaryWriter"/> class.
            </summary>
            <param name="output">The supplied stream.</param>
            <exception cref="T:System.ArgumentNullException">output is null. </exception>
            <exception cref="T:System.ArgumentException">
            The stream does not support writing, or the stream is already closed. </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryWriter.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Initializes a new instance of the <see cref="T:BEBinaryWriter"/> class.
            </summary>
            <param name="output">The supplied stream.</param>
            <param name="encoding">The character encoding.</param>
            <exception cref="T:System.ArgumentNullException">output or encoding is null. </exception>
            <exception cref="T:System.ArgumentException">
            The stream does not support writing, or the stream is already closed. </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryWriter.Write(System.Int16)">
            <summary>
            Writes a two-byte signed integer to the current stream using BigEndian encoding
            and advances the stream position by two bytes.
            </summary>
            <param name="value">The two-byte signed integer to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryWriter.Write(System.UInt16)">
            <summary>
            Writes a two-byte unsigned integer to the current stream  using BigEndian encoding
            and advances the stream position by two bytes.
            </summary>
            <param name="value">The two-byte unsigned integer to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryWriter.Write(System.Int32)">
            <summary>
            Writes a four-byte signed integer to the current stream using BigEndian encoding
            and advances the stream position by four bytes.
            </summary>
            <param name="value">The four-byte signed integer to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryWriter.Write(System.UInt32)">
            <summary>
            Writes a four-byte unsigned integer to the current stream using BigEndian encoding
            and advances the stream position by four bytes.
            </summary>
            <param name="value">The four-byte unsigned integer to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryWriter.Write(System.Int64)">
            <summary>
            Writes an eight-byte signed integer to the current stream using BigEndian encoding
            and advances the stream position by eight bytes.
            </summary>
            <param name="value">The eight-byte signed integer to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryWriter.Write(System.UInt64)">
            <summary>
            Writes an eight-byte unsigned integer to the current stream using BigEndian encoding
            and advances the stream position by eight bytes.
            </summary>
            <param name="value">The eight-byte unsigned integer to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryWriter.Write(System.Single)">
            <summary>
            Writes a four-byte floating-point value to the current stream using BigEndian encoding
            and advances the stream position by four bytes.
            </summary>
            <param name="value">The four-byte floating-point value to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryWriter.Write(System.Double)">
            <summary>
            Writes an eight-byte floating-point value to the current stream using BigEndian encoding
            and advances the stream position by eight bytes.
            </summary>
            <param name="value">The eight-byte floating-point value to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryWriter.Write(System.String)">
            <summary>
            Writes a length-prefixed string to this stream in the current encoding 
            of the <see cref="T:System.IO.BinaryWriter"></see>, 
            and advances the current position of the stream in accordance 
            with the encoding used and the specific characters being written to the stream.
            </summary>
            <param name="value">The value to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.ArgumentNullException">value is null. </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryWriter.Write(System.Decimal)">
            <summary>
            Writes a decimal value to the current stream and advances the stream position by sixteen bytes.
            </summary>
            <param name="value">The decimal value to write.</param>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.BEBinaryReader">
            <summary>
            Extends the <see cref="T:System.IO.BinaryReader"/> class to allow reading values in the BigEndian format.    
            </summary>
            <remarks>
            While <see cref="T:MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryReader"/> extends <see cref="T:System.IO.BinaryReader"/> 
            adding methods for reading integer values (<see cref="M:MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryReader.ReadInt32BE"/>)
            and double values (<see cref="M:MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryReader.ReadDoubleBE"/>) in the BigEndian format, 
            this implementation overrides methods, such <see cref="M:System.IO.BinaryReader.ReadInt32"/> 
            and <see cref="M:System.IO.BinaryReader.ReadDouble"/> and more, 
            for reading <see cref="T:ByteOrder.BigEndian"/> values in the BigEndian format.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryReader.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:BEBinaryReader"/> class.
            </summary>
            <param name="stream">The stream.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryReader.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Initializes a new instance of the <see cref="T:BEBinaryReader"/> class.
            </summary>
            <param name="input">The supplied stream.</param>
            <param name="encoding">The character encoding.</param>
            <exception cref="T:System.ArgumentNullException">encoding is null. </exception>
            <exception cref="T:System.ArgumentException">The stream does not support reading, the stream is null, or the stream is already closed. </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryReader.ReadInt16">
            <summary>
            Reads a 2-byte signed integer from the current stream using big endian encoding
            and advances the current position of the stream by two bytes.
            </summary>
            <returns>
            A 2-byte signed integer read from the current stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryReader.ReadUInt16">
            <summary>
            Reads a 2-byte unsigned integer from the current stream using big endian encoding 
            and advances the position of the stream by two bytes.
            </summary>
            <returns>
            A 2-byte unsigned integer read from this stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryReader.ReadInt32">
            <summary>
            Reads a 4-byte signed integer from the current stream using big endian encoding
            and advances the current position of the stream by four bytes.
            </summary>
            <returns>
            A 4-byte signed integer read from the current stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryReader.ReadUInt32">
            <summary>
            Reads a 4-byte unsigned integer from the current stream using big endian encoding
            and advances the position of the stream by four bytes.
            </summary>
            <returns>
            A 4-byte unsigned integer read from this stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryReader.ReadInt64">
            <summary>
            Reads an 8-byte signed integer from the current stream using big endian encoding
            and advances the current position of the stream by eight bytes.
            </summary>
            <returns>
            An 8-byte signed integer read from the current stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryReader.ReadUInt64">
            <summary>
            Reads an 8-byte unsigned integer from the current stream using big endian encoding 
            and advances the position of the stream by eight bytes.
            </summary>
            <returns>
            An 8-byte unsigned integer read from this stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryReader.ReadSingle">
            <summary>
            Reads a 4-byte floating point value from the current stream using big endian encoding
            and advances the current position of the stream by four bytes.
            </summary>
            <returns>
            A 4-byte floating point value read from the current stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryReader.ReadDouble">
            <summary>
            Reads an 8-byte floating point value from the current stream using big endian encoding
            and advances the current position of the stream by eight bytes.
            </summary>
            <returns>
            An 8-byte floating point value read from the current stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryReader.ReadString">
            <summary>
            Reads a string from the current stream. 
            The string is prefixed with the length, encoded as an integer seven bits at a time.
            </summary>
            <returns>The string being read.</returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BEBinaryReader.ReadDecimal">
            <summary>
            Reads a decimal value from the current stream 
            and advances the current position of the stream by sixteen bytes.
            </summary>
            <returns>
            A decimal value read from the current stream.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
            <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.Point">
            <summary>
            Basic implementation of <c>Point</c>.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry">
            <summary>  
            Basic implementation of <c>Geometry</c>.
            <c>Clone</c> returns a deep copy of the object.
            <para>
            Binary Predicates: 
            Because it is not clear at this time what semantics for spatial
            analysis methods involving <c>GeometryCollection</c>s would be useful,
            <c>GeometryCollection</c>s are not supported as arguments to binary
            predicates (other than <c>ConvexHull</c>) or the <c>Relate</c> method.
            </para>
            <para>
            Set-Theoretic Methods: 
            The spatial analysis methods will
            return the most specific class possible to represent the result. If the
            result is homogeneous, a <c>Point</c>, <c>LineString</c>, or
            <c>Polygon</c> will be returned if the result contains a single
            element; otherwise, a <c>MultiPoint</c>, <c>MultiLineString</c>,
            or <c>MultiPolygon</c> will be returned. If the result is
            heterogeneous a <c>GeometryCollection</c> will be returned.
            </para>
            <para>
            Representation of Computed Geometries:  
            The SFS states that the result
            of a set-theoretic method is the "point-set" result of the usual
            set-theoretic definition of the operation (SFS 3.2.21.1). However, there are
            sometimes many ways of representing a point set as a <c>Geometry</c>.
            The SFS does not specify an unambiguous representation of a given point set
            returned from a spatial analysis method. One goal of NTS is to make this
            specification precise and unambiguous. NTS will use a canonical form for
            <c>Geometry</c>s returned from spatial analysis methods. The canonical
            form is a <c>Geometry</c> which is simple and noded:
            Simple means that the Geometry returned will be simple according to
            the NTS definition of <c>IsSimple</c>.
            Noded applies only to overlays involving <c>LineString</c>s. It
            means that all intersection points on <c>LineString</c>s will be
            present as endpoints of <c>LineString</c>s in the result.
            This definition implies that non-simple geometries which are arguments to
            spatial analysis methods must be subjected to a line-dissolve process to
            ensure that the results are simple.
            </para>
            <para>
            Constructed Points And The Precision Model: 
            The results computed by the set-theoretic methods may
            contain constructed points which are not present in the input <c>Geometry</c>
            s. These new points arise from intersections between line segments in the
            edges of the input <c>Geometry</c>s. In the general case it is not
            possible to represent constructed points exactly. This is due to the fact
            that the coordinates of an intersection point may contain twice as many bits
            of precision as the coordinates of the input line segments. In order to
            represent these constructed points explicitly, NTS must truncate them to fit
            the <c>PrecisionModel</c>. 
            Unfortunately, truncating coordinates moves them slightly. Line segments
            which would not be coincident in the exact result may become coincident in
            the truncated representation. This in turn leads to "topology collapses" --
            situations where a computed element has a lower dimension than it would in
            the exact result. 
            When NTS detects topology collapses during the computation of spatial
            analysis methods, it will throw an exception. If possible the exception will
            report the location of the collapse. 
            </para>
            </summary>
            <remarks>
            <see cref="M:System.Object.Equals(System.Object)"/> and <see cref="M:System.Object.GetHashCode"/> are not overridden, so that when two
            topologically equal Geometries are added to Collections and Dictionaries, they
            remain distinct. This behaviour is desired in many cases.
            </remarks>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.Geometry.SortedClasses">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.Geometry.envelope">
            <summary>
            The bounding box of this <c>Geometry</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.#ctor(MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            
            </summary>
            <param name="factory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.HasNonEmptyElements(MapWindow.Interfaces.Geometries.IGeometry[])">
            <summary>  
            Returns true if the array contains any non-empty <c>Geometry</c>s.
            </summary>
            <param name="geometries"> an array of <c>Geometry</c>s; no elements may be <c>null</c></param>
            <returns>            
            <c>true</c> if any of the <c>Geometry</c>s
            <c>IsEmpty</c> methods return <c>false</c>.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.HasNullElements(System.Object[])">
            <summary>  
            Returns true if the array contains any <c>null</c> elements.
            </summary>
            <param name="array"> an array to validate.</param>
            <returns><c>true</c> if any of <c>array</c>s elements are <c>null</c>.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.GetGeometryN(System.Int32)">
            <summary>
            Returns an element Geometry from a GeometryCollection,
            or <code>this</code>, if the geometry is not a collection.
            </summary>
            <param name="n">The index of the geometry element.</param>
            <returns>The n'th geometry contained in this geometry.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Distance(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>  
            Returns the minimum distance between this <c>Geometry</c>
            and the <c>Geometry</c> g.
            </summary>
            <param name="g">The <c>Geometry</c> from which to compute the distance.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.IsWithinDistance(MapWindow.Interfaces.Geometries.IGeometry,System.Double)">
            <summary> 
            Tests whether the distance from this <c>Geometry</c>
            to another is less than or equal to a specified value.
            </summary>
            <param name="geom">the Geometry to check the distance to.</param>
            <param name="distance">the distance value to compare.</param>
            <returns><c>true</c> if the geometries are less than <c>distance</c> apart.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.GeometryChanged">
            <summary>
            Notifies this Geometry that its Coordinates have been changed by an external
            party (using a CoordinateFilter, for example). The Geometry will flush
            and/or update any information it has cached (such as its Envelope).
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.GeometryChangedAction">
            <summary> 
            Notifies this Geometry that its Coordinates have been changed by an external
            party. When GeometryChanged is called, this method will be called for
            this Geometry and its component Geometries.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Disjoint(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>  
            Returns <c>true</c> if the DE-9IM intersection matrix for the two
            <c>Geometry</c>s is FF*FF****.
            </summary>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns><c>true</c> if the two <c>Geometry</c>s are disjoint.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Touches(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>  
            Returns <c>true</c> if the DE-9IM intersection matrix for the two
            <c>Geometry</c>s is FT*******, F**T***** or F***T****.
            </summary>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>s touch;
            Returns false if both <c>Geometry</c>s are points.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Intersects(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>  
            Returns <c>true</c> if <c>disjoint</c> returns false.
            </summary>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns><c>true</c> if the two <c>Geometry</c>s intersect.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Crosses(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>  
            Returns <c>true</c> if the DE-9IM intersection matrix for the two
            <c>Geometry</c>s is
             T*T****** (for a point and a curve, a point and an area or a line
            and an area) 0******** (for two curves).
            </summary>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>s cross.
            For this function to return <c>true</c>, the <c>Geometry</c>
            s must be a point and a curve; a point and a surface; two curves; or a
            curve and a surface.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Within(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Returns <c>true</c> if the DE-9IM intersection matrix for the two
            <c>Geometry</c>s is T*F**F***.
            </summary>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns><c>true</c> if this <c>Geometry</c> is within <c>other</c>.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Overlaps(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Returns <c>true</c> if the DE-9IM intersection matrix for the two
            <c>Geometry</c>s is
             T*T***T** (for two points or two surfaces)
             1*T***T** (for two curves).
            </summary>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if the two <c>Geometry</c>s overlap.
            For this function to return <c>true</c>, the <c>Geometry</c>
            s must be two points, two curves or two surfaces.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Covers(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Returns <c>true</c> if this geometry covers the specified geometry.
            <para>
            The <c>Covers</c> predicate has the following equivalent definitions:
                - Every point of the other geometry is a point of this geometry.
                - The DE-9IM Intersection Matrix for the two geometries is <c>T*****FF*</c> or <c>*T****FF*</c> or <c>***T**FF*</c> or <c>****T*FF*</c>.
                - <c>g.CoveredBy(this)</c> (<c>Covers</c> is the inverse of <c>CoveredBy</c>).
            </para>
            Note the difference between <c>Covers</c> and <c>Contains</c>: <c>Covers</c> is a more inclusive relation.
            In particular, unlike <c>Contains</c> it does not distinguish between
            points in the boundary and in the interior of geometries.        
            </summary>
            <remarks>
            For most situations, <c>Covers</c> should be used in preference to <c>Contains</c>.
            As an added benefit, <c>Covers</c> is more amenable to optimization, and hence should be more performant.
            </remarks>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <returns><c>true</c> if this <c>Geometry</c> covers <paramref name="g"/></returns>
            <seealso cref="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Contains(MapWindow.Interfaces.Geometries.IGeometry)"/>
            <seealso cref="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.CoveredBy(MapWindow.Interfaces.Geometries.IGeometry)"/>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.CoveredBy(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Returns <c>true</c> if this geometry is covered by the specified geometry.
            <para>
            The <c>CoveredBy</c> predicate has the following equivalent definitions:
                - Every point of this geometry is a point of the other geometry.
                - The DE-9IM Intersection Matrix for the two geometries is <c>T*F**F***</c> or <c>*TF**F***</c> or <c>**FT*F***</c> or <c>**F*TF***</c>.
                - <c>g.Covers(this)</c> (<c>CoveredBy</c> is the inverse of <c>Covers</c>).
            </para>
            Note the difference between <c>CoveredBy</c> and <c>Within</c>: <c>CoveredBy</c> is a more inclusive relation.
            </summary>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c></param>.
            <returns><c>true</c> if this <c>Geometry</c> is covered by <paramref name="g"/>.</returns>
            <seealso cref="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Within(MapWindow.Interfaces.Geometries.IGeometry)"/>
            <seealso cref="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Covers(MapWindow.Interfaces.Geometries.IGeometry)"/>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Relate(MapWindow.Interfaces.Geometries.IGeometry,System.String)">
            <summary>  
            Returns <c>true</c> if the elements in the DE-9IM intersection
            matrix for the two <c>Geometry</c>s match the elements in <c>intersectionPattern</c>
            , which may be:
             0
             1
             2
             T ( = 0, 1 or 2)
             F ( = -1)
             * ( = -1, 0, 1 or 2)
            For more information on the DE-9IM, see the OpenGIS Simple Features
            Specification.
            </summary>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <param name="intersectionPattern">The pattern against which to check the intersection matrix for the two <c>Geometry</c>s.</param>
            <returns><c>true</c> if the DE-9IM intersection matrix for the two <c>Geometry</c>s match <c>intersectionPattern</c>.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Relate(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Returns the DE-9IM intersection matrix for the two <c>Geometry</c>s.
            </summary>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <returns>
            A matrix describing the intersections of the interiors,
            boundaries and exteriors of the two <c>Geometry</c>s.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Equals(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Returns <c>true</c> if the DE-9IM intersection matrix for the two
            <c>Geometry</c>s is T*F**FFF*.
            </summary>
            <param name="g">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns><c>true</c> if the two <c>Geometry</c>s are equal.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.ToString">
            <summary>
            Returns the Well-known Text representation of this <c>Geometry</c>.
            For a definition of the Well-known Text format, see the OpenGIS Simple
            Features Specification.
            </summary>
            <returns>
            The Well-known Text representation of this <c>Geometry</c>.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.ToText">
            <summary>
            Returns the Well-known Text representation of this <c>Geometry</c>.
            For a definition of the Well-known Text format, see the OpenGIS Simple
            Features Specification.
            </summary>
            <returns>
            The Well-known Text representation of this <c>Geometry</c>.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.ToBinary">
            <summary>
            Returns the Well-known Binary representation of this <c>Geometry</c>.
            For a definition of the Well-known Binary format, see the OpenGIS Simple
            Features Specification.
            </summary>
            <returns>The Well-known Binary representation of this <c>Geometry</c>.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.ToGMLFeature">
            <summary>
            Returns the feature representation as GML 2.1.1 XML document.
            This XML document is based on <c>Geometry.xsd</c> schema.
            NO features or XLink are implemented here!
            </summary>        
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.ExportToGML">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.ConvexHull">
            <summary>
            Returns the smallest convex <c>Polygon</c> that contains all the
            points in the <c>Geometry</c>. This obviously applies only to <c>Geometry</c>
            s which contain 3 or more points.
            </summary>
            <returns>the minimum-area convex polygon containing this <c>Geometry</c>'s points.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Intersection(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Returns a <c>Geometry</c> representing the points shared by this
            <c>Geometry</c> and <c>other</c>.
            </summary>
            <param name="other">The <c>Geometry</c> with which to compute the intersection.</param>
            <returns>The points common to the two <c>Geometry</c>s.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Union(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Returns a <c>Geometry</c> representing all the points in this <c>Geometry</c>
            and <c>other</c>.
            </summary>
            <param name="other">The <c>Geometry</c> with which to compute the union.</param>
            <returns>A set combining the points of this <c>Geometry</c> and the points of <c>other</c>.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Difference(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Returns a <c>Geometry</c> representing the points making up this
            <c>Geometry</c> that do not make up <c>other</c>. This method
            returns the closure of the resultant <c>Geometry</c>.
            </summary>
            <param name="other">The <c>Geometry</c> with which to compute the difference.</param>
            <returns>The point set difference of this <c>Geometry</c> with <c>other</c>.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.SymmetricDifference(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Returns a set combining the points in this <c>Geometry</c> not in
            <c>other</c>, and the points in <c>other</c> not in this
            <c>Geometry</c>. This method returns the closure of the resultant
            <c>Geometry</c>.
            </summary>
            <param name="other">The <c>Geometry</c> with which to compute the symmetric difference.</param>
            <returns>The point set symmetric difference of this <c>Geometry</c> with <c>other</c>.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.EqualsExact(MapWindow.Interfaces.Geometries.IGeometry,System.Double)">
            <summary>
            Returns true if the two <c>Geometry</c>s are exactly equal,
            up to a specified tolerance.
            Two Geometries are exactly within a tolerance equal iff:
            they have the same class,
            they have the same values of Coordinates,
            within the given tolerance distance, in their internal
            Coordinate lists, in exactly the same order.
            If this and the other <c>Geometry</c>s are
            composites and any children are not <c>Geometry</c>s, returns
            false.
            </summary>
            <param name="other">The <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <param name="tolerance">Distance at or below which two Coordinates will be considered equal.</param>
            <returns>
            <c>true</c> if this and the other <c>Geometry</c>
            are of the same class and have equal internal data.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.EqualsExact(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Returns true if the two <c>Geometry</c>s are exactly equal.
            Two Geometries are exactly equal iff:
            they have the same class,
            they have the same values of Coordinates in their internal
            Coordinate lists, in exactly the same order.
            If this and the other <c>Geometry</c>s are
            composites and any children are not <c>Geometry</c>s, returns
            false.
            This provides a stricter test of equality than <c>equals</c>.
            </summary>
            <param name="other">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns>
            <c>true</c> if this and the other <c>Geometry</c>
            are of the same class and have equal internal data.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Apply(MapWindow.Interfaces.Geometries.ICoordinateFilter)">
            <summary>
            Performs an operation with or on this <c>Geometry</c>'s
            coordinates. If you are using this method to modify the point, be sure
            to call GeometryChanged() afterwards. Note that you cannot use this
            method to
            modify this Geometry if its underlying CoordinateSequence's Get method
            returns a copy of the Coordinate, rather than the actual Coordinate stored
            (if it even stores Coordinates at all).
            </summary>
            <param name="filter">The filter to apply to this <c>Geometry</c>'s coordinates</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Apply(MapWindow.Interfaces.Geometries.IGeometryFilter)">
            <summary>
            Performs an operation with or on this <c>Geometry</c> and its
            subelement <c>Geometry</c>s (if any).
            Only GeometryCollections and subclasses
            have subelement Geometry's.
            </summary>
            <param name="filter">
            The filter to apply to this <c>Geometry</c> (and
            its children, if it is a <c>GeometryCollection</c>).
            </param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Apply(MapWindow.Interfaces.Geometries.IGeometryComponentFilter)">
            <summary>
            Performs an operation with or on this Geometry and its
            component Geometry's. Only GeometryCollections and
            Polygons have component Geometry's; for Polygons they are the LinearRings
            of the shell and holes.
            </summary>
            <param name="filter">The filter to apply to this <c>Geometry</c>.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Normalize">
            <summary>
            Converts this <c>Geometry</c> to normal form (or 
            canonical form ). Normal form is a unique representation for <c>Geometry</c>
            s. It can be used to test whether two <c>Geometry</c>s are equal
            in a way that is independent of the ordering of the coordinates within
            them. Normal form equality is a stronger condition than topological
            equality, but weaker than pointwise equality. The definitions for normal
            form use the standard lexicographical ordering for coordinates. "Sorted in
            order of coordinates" means the obvious extension of this ordering to
            sequences of coordinates.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.CompareTo(System.Object)">
            <summary>
            Returns whether this <c>Geometry</c> is greater than, equal to,
            or less than another <c>Geometry</c>. 
            If their classes are different, they are compared using the following
            ordering:
                Point (lowest),
                MultiPoint,
                LineString,
                LinearRing,
                MultiLineString,
                Polygon,
                MultiPolygon,
                GeometryCollection (highest).
            If the two <c>Geometry</c>s have the same class, their first
            elements are compared. If those are the same, the second elements are
            compared, etc.
            </summary>
            <param name="o">A <c>Geometry</c> with which to compare this <c>Geometry</c></param>
            <returns>
            A positive number, 0, or a negative number, depending on whether
            this object is greater than, equal to, or less than <c>o</c>, as
            defined in "Normal Form For Geometry" in the NTS Technical
            Specifications.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.IsEquivalentClass(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Returns whether the two <c>Geometry</c>s are equal, from the point
            of view of the <c>EqualsExact</c> method. Called by <c>EqualsExact</c>
            . In general, two <c>Geometry</c> classes are considered to be
            "equivalent" only if they are the same class. An exception is <c>LineString</c>
            , which is considered to be equivalent to its subclasses.
            </summary>
            <param name="other">The <c>Geometry</c> with which to compare this <c>Geometry</c> for equality.</param>
            <returns>
            <c>true</c> if the classes of the two <c>Geometry</c>
            s are considered to be equal by the <c>equalsExact</c> method.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.CheckNotGeometryCollection(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Throws an exception if <c>g</c>'s class is <c>GeometryCollection</c>. 
            (Its subclasses do not trigger an exception).
            </summary>
            <param name="g">
            The <c>Geometry</c> to check;
            throws  ArgumentException  if <c>g</c> is a <c>GeometryCollection</c>
            but not one of its subclasses.
            </param>        
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.ComputeEnvelopeInternal">
            <summary>
            Returns the minimum and maximum x and y values in this <c>Geometry</c>
            , or a null <c>Envelope</c> if this <c>Geometry</c> is empty.
            Unlike <c>EnvelopeInternal</c>, this method calculates the <c>Envelope</c>
            each time it is called; <c>EnvelopeInternal</c> caches the result
            of this method.        
            </summary>
            <returns>
            This <c>Geometry</c>s bounding box; if the <c>Geometry</c>
            is empty, <c>Envelope.IsNull</c> will return <c>true</c>.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.CompareToSameClass(System.Object)">
            <summary>
            Returns whether this <c>Geometry</c> is greater than, equal to,
            or less than another <c>Geometry</c> having the same class.
            </summary>
            <param name="o">A <c>Geometry</c> having the same class as this <c>Geometry</c>.</param>
            <returns>
            A positive number, 0, or a negative number, depending on whether
            this object is greater than, equal to, or less than <c>o</c>, as
            defined in "Normal Form For Geometry" in the NTS Technical
            Specifications.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Compare(System.Collections.ArrayList,System.Collections.ArrayList)">
            <summary>
            Returns the first non-zero result of <c>CompareTo</c> encountered as
            the two <c>Collection</c>s are iterated over. If, by the time one of
            the iterations is complete, no non-zero result has been encountered,
            returns 0 if the other iteration is also complete. If <c>b</c>
            completes before <c>a</c>, a positive number is returned; if a
            before b, a negative number.
            </summary>
            <param name="a">A <c>Collection</c> of <c>IComparable</c>s.</param>
            <param name="b">A <c>Collection</c> of <c>IComparable</c>s.</param>
            <returns>The first non-zero <c>compareTo</c> result, if any; otherwise, zero.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Equal(MapWinGeoProc.NTS.Topology.Geometries.Coordinate,MapWindow.Interfaces.Geometries.ICoordinate,System.Double)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="tolerance"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.CreatePointFromInternalCoord(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="coord"></param>
            <param name="exemplar"></param>
            <returns></returns>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.Geometry.DefaultFactory">
            <summary>
            A predefined <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory"/> with <see cref="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.PrecisionModel"/> <c> == </c> <see cref="F:MapWindow.Interfaces.Geometries.PrecisionModels.Fixed"/>.
            </summary>
            <seealso cref="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.Default"/>
            <seealso cref="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.Fixed"/>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Buffer(System.Double,System.Int32,MapWindow.Interfaces.Geometries.BufferStyles)">
            <summary>
            Returns a buffer region around this <c>Geometry</c> having the given
            width and with a specified number of segments used to approximate curves.
            The buffer of a Geometry is the Minkowski sum of the Geometry with
            a disc of radius <c>distance</c>.  Curves in the buffer polygon are
            approximated with line segments.  This method allows specifying the
            accuracy of that approximation.
            </summary>
            <param name="distance">
            The width of the buffer, interpreted according to the
            <c>PrecisionModel</c> of the <c>Geometry</c>.
            </param>
            <param name="quadrantSegments">The number of segments to use to approximate a quadrant of a circle.</param>
            <param name="endCapStyle">Cap Style to use for compute buffer.</param>
            <returns>
            All points whose distance from this <c>Geometry</c>
            are less than or equal to <c>distance</c>.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Buffer(System.Double,System.Int32)">
            <summary>
            Returns a buffer region around this <c>Geometry</c> having the given
            width and with a specified number of segments used to approximate curves.
            The buffer of a Geometry is the Minkowski sum of the Geometry with
            a disc of radius <c>distance</c>.  Curves in the buffer polygon are
            approximated with line segments.  This method allows specifying the
            accuracy of that approximation.
            </summary>
            <param name="distance">
            The width of the buffer, interpreted according to the
            <c>PrecisionModel</c> of the <c>Geometry</c>.
            </param>
            <param name="quadrantSegments">The number of segments to use to approximate a quadrant of a circle.</param>
            <returns>
            All points whose distance from this <c>Geometry</c>
            are less than or equal to <c>distance</c>.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Buffer(System.Double,MapWindow.Interfaces.Geometries.BufferStyles)">
            <summary>
            Returns a buffer region around this <c>Geometry</c> having the given width.
            The buffer of a Geometry is the Minkowski sum or difference of the Geometry with a disc of radius <c>distance</c>.
            </summary>
            <param name="distance">
            The width of the buffer, interpreted according to the
            <c>PrecisionModel</c> of the <c>Geometry</c>.
            </param>
            <param name="endCapStyle">Cap Style to use for compute buffer.</param>
            <returns>
            All points whose distance from this <c>Geometry</c>
            are less than or equal to <c>distance</c>.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Buffer(System.Double)">
            <summary>
            Returns a buffer region around this <c>Geometry</c> having the given width.
            The buffer of a Geometry is the Minkowski sum or difference of the Geometry with a disc of radius <c>distance</c>.
            </summary>
            <param name="distance">
            The width of the buffer, interpreted according to the
            <c>PrecisionModel</c> of the <c>Geometry</c>.
            </param>
            <returns>
            All points whose distance from this <c>Geometry</c>
            are less than or equal to <c>distance</c>.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Contains(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Returns <c>true</c> if <c>other.within(this)</c> returns <c>true</c>.
            </summary>
            <param name="geom">The <c>Geometry</c> with which to compare this <c>Geometry</c>.</param>
            <returns><c>true</c> if this <c>Geometry</c> contains <c>other</c>.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Intersects(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            Tests whetehr this geometry intersects with an envelope
            </summary>
            <param name="env">The IEnvelope to test</param>
            <returns>The intersection between this geometry and the envelope</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Intersects(System.Double,System.Double)">
            <summary>
            Intersection between a point specified by double x and y values
            </summary>
            <param name="x">double, specifies the x coordinate of a point</param>
            <param name="y">double, specifies the y coordinate of a point</param>
            <returns>Boolean, true if the point intersects with this geometry</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Factory">
            <summary> 
            Gets the factory which contains the context in which this point was created.
            </summary>
            <returns>The factory for this point.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.UserData">
            <summary> 
            Gets/Sets the user data object for this point, if any.
            A simple scheme for applications to add their own custom data to a Geometry.
            An example use might be to add an object representing a Coordinate Reference System.
            Note that user data objects are not present in geometries created by
            construction methods.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.SRID">
            <summary>  
            Gets/Sets the ID of the Spatial Reference System used by the <c>Geometry</c>. 
            NTS supports Spatial Reference System information in the simple way
            defined in the SFS. A Spatial Reference System ID (SRID) is present in
            each <c>Geometry</c> object. <c>Geometry</c> provides basic
            accessor operations for this field, but no others. The SRID is represented
            as an integer.
            </summary>        
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.GeometryType">
            <summary>
            Clarifies which subtype of geometry we are working with
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.PrecisionModel">
            <summary>  
            Returns the <c>PrecisionModel</c> used by the <c>Geometry</c>.
            </summary>
            <returns>    
            the specification of the grid of allowable points, for this
            <c>Geometry</c> and all other <c>Geometry</c>s.
            </returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Coordinate">
            <summary>  
            Returns a vertex of this <c>Geometry</c>.
            </summary>
            <returns>    
            a Coordinate which is a vertex of this <c>Geometry</c>.
            Returns <c>null</c> if this Geometry is empty.
            </returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Coordinates">
            <summary>  
            Returns this <c>Geometry</c> s vertices. If you modify the coordinates
            in this array, be sure to call GeometryChanged afterwards.
            The <c>Geometry</c>s contained by composite <c>Geometry</c>s
            must be Geometry's; that is, they must implement <c>Coordinates</c>.
            </summary>
            <returns>The vertices of this <c>Geometry</c>.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.NumPoints">
            <summary>  
            Returns the count of this <c>Geometry</c>s vertices. The <c>Geometry</c>
            s contained by composite <c>Geometry</c>s must be
            Geometry's; that is, they must implement <c>NumPoints</c>.
            </summary>
            <returns>The number of vertices in this <c>Geometry</c>.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.NumGeometries">
            <summary>
            Returns the number of Geometryes in a GeometryCollection,
            or 1, if the geometry is not a collection.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.IsSimple">
            <summary> 
            Returns false if the <c>Geometry</c> not simple.
            Subclasses provide their own definition of "simple". If
            this <c>Geometry</c> is empty, returns <c>true</c>. 
            In general, the SFS specifications of simplicity seem to follow the
            following rule:
             A Geometry is simple if the only self-intersections are at boundary points.
            For all empty <c>Geometry</c>s, <c>IsSimple==true</c>.
            </summary>
            <returns>    
            <c>true</c> if this <c>Geometry</c> has any points of
            self-tangency, self-intersection or other anomalous points.
            </returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.IsValid">
            <summary>  
            Tests the validity of this <c>Geometry</c>.
            Subclasses provide their own definition of "valid".
            </summary>
            <returns><c>true</c> if this <c>Geometry</c> is valid.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.IsEmpty">
            <summary> 
            Returns whether or not the set of points in this <c>Geometry</c> is empty.
            </summary>
            <returns><c>true</c> if this <c>Geometry</c> equals the empty point.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Area">
            <summary>  
            Returns the area of this <c>Geometry</c>.
            Areal Geometries have a non-zero area.
            They override this function to compute the area.
            Others return 0.0
            </summary>
            <returns>The area of the Geometry.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Length">
            <summary> 
            Returns the length of this <c>Geometry</c>.
            Linear geometries return their length.
            Areal geometries return their perimeter.
            They override this function to compute the length.
            Others return 0.0
            </summary>
            <returns>The length of the Geometry.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.InteriorPoint">
            <summary>
            Computes an interior point of this <c>Geometry</c>.
            An interior point is guaranteed to lie in the interior of the Geometry,
            if it possible to calculate such a point exactly. Otherwise,
            the point may lie on the boundary of the point.
            </summary>
            <returns>A <c>Point</c> which is in the interior of this Geometry.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Dimension">
            <summary> 
            Returns the dimension of this <c>Geometry</c>.
            </summary>
            <returns>  
            The dimension of the class implementing this interface, whether
            or not this object is the empty point.
            </returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.BoundaryDimension">
            <summary> 
            Returns the dimension of this <c>Geometry</c>s inherent boundary.
            </summary>
            <returns>    
            The dimension of the boundary of the class implementing this
            interface, whether or not this object is the empty point. Returns
            <c>Dimension.False</c> if the boundary is the empty point.
            </returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.EnvelopeAsGeometry">
            <summary>  
            Returns this <c>Geometry</c>s bounding box. If this <c>Geometry</c>
            is the empty point, returns an empty <c>Point</c>. If the <c>Geometry</c>
            is a point, returns a non-empty <c>Point</c>. Otherwise, returns a
            <c>Polygon</c> whose points are (minx, miny), (maxx, miny), (maxx,
            maxy), (minx, maxy), (minx, miny).
            </summary>
            <returns>    
            An empty <c>Point</c> (for empty <c>Geometry</c>s), a
            <c>Point</c> (for <c>Point</c>s) or a <c>Polygon</c>
            (in all other cases).
            </returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.EnvelopeInternal">
            <summary> 
            Returns the minimum and maximum x and y values in this <c>Geometry</c>
            , or a null <c>Envelope</c> if this <c>Geometry</c> is empty.
            </summary>
            <returns>    
            This <c>Geometry</c>s bounding box; if the <c>Geometry</c>
            is empty, <c>Envelope.IsNull</c> will return <c>true</c>.
            </returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.ClassSortIndex">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.IsRectangle">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Boundary">
            <summary>  
            Returns the boundary, or the empty point if this <c>Geometry</c>
            is empty. For a discussion of this function, see the OpenGIS Simple
            Features Specification. As stated in SFS Section 2.1.13.1, "the boundary
            of a Geometry is a set of Geometries of the next lower dimension."
            </summary>
            <returns>The closure of the combinatorial boundary of this <c>Geometry</c>.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Centroid">
            <summary> 
            Computes the centroid of this <c>Geometry</c>.
            The centroid is equal to the centroid of the set of component Geometries of highest
            dimension (since the lower-dimension geometries contribute zero "weight" to the centroid).
            </summary>
            <returns>A Point which is the centroid of this Geometry.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.Envelope">
            <summary>
            Returns an IEnvelope
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Geometry.BaseCoordinates">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.Point.Empty">
            <summary>
            Represents an empty <c>Point</c>.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.Point.coordinates">
            <summary>  
            The <c>Coordinate</c> wrapped by this <c>Point</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Point.#ctor(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Initializes a new instance of the <see cref="T:Point"/> class.
            </summary>
            <param name="coordinate">The coordinate used for create this <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Point"/>.</param>
            <remarks>
            For create this <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/> is used a standard <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory"/> 
            with <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel"/> <c> == </c> <see cref="F:MapWindow.Interfaces.Geometries.PrecisionModels.Floating"/>.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Point.#ctor(MapWindow.Interfaces.Geometries.ICoordinateSequence,MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory)">
            <summary>
            Constructs a <c>Point</c> with the given coordinate.
            </summary>
            <param name="coordinates">
            Contains the single coordinate on which to base this <c>Point</c>,
            or <c>null</c> to create the empty point.
            </param>
            <param name="factory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Point.ComputeEnvelopeInternal">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Point.EqualsExact(MapWindow.Interfaces.Geometries.IGeometry,System.Double)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <param name="tolerance"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Point.Apply(MapWindow.Interfaces.Geometries.ICoordinateFilter)">
            <summary>
            
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Point.Apply(MapWindow.Interfaces.Geometries.IGeometryFilter)">
            <summary>
            
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Point.Apply(MapWindow.Interfaces.Geometries.IGeometryComponentFilter)">
            <summary>
            
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Point.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Point.Normalize">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Point.CompareToSameClass(System.Object)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Point.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Point"/> class.
            </summary>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            <param name="z">The z coordinate.</param>
            /// <remarks>
            For create this <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/> is used a standard <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory"/> 
            with <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel"/> <c> set to </c> <see cref="F:MapWindow.Interfaces.Geometries.PrecisionModels.Floating"/>.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Point.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Point"/> class.
            </summary>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            /// <remarks>
            For create this <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/> is used a standard <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory"/> 
            with <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel"/> <c> set to </c> <see cref="F:MapWindow.Interfaces.Geometries.PrecisionModels.Floating"/>.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Point.Equals2D(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Tests to see if the X coordinate and Y coordinate are the same between this point and the
            specified Coordinate
            </summary>
            <param name="Coord">Any valid implementation of the ICoordinate Interface</param>
            <returns>True if the coordinates are equal, false otherwise</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Point.Equals3D(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Tests to see if the X, Y, and Z coordinate are the same between this point and the
            specified Coordinate
            </summary>
            <param name="Coord">Any valid implementation of the ICoordinate Interface</param>
            <returns>True if the coordinates are equal, false otherwise</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Point.Distance(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Calculates the vector distance.  (This is a 2D opperation)
            </summary>
            <param name="Coord">Any valid implementation of the ICoordinate Interface</param>
            <returns>The Euclidean distance between two points {Sqrt((X2 - X1)^2 + (Y2 - Y1)^2)</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Point.CoordinateSequence">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Point.Coordinates">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Point.NumPoints">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Point.IsEmpty">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Point.IsSimple">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Point.IsValid">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Point.Dimension">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Point.BoundaryDimension">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Point.X">
            <summary>
            
            </summary>        
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Point.Y">
            <summary>
            
            </summary>        
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Point.Coordinate">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Point.GeometryType">
            <summary>
            An enumeration to clarify that this is a Point geometry type
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Point.Boundary">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Point.Z">
            <summary>
            
            </summary>        
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Point.Envelope">
            <summary>
            This is technically an envelope, but all the X and Y values are the same as 
            the X and Y coordinates for this point
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequence">
            <summary>
            The <c>ICoordinateSequence</c> implementation that <c>Geometry</c>s use by default.
            In this implementation, Coordinates returned by ToArray and Coordinate are live --
            modifications to them are actually changing the
            CoordinateSequence's underlying data.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequence.#ctor(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Constructs a sequence based on the given array (the array is not copied).
            </summary>
            <param name="coordinates">The coordinate array that will be referenced.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequence.#ctor(System.Int32)">
            <summary>
            Constructs a sequence of a given size, populated with new Coordinates.
            </summary>
            <param name="size">The size of the sequence to create.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequence.#ctor(MapWindow.Interfaces.Geometries.ICoordinateSequence)">
            <summary>
            Constructs a sequence based on the given array (the array is not copied).
            </summary>
            <param name="coordSeq">The coordinate array that will be referenced.</param>      
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequence.GetCoordinate(System.Int32)">
            <summary>
            Get the Coordinate with index i.
            </summary>
            <param name="i">The index of the coordinate.</param>
            <returns>The requested Coordinate instance.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequence.GetCoordinateCopy(System.Int32)">
            <summary>
            Get a copy of the Coordinate with index i.
            </summary>
            <param name="i">The index of the coordinate.</param>
            <returns>A copy of the requested Coordinate.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequence.GetCoordinate(System.Int32,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Copies the i'th coordinate in the sequence to the supplied Coordinate.
            Only the first two dimensions are copied.
            </summary>
            <param name="index">The index of the coordinate to copy.</param>
            <param name="coord">A Coordinate to receive the value.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequence.GetX(System.Int32)">
            <summary>
            Returns ordinate X (0) of the specified coordinate.
            </summary>
            <param name="index"></param>
            <returns>
            The value of the X ordinate in the index'th coordinate.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequence.GetY(System.Int32)">
            <summary>
            Returns ordinate Y (1) of the specified coordinate.
            </summary>
            <param name="index"></param>
            <returns>
            The value of the Y ordinate in the index'th coordinate.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequence.GetOrdinate(System.Int32,MapWindow.Interfaces.Geometries.Ordinates)">
            <summary>
            Returns the ordinate of a coordinate in this sequence.
            Ordinate indices 0 and 1 are assumed to be X and Y.
            Ordinates indices greater than 1 have user-defined semantics
            (for instance, they may contain other dimensions or measure values).
            </summary>
            <param name="index">The coordinate index in the sequence.</param>
            <param name="ordinate">The ordinate index in the coordinate (in range [0, dimension-1]).</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequence.Clone">
            <summary>
            Creates a deep copy of the object.
            </summary>
            <returns>The deep copy.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequence.SetOrdinate(System.Int32,MapWindow.Interfaces.Geometries.Ordinates,System.Double)">
            <summary>
            Sets the value for a given ordinate of a coordinate in this sequence.
            </summary>
            <param name="index">The coordinate index in the sequence.</param>
            <param name="ordinate">The ordinate index in the coordinate (in range [0, dimension-1]).</param>
            <param name="value">The new ordinate value.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequence.ToCoordinateArray">
             <summary>
            This method exposes the internal Array of Coordinate Objects.       
             </summary>
             <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequence.ExpandEnvelope(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            Expands the given Envelope to include the coordinates in the sequence.
            Allows implementing classes to optimize access to coordinate values.
            </summary>
            <param name="env">The envelope to expand.</param>
            <returns>A reference to the expanded envelope.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequence.ToString">
            <summary>
            Returns the string representation of the coordinate array.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequence.Dimension">
            <summary>
            Returns the dimension (number of ordinates in each coordinate) for this sequence.
            </summary>
            <value></value>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequence.Count">
            <summary>
            Returns the length of the coordinate sequence.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.MonotoneChain">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.MonotoneChain.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.MonotoneChainEdge,System.Int32)">
            <summary>
            
            </summary>
            <param name="mce"></param>
            <param name="chainIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.MonotoneChain.ComputeIntersections(MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.MonotoneChain,MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector)">
            <summary>
            
            </summary>
            <param name="mc"></param>
            <param name="si"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.DomainFlags">
            <summary>
            Flags indicating parts of domain covered by a convex hull. 
            </summary>
            <remarks>
            These flags can be combined. For example, the value 3 
            corresponds to a combination of <see cref="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.DomainFlags.Inside"/> and <see cref="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.DomainFlags.Outside"/>,
            which means that some parts of the convex hull are inside the 
            domain, and some parts of the convex hull are outside the domain.
            </remarks>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.DomainFlags.Inside">
            <summary>
            At least one point in a convex hull is inside the transform's domain.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.DomainFlags.Outside">
            <summary>
            At least one point in a convex hull is outside the transform's domain.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.DomainFlags.Discontinuous">
            <summary>
            At least one point in a convex hull is not transformed continuously.
            </summary>
            <remarks>
            As an example, consider a "Longitude_Rotation" transform which adjusts 
            longitude coordinates to take account of a change in Prime Meridian. If
            the rotation is 5 degrees east, then the point (Lat=175,Lon=0) is not 
            transformed continuously, since it is on the meridian line which will 
            be split at +180/-180 degrees.
            </remarks>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemFactory">
            <summary>
            Builds up complex objects from simpler objects or values.
            </summary>
            <remarks>
            <para>ICoordinateSystemFactory allows applications to make coordinate systems that 
            cannot be created by a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemAuthorityFactory"/>. This factory is very 
            flexible, whereas the authority factory is easier to use.</para>
            <para>So <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemAuthorityFactory"/>can be used to make 'standard' coordinate 
            systems, and <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory"/> can be used to make 'special' 
            coordinate systems.</para>
            <para>For example, the EPSG authority has codes for USA state plane coordinate systems 
            using the NAD83 datum, but these coordinate systems always use meters. EPSG does not 
            have codes for NAD83 state plane coordinate systems that use feet units. This factory
            lets an application create such a hybrid coordinate system.</para>
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemFactory.CreateCompoundCoordinateSystem(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystem,MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystem)">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICompoundCoordinateSystem"/>.
            </summary>
            <param name="name">Name of compound coordinate system.</param>
            <param name="head">Head coordinate system</param>
            <param name="tail">Tail coordinate system</param>
            <returns>Compound coordinate system</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemFactory.CreateEllipsoid(System.String,System.Double,System.Double,MapWinGeoProc.NTS.Topology.CoordinateSystems.ILinearUnit)">
            <summary>
            Creates an <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IEllipsoid"/> from radius values.
            </summary>
            <seealso cref="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemFactory.CreateFlattenedSphere(System.String,System.Double,System.Double,MapWinGeoProc.NTS.Topology.CoordinateSystems.ILinearUnit)"/>
            <param name="name">Name of ellipsoid</param>
            <param name="semiMajorAxis"></param>
            <param name="semiMinorAxis"></param>
            <param name="linearUnit"></param>
            <returns>Ellipsoid</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemFactory.CreateFittedCoordinateSystem(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystem,System.String,System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo})">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IFittedCoordinateSystem"/>.
            </summary>
            <remarks>The units of the axes in the fitted coordinate system will be 
            inferred from the units of the base coordinate system. If the affine map
            performs a rotation, then any mixed axes must have identical units. For
            example, a (lat_deg,lon_deg,height_feet) system can be rotated in the 
            (lat,lon) plane, since both affected axes are in degrees. But you 
            should not rotate this coordinate system in any other plane.</remarks>
            <param name="name">Name of coordinate system</param>
            <param name="baseCoordinateSystem">Base coordinate system</param>
            <param name="toBaseWkt"></param>
            <param name="arAxes"></param>
            <returns>Fitted coordinate system</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemFactory.CreateFlattenedSphere(System.String,System.Double,System.Double,MapWinGeoProc.NTS.Topology.CoordinateSystems.ILinearUnit)">
            <summary>
            Creates an <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IEllipsoid"/> from an major radius, and inverse flattening.
            </summary>
            <seealso cref="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemFactory.CreateEllipsoid(System.String,System.Double,System.Double,MapWinGeoProc.NTS.Topology.CoordinateSystems.ILinearUnit)"/>
            <param name="name">Name of ellipsoid</param>
            <param name="semiMajorAxis">Semi major-axis</param>
            <param name="inverseFlattening">Inverse flattening</param>
            <param name="linearUnit">Linear unit</param>
            <returns>Ellipsoid</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemFactory.CreateFromXml(System.String)">
            <summary>
            Creates a coordinate system object from an XML string.
            </summary>
            <param name="xml">XML representation for the spatial reference</param>
            <returns>The resulting spatial reference object</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemFactory.CreateFromWkt(System.String)">
            <summary>
            Creates a spatial reference object given its Well-known text representation.
            The output object may be either a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeographicCoordinateSystem"/> or
            a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IProjectedCoordinateSystem"/>.
            </summary>
            <param name="WKT">The Well-known text representation for the spatial reference</param>
            <returns>The resulting spatial reference object</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemFactory.CreateGeographicCoordinateSystem(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.IAngularUnit,MapWinGeoProc.NTS.Topology.CoordinateSystems.IHorizontalDatum,MapWinGeoProc.NTS.Topology.CoordinateSystems.IPrimeMeridian,MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo,MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo)">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeographicCoordinateSystem"/>, which could be Lat/Lon or Lon/Lat.
            </summary>
            <param name="name">Name of geographical coordinate system</param>
            <param name="angularUnit">Angular units</param>
            <param name="datum">Horizontal datum</param>
            <param name="primeMeridian">Prime meridian</param>
            <param name="axis0">First axis</param>
            <param name="axis1">Second axis</param>
            <returns>Geographic coordinate system</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemFactory.CreateHorizontalDatum(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType,MapWinGeoProc.NTS.Topology.CoordinateSystems.IEllipsoid,MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo)">
            <summary>
            Creates <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IHorizontalDatum"/> from ellipsoid and Bursa-World parameters.
            </summary>
            <remarks>
            Since this method contains a set of Bursa-Wolf parameters, the created 
            datum will always have a relationship to WGS84. If you wish to create a
            horizontal datum that has no relationship with WGS84, then you can 
            either specify a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType">horizontalDatumType</see> of <see cref="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType.HD_Other"/>, or create it via WKT.
            </remarks>
            <param name="name">Name of ellipsoid</param>
            <param name="datumType">Type of datum</param>
            <param name="ellipsoid">Ellipsoid</param>
            <param name="toWgs84">Wgs84 conversion parameters</param>
            <returns>Horizontal datum</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemFactory.CreateLocalCoordinateSystem(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.ILocalDatum,MapWinGeoProc.NTS.Topology.CoordinateSystems.IUnit,System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo})">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ILocalCoordinateSystem">local coordinate system</see>.
            </summary>
            <remarks>
             The dimension of the local coordinate system is determined by the size of 
            the axis array. All the axes will have the same units. If you want to make 
            a coordinate system with mixed units, then you can make a compound 
            coordinate system from different local coordinate systems.
            </remarks>
            <param name="name">Name of local coordinate system</param>
            <param name="datum">Local datum</param>
            <param name="unit">Units</param>
            <param name="axes">Axis info</param>
            <returns>Local coordinate system</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemFactory.CreateLocalDatum(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType)">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ILocalDatum"/>.
            </summary>
            <param name="name">Name of datum</param>
            <param name="datumType">Datum type</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemFactory.CreatePrimeMeridian(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.IAngularUnit,System.Double)">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IPrimeMeridian"/>, relative to Greenwich.
            </summary>
            <param name="name">Name of prime meridian</param>
            <param name="angularUnit">Angular unit</param>
            <param name="longitude">Longitude</param>
            <returns>Prime meridian</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemFactory.CreateProjectedCoordinateSystem(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeographicCoordinateSystem,MapWinGeoProc.NTS.Topology.CoordinateSystems.IProjection,MapWinGeoProc.NTS.Topology.CoordinateSystems.ILinearUnit,MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo,MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo)">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IProjectedCoordinateSystem"/> using a projection object.
            </summary>
            <param name="name">Name of projected coordinate system</param>
            <param name="gcs">Geographic coordinate system</param>
            <param name="projection">Projection</param>
            <param name="linearUnit">Linear unit</param>
            <param name="axis0">Primary axis</param>
            <param name="axis1">Secondary axis</param>
            <returns>Projected coordinate system</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemFactory.CreateProjection(System.String,System.String,System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectionParameter})">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IProjection"/>.
            </summary>
            <param name="name">Name of projection</param>
            <param name="wktProjectionClass">Projection class</param>
            <param name="Parameters">Projection parameters</param>
            <returns>Projection</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemFactory.CreateVerticalCoordinateSystem(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.IVerticalDatum,MapWinGeoProc.NTS.Topology.CoordinateSystems.ILinearUnit,MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo)">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IVerticalCoordinateSystem"/> from a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IVerticalDatum">datum</see> and <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ILinearUnit">linear units</see>.
            </summary>
            <param name="name">Name of vertical coordinate system</param>
            <param name="datum">Vertical datum</param>
            <param name="verticalUnit">Unit</param>
            <param name="axis">Axis info</param>
            <returns>Vertical coordinate system</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemFactory.CreateVerticalDatum(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType)">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IVerticalDatum"/> from an enumerated type value.
            </summary>
            <param name="name">Name of datum</param>
            <param name="datumType">Type of datum</param>
            <returns>Vertical datum</returns>	
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.HorizontalDatum">
            <summary>
            Horizontal datum defining the standard datum information.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Datum">
            <summary>
            A set of quantities from which other quantities are calculated.
            </summary>
            <remarks>
            For the OGC abstract model, it can be defined as a set of real points on the earth 
            that have coordinates. EG. A datum can be thought of as a set of parameters 
            defining completely the origin and orientation of a coordinate system with respect 
            to the earth. A textual description and/or a set of parameters describing the 
            relationship of a coordinate system to some predefined physical locations (such 
            as center of mass) and physical directions (such as axis of spin). The definition 
            of the datum may also include the temporal behavior (such as the rate of change of
            the orientation of the coordinate axes).
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Datum.#ctor(MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType,System.String,System.String,System.Int64,System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of a Datum object
            </summary>
            <param name="type">Datum type</param>
            <param name="name">Name</param>
            <param name="authority">Authority name</param>
            <param name="code">Authority-specific identification code.</param>
            <param name="alias">Alias</param>
            <param name="abbreviation">Abbreviation</param>
            <param name="remarks">Provider-supplied remarks</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Datum.EqualParams(System.Object)">
            <summary>
            Checks whether the values of this instance is equal to the values of another instance.
            Only parameters used for coordinate system are used for comparison.
            Name, abbreviation, authority, alias and remarks are ignored in the comparison.
            </summary>
            <param name="obj"></param>
            <returns>True if equal</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Datum.DatumType">
            <summary>
            Gets or sets the type of the datum as an enumerated code.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.HorizontalDatum.#ctor(MapWinGeoProc.NTS.Topology.CoordinateSystems.IEllipsoid,MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo,MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType,System.String,System.String,System.Int64,System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of a horizontal datum
            </summary>
            <param name="ellipsoid">Ellipsoid</param>
            <param name="toWgs84">Parameters for a Bursa Wolf transformation into WGS84</param>
            <param name="type">Datum type</param>
            <param name="name">Name</param>
            <param name="authority">Authority name</param>
            <param name="code">Authority-specific identification code.</param>
            <param name="alias">Alias</param>
            <param name="abbreviation">Abbreviation</param>
            <param name="remarks">Provider-supplied remarks</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.HorizontalDatum.EqualParams(System.Object)">
            <summary>
            Checks whether the values of this instance is equal to the values of another instance.
            Only parameters used for coordinate system are used for comparison.
            Name, abbreviation, authority, alias and remarks are ignored in the comparison.
            </summary>
            <param name="obj"></param>
            <returns>True if equal</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.HorizontalDatum.WGS84">
            <summary>
            EPSG's WGS 84 datum has been the then current realisation. No distinction is made between the original WGS 84 
            frame, WGS 84 (G730), WGS 84 (G873) and WGS 84 (G1150). Since 1997, WGS 84 has been maintained within 10cm of 
            the then current ITRF.
            </summary>
            <remarks>
            <para>Area of use: World</para>
            <para>Origin description: Defined through a consistent set of station coordinates. These have changed with time: by 0.7m 
            on 29/6/1994 [WGS 84 (G730)], a further 0.2m on 29/1/1997 [WGS 84 (G873)] and a further 0.06m on 
            20/1/2002 [WGS 84 (G1150)].</para>
            </remarks>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.HorizontalDatum.WGS72">
            <summary>
            World Geodetic System 1972
            </summary>
            <remarks>
            <para>Used by GPS before 1987. For Transit satellite positioning see also WGS 72BE. Datum code 6323 reserved for southern hemisphere ProjCS's.</para>
            <para>Area of use: World</para>
            <para>Origin description: Developed from a worldwide distribution of terrestrial and
            geodetic satellite observations and defined through a set of station coordinates.</para>
            </remarks>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.HorizontalDatum.ETRF89">
            <summary>
            European Terrestrial Reference System 1989
            </summary>
            <remarks>
            <para>Area of use: 
            Europe: Albania; Andorra; Austria; Belgium; Bosnia and Herzegovina; Bulgaria; Croatia; 
            Cyprus; Czech Republic; Denmark; Estonia; Finland; Faroe Islands; France; Germany; Greece; 
            Hungary; Ireland; Italy; Latvia; Liechtenstein; Lithuania; Luxembourg; Malta; Netherlands; 
            Norway; Poland; Portugal; Romania; San Marino; Serbia and Montenegro; Slovakia; Slovenia; 
            Spain; Svalbard; Sweden; Switzerland; United Kingdom (UK) including Channel Islands and 
            Isle of Man; Vatican City State.</para>
            <para>Origin description: Fixed to the stable part of the Eurasian continental 
            plate and consistent with ITRS at the epoch 1989.0.</para>
            </remarks>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.HorizontalDatum.ED50">
            <summary>
            European Datum 1950
            </summary>
            <remarks>
            <para>Area of use:
            Europe - west - Denmark; Faroe Islands; France offshore; Israel offshore; Italy including San 
            Marino and Vatican City State; Ireland offshore; Netherlands offshore; Germany; Greece (offshore);
            North Sea; Norway; Spain; Svalbard; Turkey; United Kingdom UKCS offshore. Egypt - Western Desert.
            </para>
            <para>Origin description: Fundamental point: Potsdam (Helmert Tower). 
            Latitude: 52 deg 22 min 51.4456 sec N; Longitude: 13 deg  3 min 58.9283 sec E (of Greenwich).</para>
            </remarks>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.HorizontalDatum.Ellipsoid">
            <summary>
            Gets or sets the ellipsoid of the datum
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.HorizontalDatum.Wgs84Parameters">
            <summary>
            Gets preferred parameters for a Bursa Wolf transformation into WGS84
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.HorizontalDatum.WKT">
            <summary>
            Returns the Well-known text for this object
            as defined in the simple features specification.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.HorizontalDatum.XML">
            <summary>
            Gets an XML representation of this object
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.NonRobustCGAlgorithms">
            <summary> 
            Non-robust versions of various fundamental Computational Geometric algorithms,
            FOR TESTING PURPOSES ONLY!.
            The non-robustness is due to rounding error in floating point computation.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.NonRobustCGAlgorithms.IsPointInRing(MapWinGeoProc.NTS.Topology.Geometries.Coordinate,MapWinGeoProc.NTS.Topology.Geometries.Coordinate[])">
            <summary>
            
            </summary>
            <param name="p"></param>
            <param name="ring"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.NonRobustCGAlgorithms.IsCCW(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[])">
            <summary>
            Computes whether a ring defined by an array of <c>Coordinate</c> is
            oriented counter-clockwise.
            This will handle coordinate lists which contain repeated points.
            </summary>
            <param name="ring">an array of coordinates forming a ring.</param>
            <returns>
            <c>true</c> if the ring is oriented counter-clockwise.
            throws <c>ArgumentException</c> if the ring is degenerate (does not contain 3 different points)
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.NonRobustCGAlgorithms.ComputeOrientation(MapWinGeoProc.NTS.Topology.Geometries.Coordinate,MapWinGeoProc.NTS.Topology.Geometries.Coordinate,MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="q"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.Transforms.Affine">
            <summary>
            A class supporting the affine transform.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Transforms.Affine.Specify_CellSize(System.Single,System.Single)">
            <summary>
            If this function is called the output image will be sized so that the pixels represent these dimensions.
            If this function is not specified, a cellwidth will be chosen to be as small as possible while retaining data.
            This is done by ensuring that no edge will contain fewer pixels than the edge in the source image.
            </summary>
            <param name="CellHeight">CellHeight is the height in the projected coordinates of each pixel in the output image</param>
            <param name="CellWidth">CellWidth is the width in the projected coordinates of each pixel in the output image</param>
            <remarks>Call this function first if you are going to call functions</remarks>
        </member>
        <member name="M:MapWinGeoProc.Transforms.Affine.Derive_Coefficients(System.Int32,System.Int32,MapWinGIS.Point,MapWinGIS.Point,MapWinGIS.Point,MapWinGIS.Point)">
            <summary>
            Calculates coefficients that will be stored in the instantiated object for further transforms.
            </summary>
            <param name="Width">The pixel width of the original rectangular image</param>
            <param name="Height">The pixel height of the original rectangular image</param>
            <param name="UpperLeft">The projected MapWinGIS.Point of the upper left corner of the image</param>
            <param name="UpperRight">The projected MapWinGIS.Point of the upper right corner of the image</param>
            <param name="LowerLeft">The projected MapWinGIS.Point of the lower left corner of the image</param>
            <param name="LowerRight">The projected MapWinGIS.Point fo the lower right corner of the image</param>
        </member>
        <member name="M:MapWinGeoProc.Transforms.Affine.Error">
            <summary>
            If you have all four corners, and you want to ensure that the affine transform that you have specified
            describes the result image adequately, use this function to estimate the erroroneous distance in pixels
            (Any value less than about 2 is generally good enough.)
            </summary>
            <returns>Double.  The pythagorean difference between the predicted and actual location
            for the lower right point in pixel coordinates.</returns>
        </member>
        <member name="M:MapWinGeoProc.Transforms.Affine.Autosize_Cells(System.Single,System.Single,MapWinGIS.Point,MapWinGIS.Point,MapWinGIS.Point)">
            <summary>
            This function will calculate a "scale" factor that should be the output pixel size.  If none is specified,
            this function is called internally.  This should prevent data loss, but may have more data than needed.
            </summary>
            <param name="Width">The width of the source image </param>
            <param name="Height">The height of the source image</param>
            <param name="outLL">The projected location of the lower left point</param>
            <param name="outUL">The projected location of the upper left point</param>
            <param name="outUR">The projected location of the upper right point</param>
            <returns>A float value representing the cell-height and cell-width.</returns>
        </member>
        <member name="T:MapWinGeoProc.Compatibility.RasterCatalog">
            <summary>
            Not yet implemented
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.RasterCatalog.Add(MapWindow.Interfaces.Raster.IRaster)">
            <summary>
            
            </summary>
            <param name="Raster"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.RasterCatalog.GetValue(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="X"></param>
            <param name="Y"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.RasterCatalog.PutValue(System.Double,System.Double,System.Object)">
            <summary>
            
            </summary>
            <param name="X"></param>
            <param name="Y"></param>
            <param name="Value"></param>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.RasterCatalog.Remove(System.Int32)">
            <summary>
            
            </summary>
            <param name="ID"></param>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.RasterCatalog.Count">
            <summary>
            
            </summary>
        </member>
        <member name="T:RTools.Util.StreamTokenizerUntermException">
            <summary>
            Exception class for unterminated tokens.
            </summary>
        </member>
        <member name="M:RTools.Util.StreamTokenizerUntermException.#ctor(System.String)">
            <summary>
            Construct with a particular message.
            </summary>
            <param name="msg">The message to store in this object.</param>
        </member>
        <member name="T:RTools.Util.StreamTokenizerUntermQuoteException">
            <summary>
            Exception class for unterminated quotes.
            </summary>
        </member>
        <member name="M:RTools.Util.StreamTokenizerUntermQuoteException.#ctor(System.String)">
            <summary>
            Construct with a particular message.
            </summary>
            <param name="msg">The message to store in this object.</param>
        </member>
        <member name="T:RTools.Util.StreamTokenizerUntermCommentException">
            <summary>
            Exception class for unterminated block comments.
            </summary>
        </member>
        <member name="M:RTools.Util.StreamTokenizerUntermCommentException.#ctor(System.String)">
            <summary>
            Construct with a particular message.
            </summary>
            <param name="msg">The message to store in this object.</param>
        </member>
        <member name="T:RTools.Util.CharTypeBits">
            <summary>
            Bitwise enumeration for character types.
            </summary>
        </member>
        <member name="F:RTools.Util.CharTypeBits.Word">
            <summary>word characters (usually alpha, digits, and domain specific)</summary>
        </member>
        <member name="F:RTools.Util.CharTypeBits.Comment">
            <summary># or something for line comments</summary>
        </member>
        <member name="F:RTools.Util.CharTypeBits.Whitespace">
            <summary>whitespace</summary>
        </member>
        <member name="F:RTools.Util.CharTypeBits.Quote">
            <summary>' or " type</summary>
        </member>
        <member name="F:RTools.Util.CharTypeBits.Digit">
            <summary>usually 0 to 9</summary>
        </member>
        <member name="F:RTools.Util.CharTypeBits.HexDigit">
            <summary>usually 0 to 9, a-f and A-F</summary>
        </member>
        <member name="F:RTools.Util.CharTypeBits.Eof">
            <summary>eof char</summary>
        </member>
        <member name="T:RTools.Util.StreamTokenizerSettings">
            <summary>
            This contains the settings that control the behavior of the tokenizer.
            This is separated from the StreamTokenizer so that common settings
            are easy to package and keep together.
            </summary>
        </member>
        <member name="M:RTools.Util.StreamTokenizerSettings.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:RTools.Util.StreamTokenizerSettings.#ctor(RTools.Util.StreamTokenizerSettings)">
            <summary>
            Copy constructor.
            </summary>
        </member>
        <member name="M:RTools.Util.StreamTokenizerSettings.Copy(RTools.Util.StreamTokenizerSettings)">
            <summary>
            Sets this object to be the same as the specified object.
            Note that some settings which are entirely embodied by the character
            type table.
            </summary>
        </member>
        <member name="M:RTools.Util.StreamTokenizerSettings.SetDefaults">
            <summary>
            Setup default parse behavior.
            This resets to same behavior as on construction.
            </summary>
            <returns>bool - true for success.</returns>
        </member>
        <member name="M:RTools.Util.StreamTokenizerSettings.SetupForCodeParse">
            <summary>
            Apply settings which are commonly used for code parsing
            C-endCapStyle code, including C++, C#, and Java.
            </summary>
            <returns></returns>
        </member>
        <member name="M:RTools.Util.StreamTokenizerSettings.ResetCharTypeTable">
            <summary>
            Clear the character type settings.  This leaves them unset,
            as opposed to the default.  Use SetDefaults() for default
            settings.
            </summary>
        </member>
        <member name="M:RTools.Util.StreamTokenizerSettings.WordChar(System.Int32)">
            <summary>
            Specify that a particular character is a word character.
            Character table type manipulation method.
            This adds the type to the char(s), rather
            than overwriting other types.
            </summary>
            <param name="c">The character.</param>
        </member>
        <member name="M:RTools.Util.StreamTokenizerSettings.WordChars(System.Int32,System.Int32)">
            <summary>
            Specify that a range of characters are word characters.
            Character table type manipulation method.
            This adds the type to the char(s), rather
            than overwriting other types.
            </summary>
            <param name="startChar">First character.</param>
            <param name="endChar">Last character.</param>
        </member>
        <member name="M:RTools.Util.StreamTokenizerSettings.WordChars(System.String)">
            <summary>
            Specify that a string of characters are word characters.
            Character table type manipulation method.
            This adds the type to the char(s), rather
            than overwriting other types.
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:RTools.Util.StreamTokenizerSettings.WhitespaceChar(System.Int32)">
            <summary>
            Specify that a character is a whitespace character.
            Character table type manipulation method.
            This type is exclusive with other types.
            </summary>
            <param name="c">The character.</param>
        </member>
        <member name="M:RTools.Util.StreamTokenizerSettings.WhitespaceChars(System.Int32,System.Int32)">
            <summary>
            Specify that a range of characters are whitespace characters.
            Character table type manipulation method.
            This adds the characteristic to the char(s), rather
            than overwriting other characteristics.
            </summary>
            <param name="startChar">First character.</param>
            <param name="endChar">Last character.</param>
        </member>
        <member name="M:RTools.Util.StreamTokenizerSettings.OrdinaryChars(System.Int32,System.Int32)">
            <summary>
            Remove other type settings from a range of characters.
            Character table type manipulation method.
            </summary>
            <param name="startChar"></param>
            <param name="endChar"></param>
        </member>
        <member name="M:RTools.Util.StreamTokenizerSettings.OrdinaryChar(System.Int32)">
            <summary>
            Remove other type settings from a character.
            Character table type manipulation method.
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:RTools.Util.StreamTokenizerSettings.CommentChar(System.Int32)">
            <summary>
            Specify that a particular character is a comment-starting character.
            Character table type manipulation method.
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:RTools.Util.StreamTokenizerSettings.QuoteChar(System.Int32)">
            <summary>
            Specify that a particular character is a quote character.
            Character table type manipulation method.
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:RTools.Util.StreamTokenizerSettings.CharTypeToString(System.Byte)">
            <summary>
            Return a string representation of a character type setting.
            Since the type setting is bitwise encoded, a character
            can have more than one type.
            </summary>
            <param name="ctype">The character type byte.</param>
            <returns>The string representation of the type flags.</returns>
        </member>
        <member name="M:RTools.Util.StreamTokenizerSettings.IsCharType(System.Byte,RTools.Util.CharTypeBits)">
            <summary>
            Check whether the specified char type byte has a 
            particular type flag set.
            </summary>
            <param name="ctype">The char type byte.</param>
            <param name="type">The CharTypeBits entry to compare to.</param>
            <returns>bool - true or false</returns>
        </member>
        <member name="M:RTools.Util.StreamTokenizerSettings.IsCharType(System.Char,RTools.Util.CharTypeBits)">
            <summary>
            Check whether the specified char has a 
            particular type flag set.
            </summary>
            <param name="c">The character.</param>
            <param name="type">The CharTypeBits entry to compare to.</param>
            <returns>bool - true or false</returns>
        </member>
        <member name="M:RTools.Util.StreamTokenizerSettings.IsCharType(System.Int32,RTools.Util.CharTypeBits)">
            <summary>
            Check whether the specified char has a 
            particular type flag set.
            </summary>
            <param name="c">The character.</param>
            <param name="type">The CharTypeBits entry to compare to.</param>
            <returns>bool - true or false</returns>
        </member>
        <member name="M:RTools.Util.StreamTokenizerSettings.Display">
            <summary>
            Display the state of this object.
            </summary>
        </member>
        <member name="M:RTools.Util.StreamTokenizerSettings.Display(System.String)">
            <summary>
            Display the state of this object, with a per-line prefix.
            </summary>
            <param name="prefix">The pre-line prefix.</param>
        </member>
        <member name="P:RTools.Util.StreamTokenizerSettings.CharTypes">
            <summary>
            This is the character type table.  Each byte is bitwise encoded
            with the character attributes, such as whether that character is
            word or whitespace.
            </summary>
        </member>
        <member name="P:RTools.Util.StreamTokenizerSettings.GrabWhitespace">
            <summary>
            Whether or not to return whitespace tokens.  If not, they're ignored.
            </summary>
        </member>
        <member name="P:RTools.Util.StreamTokenizerSettings.GrabEol">
            <summary>
            Whether or not to return EolTokens on end of line.  Eol tokens will not
            break up other tokens which can be multi-line.  For example block comments 
            and quotes will not be broken by Eol tokens.  Therefore the number of
            Eol tokens does not give you the line count of a stream.
            </summary>
        </member>
        <member name="P:RTools.Util.StreamTokenizerSettings.SlashSlashComments">
            <summary>
            Whether or not to look for // comments
            </summary>
        </member>
        <member name="P:RTools.Util.StreamTokenizerSettings.SlashStarComments">
            <summary>
            Whether or not to look for /* */ block comments.
            </summary>
        </member>
        <member name="P:RTools.Util.StreamTokenizerSettings.GrabComments">
            <summary>
            Whether or not to return comments.
            </summary>
        </member>
        <member name="P:RTools.Util.StreamTokenizerSettings.DoUntermCheck">
            <summary>
            Whether or not to check for unterminated quotes and block comments.
            If true, and one is encoutered, an exception is thrown of the appropriate type.
            </summary>
        </member>
        <member name="P:RTools.Util.StreamTokenizerSettings.ParseNumbers">
            <summary>
            Whether or not digits are specified as Digit type in the
            character table.
            This setting is based on the character types table, so this
            setting interacts with character type table manipulation.
            This setting may become incorrect if you modify the character
            types table directly.
            </summary>
        </member>
        <member name="P:RTools.Util.StreamTokenizerSettings.ParseHexNumbers">
            <summary>
            Whether or not to parse Hex (0xABCD...) numbers.
            This setting is based on the character types table, so this
            setting interacts with character type table manipulation.
            </summary>
        </member>
        <member name="T:RTools.Util.StreamTokenizer">
            <summary>
            A StreamTokenizer similar to Java's.  This breaks an input stream
            (coming from a TextReader) into Tokens based on various settings.  The settings
            are stored in the TokenizerSettings property, which is a
            StreamTokenizerSettings instance.
            </summary>
            <remarks>
            <para>
            This is configurable in that you can modify TokenizerSettings.CharTypes[] array
            to specify which characters are which type, along with other settings
            such as whether to look for comments or not.
            </para>
            <para>
            WARNING: This is not internationalized.  This treats all characters beyond
            the 7-bit ASCII range (decimal 127) as Word characters.
            </para>
            <para>
            There are two main ways to use this: 1) Parse the entire stream at
            once and get an ArrayList of Tokens (see the Tokenize* methods), 
            and 2) call NextToken() successively.
            This reads from a TextReader, which you can set directly, and this
            also provides some convenient methods to parse files and strings.
            This returns an Eof token if the end of the input is reached.
            </para>
            <para>
            Here's an example of the NextToken() endCapStyle of use:
            <code>
            StreamTokenizer tokenizer = new StreamTokenizer();
            tokenizer.GrabWhitespace = true;
            tokenizer.Verbosity = VerbosityLevel.Debug; // just for debugging
            tokenizer.TextReader = File.OpenText(fileName);
            Token token;
            while (tokenizer.NextToken(out token)) log.Info("Token = '{0}'", token);
            </code>
            </para>
            <para>
            Here's an example of the Tokenize... endCapStyle of use:
            <code>
            StreamTokenizer tokenizer = new StreamTokenizer("some string");
            ArrayList tokens = new ArrayList();
            if (!tokenizer.Tokenize(tokens)) 
            { 
            	// error handling
            }
            foreach (Token t in tokens) Console.WriteLine("t = {0}", t);
            </code>
            </para>
            <para>
            Comment delimiters are hardcoded (// and /*), not affected by char type table.
            </para>
            <para>
            This sets line numbers in the tokens it produces.  These numbers are normally
            the line on which the token starts.
            There is one known caveat, and that is that when GrabWhitespace setting
            is true, and a whitespace token contains a newline, that token's line number
            will be set to the following line rather than the line on which the token
            started.
            </para>
            </remarks>
        </member>
        <member name="F:RTools.Util.StreamTokenizer.NChars">
            <summary>
            This is the number of characters in the character table.
            </summary>
        </member>
        <member name="M:RTools.Util.StreamTokenizer.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:RTools.Util.StreamTokenizer.#ctor(System.IO.TextReader)">
            <summary>
            Construct and set this object's TextReader to the one specified.
            </summary>
            <param name="sr">The TextReader to read from.</param>
        </member>
        <member name="M:RTools.Util.StreamTokenizer.#ctor(System.String)">
            <summary>
            Construct and set a string to tokenize.
            </summary>
            <param name="str">The string to tokenize.</param>
        </member>
        <member name="M:RTools.Util.StreamTokenizer.Initialize">
            <summary>
            Utility function, things common to constructors.
            </summary>
        </member>
        <member name="M:RTools.Util.StreamTokenizer.InitializeStream">
            <summary>
            Clear the stream settings.
            </summary>
        </member>
        <member name="M:RTools.Util.StreamTokenizer.Display">
            <summary>
            Display the state of this object.
            </summary>
        </member>
        <member name="M:RTools.Util.StreamTokenizer.Display(System.String)">
            <summary>
            Display the state of this object, with a per-line prefix.
            </summary>
            <param name="prefix">The pre-line prefix.</param>
        </member>
        <member name="M:RTools.Util.StreamTokenizer.PickNextState(System.Byte,System.Int32)">
            <summary>
            Pick the next state given just a single character.  This is used
            at the start of a new token.
            </summary>
            <param name="ctype">The type of the character.</param>
            <param name="c">The character.</param>
            <returns>The state.</returns>
        </member>
        <member name="M:RTools.Util.StreamTokenizer.PickNextState(System.Byte,System.Int32,RTools.Util.StreamTokenizer.NextTokenState)">
            <summary>
            Pick the next state given just a single character.  This is used
            at the start of a new token.
            </summary>
            <param name="ctype">The type of the character.</param>
            <param name="c">The character.</param>
            <param name="excludeState">Exclude this state from the possible next state.</param>
            <returns>The state.</returns>
        </member>
        <member name="M:RTools.Util.StreamTokenizer.GetNextChar">
            <summary>
            Read the next character from the stream, or from backString
            if we backed up.
            </summary>
            <returns>The next character.</returns>
        </member>
        <member name="M:RTools.Util.StreamTokenizer.NextToken(RTools.Util.Token@)">
            <summary>
            Get the next token.  The last token will be an EofToken unless
            there's an unterminated quote or unterminated block comment
            and Settings.DoUntermCheck is true, in which case this throws
            an exception of type StreamTokenizerUntermException or sub-class.
            </summary>
            <param name="token">The output token.</param>
            <returns>bool - true for success, false for failure.</returns>
        </member>
        <member name="M:RTools.Util.StreamTokenizer.GrabInt(RTools.Util.CharBuffer,System.Boolean,System.Char@)">
            <summary>
            Starting from current stream location, scan forward
            over an int.  Determine whether it's an integer or not.  If so, 
            push the integer characters to the specified CharBuffer.  
            If not, put them in backString (essentially leave the
            stream as it was) and return false.
            <para>
            If it was an int, the stream is left 1 character after the
            end of the int, and that character is output in the thisChar parameter.
            </para>
            <para>The formats for integers are: 1, +1, and -1</para>
            The + and - signs are included in the output buffer.
            </summary>
            <param name="sb">The CharBuffer to append to.</param>
            <param name="allowPlus">Whether or not to consider + to be part
            of an integer.</param>
            <param name="thisChar">The last character read by this method.</param>
            <returns>true for parsed an int, false for not an int</returns>
        </member>
        <member name="M:RTools.Util.StreamTokenizer.Tokenize(System.Collections.ArrayList)">
            <summary>
            Parse the rest of the stream and put all the tokens
            in the input ArrayList. This resets the line number to 1.
            </summary>
            <param name="tokens">The ArrayList to append to.</param>
            <returns>bool - true for success</returns>
        </member>
        <member name="M:RTools.Util.StreamTokenizer.TokenizeReader(System.IO.TextReader,System.Collections.ArrayList)">
            <summary>
            Parse all tokens from the specified TextReader, put
            them into the input ArrayList.
            </summary>
            <param name="tr">The TextReader to read from.</param>
            <param name="tokens">The ArrayList to append to.</param>
            <returns>bool - true for success, false for failure.</returns>
        </member>
        <member name="M:RTools.Util.StreamTokenizer.TokenizeFile(System.String,System.Collections.ArrayList)">
            <summary>
            Parse all tokens from the specified file, put
            them into the input ArrayList.
            </summary>
            <param name="fileName">The file to read.</param>
            <param name="tokens">The ArrayList to put tokens in.</param>
            <returns>bool - true for success, false for failure.</returns>
        </member>
        <member name="M:RTools.Util.StreamTokenizer.TokenizeString(System.String,System.Collections.ArrayList)">
            <summary>
            Parse all tokens from the specified string, put
            them into the input ArrayList.
            </summary>
            <param name="str"></param>
            <param name="tokens">The ArrayList to put tokens in.</param>
            <returns>bool - true for success, false for failure.</returns>
        </member>
        <member name="M:RTools.Util.StreamTokenizer.TokenizeStream(System.IO.Stream,System.Collections.ArrayList)">
            <summary>
            Parse all tokens from the specified Stream, put
            them into the input ArrayList.
            </summary>
            <param name="s"></param>
            <param name="tokens">The ArrayList to put tokens in.</param>
            <returns>bool - true for success, false for failure.</returns>
        </member>
        <member name="M:RTools.Util.StreamTokenizer.TokenizeFile(System.String)">
            <summary>
            Tokenize a file completely and return the tokens in a Token[].
            </summary>
            <param name="fileName">The file to tokenize.</param>
            <returns>A Token[] with all tokens.</returns>
        </member>
        <member name="P:RTools.Util.StreamTokenizer.TextReader">
            <summary>
            This is the TextReader that this object will read from.
            Set this to set the input reader for the parse.
            </summary>
        </member>
        <member name="P:RTools.Util.StreamTokenizer.Settings">
            <summary>
            The settings which govern the behavior of the tokenization.
            </summary>
        </member>
        <member name="P:RTools.Util.StreamTokenizer.Verbosity">
            <summary>
            The verbosity level for this object's Logger.
            </summary>
        </member>
        <member name="T:RTools.Util.StreamTokenizer.NextTokenState">
            <summary>
            The states of the state machine.
            </summary>
        </member>
        <member name="T:RTools.Util.BufferedTextReader">
            <summary>
            Wraps a TextReader with buffering for speed. This is not finished,
            and preliminary testing indicates it isn't faster than FCL implementation.
            </summary>
        </member>
        <member name="M:RTools.Util.BufferedTextReader.#ctor(System.IO.TextReader)">
            <summary>
            Constructor
            </summary>
            <param name="reader">The TextReader to wrap.</param>
        </member>
        <member name="M:RTools.Util.BufferedTextReader.Read">
            <summary>
            Read a single character.
            </summary>
            <returns>The character read.</returns>
        </member>
        <member name="M:RTools.Util.BufferedTextReader.Close">
            <summary>
            Close the underlying reader.
            </summary>
        </member>
        <member name="T:Iesi.Collections.Generic.ImmutableSet`1">
            <summary>
            <p>Implements an immutable (read-only) <c>Set</c> wrapper.</p>
            <p>Although this is advertised as immutable, it really isn't.  Anyone with access to the
            <c>basisSet</c> can still change the data-set.  So <c>GetHashCode()</c> is not implemented
            for this <c>Set</c>, as is the case for all <c>Set</c> implementations in this library.
            This design decision was based on the efficiency of not having to <c>Clone()</c> the 
            <c>basisSet</c> every time you wrap a mutable <c>Set</c>.</p>
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.ImmutableSet`1.#ctor(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Constructs an immutable (read-only) <c>Set</c> wrapper.
            </summary>
            <param name="basisSet">The <c>Set</c> that is wrapped.</param>
        </member>
        <member name="M:Iesi.Collections.Generic.ImmutableSet`1.Add(`0)">
            <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
            <param name="o">The object to add to the set.</param>
            <returns><c>true</c> is the object was added, <c>false</c> if it was already present.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ImmutableSet`1.AddAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
            <param name="c">A collection of objects to add to the set.</param>
            <returns><c>true</c> is the set changed as a result of this operation, <c>false</c> if not.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ImmutableSet`1.Clear">
            <summary>
            Removes all objects from the set.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.ImmutableSet`1.Contains(`0)">
            <summary>
            Returns <c>true</c> if this set contains the specified element.
            </summary>
            <param name="o">The element to look for.</param>
            <returns><c>true</c> if this set contains the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ImmutableSet`1.ContainsAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Returns <c>true</c> if the set contains all the elements in the specified collection.
            </summary>
            <param name="c">A collection of objects.</param>
            <returns><c>true</c> if the set contains all the elements in the specified collection, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ImmutableSet`1.Remove(`0)">
            <summary>
            Removes the specified element from the set.
            </summary>
            <param name="o">The element to be removed.</param>
            <returns><c>true</c> if the set contained the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ImmutableSet`1.RemoveAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
            <param name="c">A collection of elements to remove.</param>
            <returns><c>true</c> if the set was modified as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ImmutableSet`1.RetainAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
            <param name="c">Collection that defines the set of elements to be retained.</param>
            <returns><c>true</c> if this set changed as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ImmutableSet`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements in the <c>Set</c> to an array.  The type of array needs
            to be compatible with the objects in the <c>Set</c>, obviously.
            </summary>
            <param name="array">An array that will be the target of the copy operation.</param>
            <param name="index">The zero-based index where copying will start.</param>
        </member>
        <member name="M:Iesi.Collections.Generic.ImmutableSet`1.GetEnumerator">
            <summary>
            Gets an enumerator for the elements in the <c>Set</c>.
            </summary>
            <returns>An <c>IEnumerator</c> over the elements in the <c>Set</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ImmutableSet`1.Clone">
            <summary>
            Returns a clone of the <c>Set</c> instance.  
            </summary>
            <returns>A clone of this object.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ImmutableSet`1.Union(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs a "union" of the two sets, where all the elements
            in both sets are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            Neither this set nor the input set are modified during the operation.  The return value
            is a <c>Clone()</c> of this set with the extra elements added in.
            </summary>
            <param name="a">A collection of elements.</param>
            <returns>A new <c>Set</c> containing the union of this <c>Set</c> with the specified collection.
            Neither of the input objects is modified by the union.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ImmutableSet`1.Intersect(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included if it exists in
            both sets.  The <c>Intersect()</c> operation does not modify the input sets.  It returns
            a <c>Clone()</c> of this set with the appropriate elements removed.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>The intersection of this set with <c>a</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ImmutableSet`1.Minus(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of this <c>Set</c> containing the elements from the operation.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>A set containing the elements from this set with the elements in <c>a</c> removed.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ImmutableSet`1.ExclusiveOr(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of this set containing
            the elements from the exclusive-or operation.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>A set containing the result of <c>a ^ b</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.ImmutableSet`1.unwrap(Iesi.Collections.Generic.ImmutableSet{`0})">
            <summary>
            Converts the ImmutableSet back into a regular ISet
            </summary>
            <param name="set"></param>
            <returns></returns>
        </member>
        <member name="P:Iesi.Collections.Generic.ImmutableSet`1.IsReadOnly">
            <summary>
            Tests to determine if this set is readonly... this is always true
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.ImmutableSet`1.IsEmpty">
            <summary>
            Returns <c>true</c> if this set contains no elements.
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.ImmutableSet`1.Count">
            <summary>
            The number of elements contained in this collection.
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.ImmutableSet`1.IsSynchronized">
            <summary>
            Not supported unless the set is null
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.ImmutableSet`1.SyncRoot">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Utilities.GeometricShapeFactory">
            <summary>
            Computes various kinds of common geometric shapes.
            Allows various ways of specifying the location and extent of the shapes,
            as well as number of line segments used to form them.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.GeometricShapeFactory.#ctor">
            <summary>
            Create a shape factory which will create shapes using the default GeometryFactory.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.GeometricShapeFactory.#ctor(MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory)">
            <summary>
            Create a shape factory which will create shapes using the given GeometryFactory.
            </summary>
            <param name="geomFact">The factory to use.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.GeometricShapeFactory.CreateRectangle">
            <summary>
            Creates a rectangular <c>Polygon</c>.
            </summary>
            <returns>A rectangular polygon.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.GeometricShapeFactory.CreateCircle">
            <summary>
            Creates a circular <c>Polygon</c>.
            </summary>
            <returns>A circular polygon.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.GeometricShapeFactory.CreateArc(System.Double,System.Double)">
            <summary>
            Creates a elliptical arc, as a LineString.
            </summary>
            <param name="startAng"></param>
            <param name="endAng"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Utilities.GeometricShapeFactory.Base">
            <summary>
            Gets/Sets the location of the shape by specifying the base coordinate
            (which in most cases is the
            lower left point of the envelope containing the shape).
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Utilities.GeometricShapeFactory.Centre">
            <summary>
            Gets/Sets the location of the shape by specifying the centre of
            the shape's bounding box.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Utilities.GeometricShapeFactory.NumPoints">
            <summary>
            Gets/Sets the total number of points in the created Geometry.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Utilities.GeometricShapeFactory.Size">
            <summary>
            Gets/Sets the size of the extent of the shape in both x and y directions.        
            </summary>                
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Utilities.GeometricShapeFactory.Width">
            <summary>
            Gets/Sets the width of the shape.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Utilities.GeometricShapeFactory.Height">
            <summary>
            Gets/Sets the height of the shape.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Utilities.GeometricShapeFactory.Dimensions">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Utilities.GeometricShapeFactory.Dimensions.Base">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Utilities.GeometricShapeFactory.Dimensions.Centre">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Utilities.GeometricShapeFactory.Dimensions.Width">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Utilities.GeometricShapeFactory.Dimensions.Height">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Utilities.GeometricShapeFactory.Dimensions.Size">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Utilities.GeometricShapeFactory.Dimensions.Envelope">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Simplify.LineSegmentIndex">
            <summary>
            An index of LineSegments.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.LineSegmentIndex.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.LineSegmentIndex.Add(MapWinGeoProc.NTS.Topology.Simplify.TaggedLineString)">
            <summary>
            
            </summary>
            <param name="line"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.LineSegmentIndex.Add(MapWinGeoProc.NTS.Topology.Geometries.LineSegment)">
            <summary>
            
            </summary>
            <param name="seg"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.LineSegmentIndex.Remove(MapWinGeoProc.NTS.Topology.Geometries.LineSegment)">
            <summary>
            
            </summary>
            <param name="seg"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.LineSegmentIndex.Query(MapWinGeoProc.NTS.Topology.Geometries.LineSegment)">
            <summary>
            
            </summary>
            <param name="querySeg"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Simplify.LineSegmentVisitor">
            <summary>
            ItemVisitor subclass to reduce volume of query results.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.IItemVisitor">
            <summary>
            A visitor for items in an index.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.IItemVisitor.VisitItem(System.Object)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.LineSegmentVisitor.#ctor(MapWinGeoProc.NTS.Topology.Geometries.LineSegment)">
            <summary>
            
            </summary>
            <param name="querySeg"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.LineSegmentVisitor.VisitItem(System.Object)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Simplify.LineSegmentVisitor.Items">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationErrors">
            <summary>
            Contains information about the nature and location of 
            a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/> validation error.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationErrors.Error">
            <summary>
            Not used.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationErrors.RepeatedPoint">
            <summary>
            No longer used: 
            repeated points are considered valid as per the SFS.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationErrors.HoleOutsideShell">
            <summary>
            Indicates that a hole of a polygon lies partially 
            or completely in the exterior of the shell.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationErrors.NestedHoles">
            <summary>
            Indicates that a hole lies 
            in the interior of another hole in the same polygon.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationErrors.DisconnectedInteriors">
            <summary>
            Indicates that the interior of a polygon is disjoint
            (often caused by set of contiguous holes splitting 
            the polygon into two parts).
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationErrors.SelfIntersection">
            <summary>
            Indicates that two rings of a polygonal geometry intersect.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationErrors.RingSelfIntersection">
            <summary>
            Indicates that a ring self-intersects.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationErrors.NestedShells">
            <summary>
            Indicates that a polygon component of a 
            <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.MultiPolygon"/> lies inside another polygonal component.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationErrors.DuplicateRings">
            <summary>
            Indicates that a polygonal geometry 
            contains two rings which are identical.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationErrors.TooFewPoints">
            <summary>
            Indicates that either:
            - A <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.LineString"/> contains a single point.
            - A <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.LinearRing"/> contains 2 or 3 points.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationErrors.InvalidCoordinate">
            <summary>
            Indicates that the <c>X</c> or <c>Y</c> ordinate of
            a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> is not a valid 
            numeric value (e.g. <see cref="F:System.Double.NaN"/>).
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationErrors.RingNotClosed">
            <summary>
            Indicates that a ring is not correctly closed
            (the first and the last coordinate are different).
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationError">
            <summary>
            Contains information about the nature and location of a <c>Geometry</c>
            validation error.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationError.errMsg">
            <summary>
            These messages must synch up with the indexes above
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationError.#ctor(MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationErrors,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="errorType"></param>
            <param name="pt"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationError.#ctor(MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationErrors)">
            <summary>
            
            </summary>
            <param name="errorType"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationError.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationError.Coordinate">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationError.ErrorType">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Valid.TopologyValidationError.Message">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Distance.GeometryLocation">
            <summary>
            Represents the location of a point on a Geometry.
            Maintains both the actual point location (which of course
            may not be exact) as well as information about the component
            and segment index where the point occurs.
            Locations inside area Geometrys will not have an associated segment index,
            so in this case the segment index will have the sentinel value of InsideArea.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Distance.GeometryLocation.InsideArea">
            <summary>
            Special value of segment-index for locations inside area geometries. These
            locations do not have an associated segment index.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.GeometryLocation.#ctor(MapWindow.Interfaces.Geometries.IGeometry,System.Int32,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Constructs a GeometryLocation specifying a point on a point, as well as the 
            segment that the point is on (or InsideArea if the point is not on a segment).
            </summary>
            <param name="component"></param>
            <param name="segIndex"></param>
            <param name="pt"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.GeometryLocation.#ctor(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary> 
            Constructs a GeometryLocation specifying a point inside an area point.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Distance.GeometryLocation.GeometryComponent">
            <summary>
            Returns the point associated with this location.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Distance.GeometryLocation.SegmentIndex">
            <summary>
            Returns the segment index for this location. If the location is inside an
            area, the index will have the value InsideArea;
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Distance.GeometryLocation.Coordinate">
            <summary>
            Returns the location.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Distance.GeometryLocation.IsInsideArea">
            <summary>
            Returns whether this GeometryLocation represents a point inside an area point.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp">
            <summary>
            Computes the distance and
            closest points between two <c>Geometry</c>s.
            The distance computation finds a pair of points in the input geometries
            which have minimum distance between them.  These points may
            not be vertices of the geometries, but may lie in the interior of
            a line segment. In this case the coordinate computed is a close
            approximation to the exact point.
            The algorithms used are straightforward O(n^2)
            comparisons.  This worst-case performance could be improved on
            by using Voronoi techniques.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp.Distance(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Compute the distance between the closest points of two geometries.
            </summary>
            <param name="g0">A <c>Geometry</c>.</param>
            <param name="g1">Another <c>Geometry</c>.</param>
            <returns>The distance between the geometries.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp.IsWithinDistance(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.IGeometry,System.Double)">
            <summary>
            Test whether two geometries lie within a given distance of each other.
            </summary>
            <param name="g0"></param>
            <param name="g1"></param>
            <param name="distance"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp.ClosestPoints(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Compute the the closest points of two geometries.
            The points are presented in the same order as the input Geometries.
            </summary>
            <param name="g0">A <c>Geometry</c>.</param>
            <param name="g1">Another <c>Geometry</c>.</param>
            <returns>The closest points in the geometries.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp.#ctor(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Constructs a <see cref="T:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp"/>  that computes the distance and closest points between
            the two specified geometries.
            </summary>
            <param name="g0"></param>
            <param name="g1"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp.#ctor(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.IGeometry,System.Double)">
            <summary>
            Constructs a <see cref="T:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp"/> that computes the distance and closest points between
            the two specified geometries.
            </summary>
            <param name="g0"></param>
            <param name="g1"></param>
            <param name="terminateDistance">The distance on which to terminate the search.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp.Distance">
            <summary>
            Report the distance between the closest points on the input geometries.
            </summary>
            <returns>The distance between the geometries.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp.ClosestPoints">
            <summary>
            Report the coordinates of the closest points in the input geometries.
            The points are presented in the same order as the input Geometries.
            </summary>
            <returns>A pair of <c>Coordinate</c>s of the closest points.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp.ClosestLocations">
            <summary>
            Report the locations of the closest points in the input geometries.
            The locations are presented in the same order as the input Geometries.
            </summary>
            <returns>A pair of {GeometryLocation}s for the closest points.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp.UpdateMinDistance(System.Double)">
            <summary>
            
            </summary>
            <param name="dist"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp.UpdateMinDistance(MapWinGeoProc.NTS.Topology.Operation.Distance.GeometryLocation[],System.Boolean)">
            <summary>
            
            </summary>
            <param name="locGeom"></param>
            <param name="flip"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp.ComputeMinDistance">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp.ComputeContainmentDistance">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp.ComputeInside(System.Collections.IList,System.Collections.IList,MapWinGeoProc.NTS.Topology.Operation.Distance.GeometryLocation[])">
            <summary>
            
            </summary>
            <param name="locs"></param>
            <param name="polys"></param>
            <param name="locPtPoly"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp.ComputeInside(MapWinGeoProc.NTS.Topology.Operation.Distance.GeometryLocation,MapWinGeoProc.NTS.Topology.Geometries.Polygon,MapWinGeoProc.NTS.Topology.Operation.Distance.GeometryLocation[])">
            <summary>
            
            </summary>
            <param name="ptLoc"></param>
            <param name="poly"></param>
            <param name="locPtPoly"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp.ComputeLineDistance">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp.ComputeMinDistanceLines(System.Collections.IList,System.Collections.IList,MapWinGeoProc.NTS.Topology.Operation.Distance.GeometryLocation[])">
            <summary>
            
            </summary>
            <param name="lines0"></param>
            <param name="lines1"></param>
            <param name="locGeom"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp.ComputeMinDistancePoints(System.Collections.IList,System.Collections.IList,MapWinGeoProc.NTS.Topology.Operation.Distance.GeometryLocation[])">
            <summary>
            
            </summary>
            <param name="points0"></param>
            <param name="points1"></param>
            <param name="locGeom"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp.ComputeMinDistanceLinesPoints(System.Collections.IList,System.Collections.IList,MapWinGeoProc.NTS.Topology.Operation.Distance.GeometryLocation[])">
            <summary>
            
            </summary>
            <param name="lines"></param>
            <param name="points"></param>
            <param name="locGeom"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp.ComputeMinDistance(MapWinGeoProc.NTS.Topology.Geometries.LineString,MapWinGeoProc.NTS.Topology.Geometries.LineString,MapWinGeoProc.NTS.Topology.Operation.Distance.GeometryLocation[])">
            <summary>
            
            </summary>
            <param name="line0"></param>
            <param name="line1"></param>
            <param name="locGeom"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.DistanceOp.ComputeMinDistance(MapWinGeoProc.NTS.Topology.Geometries.LineString,MapWinGeoProc.NTS.Topology.Geometries.Point,MapWinGeoProc.NTS.Topology.Operation.Distance.GeometryLocation[])">
            <summary>
            
            </summary>
            <param name="line"></param>
            <param name="pt"></param>
            <param name="locGeom"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder">
            <summary>
            Computes the raw offset curve for a
            single <c>Geometry</c> component (ring, line or point).
            A raw offset curve line is not noded -
            it may contain self-intersections (and usually will).
            The final buffer polygon is computed by forming a topological graph
            of all the noded raw curves and tracing outside contours.
            The points in the raw curve are rounded to the required precision model.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder.DefaultQuadrantSegments">
            <summary>
            The default number of facets into which to divide a fillet of 90 degrees.
            A value of 8 gives less than 2% max error in the buffer distance.
            For a max error smaller of 1%, use QS = 12
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder.#ctor(MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel)">
            <summary>
            
            </summary>
            <param name="precisionModel"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder.#ctor(MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel,System.Int32)">
            <summary>
            
            </summary>
            <param name="precisionModel"></param>
            <param name="quadrantSegments"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder.GetLineCurve(MapWindow.Interfaces.Geometries.ICoordinate[],System.Double)">
            <summary>
            This method handles single points as well as lines.
            Lines are assumed to not be closed (the function will not
            fail for closed lines, but will generate superfluous line caps).
            </summary>
            <param name="inputPts"></param>
            <param name="distance"></param>
            <returns> A List of Coordinate[].</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder.GetRingCurve(MapWindow.Interfaces.Geometries.ICoordinate[],MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions,System.Double)">
            <summary>
            This method handles the degenerate cases of single points and lines,
            as well as rings.
            </summary>
            <returns>A List of Coordinate[].</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder.CopyCoordinates(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            
            </summary>
            <param name="pts"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder.Init(System.Double)">
            <summary>
            
            </summary>
            <param name="distance"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder.ComputeLineBufferCurve(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            
            </summary>
            <param name="inputPts"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder.ComputeRingBufferCurve(MapWindow.Interfaces.Geometries.ICoordinate[],MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions)">
            <summary>
            
            </summary>
            <param name="inputPts"></param>
            <param name="side"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder.AddPt(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="pt"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder.ClosePts">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder.InitSideSegments(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions)">
            <summary>
            
            </summary>
            <param name="s1"></param>
            <param name="s2"></param>
            <param name="side"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder.AddNextSegment(MapWindow.Interfaces.Geometries.ICoordinate,System.Boolean)">
            <summary>
            
            </summary>
            <param name="p"></param>
            <param name="addStartPoint"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder.AddLastSegment">
            <summary>
            Add last offset point.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder.ComputeOffsetSegment(MapWinGeoProc.NTS.Topology.Geometries.LineSegment,MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions,System.Double,MapWinGeoProc.NTS.Topology.Geometries.LineSegment)">
            <summary>
            Compute an offset segment for an input segment on a given side and at a given distance.
            The offset points are computed in full double precision, for accuracy.
            </summary>
            <param name="seg">The segment to offset.</param>
            <param name="side">The side of the segment the offset lies on.</param>
            <param name="distance">The offset distance.</param>
            <param name="offset">The points computed for the offset segment.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder.AddLineEndCap(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Add an end cap around point p1, terminating a line segment coming from p0.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder.AddFillet(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,System.Int32,System.Double)">
            <summary>
            
            </summary>
            <param name="p">Base point of curve.</param>
            <param name="p0">Start point of fillet curve.</param>
            <param name="p1">Endpoint of fillet curve.</param>
            <param name="direction"></param>
            <param name="distance"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder.AddFillet(MapWindow.Interfaces.Geometries.ICoordinate,System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            Adds points for a fillet.  The start and end point for the fillet are not added -
            the caller must add them if required.
            </summary>
            <param name="p"></param>
            <param name="startAngle"></param>
            <param name="endAngle"></param>
            <param name="direction">Is -1 for a CW angle, 1 for a CCW angle.</param>
            <param name="distance"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder.AddCircle(MapWindow.Interfaces.Geometries.ICoordinate,System.Double)">
            <summary>
            Adds a CW circle around a point.
            </summary>
            <param name="p"></param>
            <param name="distance"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder.AddSquare(MapWindow.Interfaces.Geometries.ICoordinate,System.Double)">
            <summary>
            Adds a CW square around a point
            </summary>
            <param name="p"></param>
            <param name="distance"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder.EndCapStyle">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder.Coordinates">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferBuilder">
            <summary> 
            Builds the buffer point for a given input point and precision model.
            Allows setting the level of approximation for circular arcs,
            and the precision model in which to carry out the computation.
            When computing buffers in floating point double-precision
            it can happen that the process of iterated noding can fail to converge (terminate).
            In this case a TopologyException will be thrown.
            Retrying the computation in a fixed precision
            can produce more robust results.    
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferBuilder.DepthDelta(MapWinGeoProc.NTS.Topology.GeometriesGraph.Label)">
            <summary>
            Compute the change in depth as an edge is crossed from R to L.
            </summary>
            <param name="label"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferBuilder.#ctor">
            <summary> 
            Creates a new BufferBuilder.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferBuilder.Buffer(MapWindow.Interfaces.Geometries.IGeometry,System.Double)">
            <summary>
            
            </summary>
            <param name="g"></param>
            <param name="distance"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferBuilder.GetNoder(MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel)">
            <summary>
            
            </summary>
            <param name="precisionModel"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferBuilder.ComputeNodedEdges(System.Collections.IList,MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel)">
            <summary>
            
            </summary>
            <param name="bufferSegStrList"></param>
            <param name="precisionModel"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferBuilder.InsertEdge(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge)">
            <summary>
            Inserted edges are checked to see if an identical edge already exists.
            If so, the edge is not inserted, but its label is merged
            with the existing edge.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferBuilder.BuildSubgraphs(System.Collections.IList,MapWinGeoProc.NTS.Topology.Operation.Overlay.PolygonBuilder)">
            <summary>
            Completes the building of the input subgraphs by depth-labelling them,
            and adds them to the <see cref="T:MapWinGeoProc.NTS.Topology.Operation.Overlay.PolygonBuilder"/>.
            The subgraph list must be sorted in rightmost-coordinate order.
            </summary>
            <param name="subgraphList">The subgraphs to build.</param>
            <param name="polyBuilder">The PolygonBuilder which will build the final polygons.</param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferBuilder.QuadrantSegments">
            <summary>
            Gets/Sets the number of segments used to approximate a angle fillet.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferBuilder.WorkingPrecisionModel">
            <summary>
            Gets/Sets the precision model to use during the curve computation and noding,
            if it is different to the precision model of the Geometry.
            If the precision model is less than the precision of the Geometry precision model,
            the Geometry must have previously been rounded to that precision.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferBuilder.EndCapStyle">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.SegmentNodeList">
            <summary>
            A list of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentNode"/>s present along a noded <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentNodeList.#ctor(MapWinGeoProc.NTS.Topology.Noding.SegmentString)">
            <summary>
            Initializes a new instance of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentNodeList"/> class.
            </summary>
            <param name="edge">The edge.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentNodeList.Add(MapWindow.Interfaces.Geometries.ICoordinate,System.Int32)">
            <summary>
            Adds an intersection into the list, if it isn't already there.
            The input segmentIndex and dist are expected to be normalized.
            </summary>
            <param name="intPt"></param>
            <param name="segmentIndex"></param>
            <returns>The SegmentIntersection found or added.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentNodeList.GetEnumerator">
            <summary>
            Returns an iterator of SegmentNodes.
            </summary>
            <returns>An iterator of SegmentNodes.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentNodeList.AddEndPoints">
            <summary>
            Adds nodes for the first and last points of the edge.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentNodeList.AddCollapsedNodes">
            <summary>
            Adds nodes for any collapsed edge pairs.
            Collapsed edge pairs can be caused by inserted nodes, or they can be
            pre-existing in the edge vertex list.
            In order to provide the correct fully noded semantics,
            the vertex at the base of a collapsed pair must also be added as a node.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentNodeList.FindCollapsesFromExistingVertices(System.Collections.IList)">
            <summary>
            Adds nodes for any collapsed edge pairs
            which are pre-existing in the vertex list.
            </summary>
            <param name="collapsedVertexIndexes"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentNodeList.FindCollapsesFromInsertedNodes(System.Collections.IList)">
            <summary>
            Adds nodes for any collapsed edge pairs caused by inserted nodes
            Collapsed edge pairs occur when the same coordinate is inserted as a node
            both before and after an existing edge vertex.
            To provide the correct fully noded semantics,
            the vertex must be added as a node as well.
            </summary>
            <param name="collapsedVertexIndexes"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentNodeList.FindCollapseIndex(MapWinGeoProc.NTS.Topology.Noding.SegmentNode,MapWinGeoProc.NTS.Topology.Noding.SegmentNode,System.Int32[])">
            <summary>
            
            </summary>
            <param name="ei0"></param>
            <param name="ei1"></param>
            <param name="collapsedVertexIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentNodeList.AddSplitEdges(System.Collections.IList)">
            <summary>
            Creates new edges for all the edges that the intersections in this
            list split the parent edge into.
            Adds the edges to the provided argument list
            (this is so a single list can be used to accumulate all split edges
            for a set of <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s).
            </summary>
            <param name="edgeList"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentNodeList.CheckSplitEdgesCorrectness(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="splitEdges"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentNodeList.CreateSplitEdge(MapWinGeoProc.NTS.Topology.Noding.SegmentNode,MapWinGeoProc.NTS.Topology.Noding.SegmentNode)">
            <summary>
             Create a new "split edge" with the section of points between
            (and including) the two intersections.
            The label for the new edge is the same as the label for the parent edge.
            </summary>
            <param name="ei0"></param>
            <param name="ei1"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentNodeList.Write(System.IO.StreamWriter)">
            <summary>
            
            </summary>
            <param name="outstream"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.SegmentNodeList.Edge">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.NodeVertexIterator">
            <summary>
            INCOMPLETE!!!
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.NodeVertexIterator.Remove">
            <summary>
            Not implemented.
            </summary>
            <exception cref="T:System.NotSupportedException">This method is not implemented.</exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.NodeVertexIterator.MoveNext">
            <summary>
            Consente di spostare l'enumeratore all'elemento successivo dell'insieme.
            </summary>
            <returns>
            true se l'enumeratore è stato spostato correttamente in avanti in corrispondenza dell'elemento successivo; false se l'enumeratore ha raggiunto la fine dell'insieme.
            </returns>
            <exception cref="T:System.InvalidOperationException">L'insieme è stato modificato dopo la creazione dell'enumeratore. </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.NodeVertexIterator.Reset">
            <summary>
            Imposta l'enumeratore sulla propria posizione iniziale, ovvero prima del primo elemento nell'insieme.
            </summary>
            <exception cref="T:System.InvalidOperationException">L'insieme è stato modificato dopo la creazione dell'enumeratore. </exception>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.NodeVertexIterator.Current">
            <summary>
            Ottiene l'elemento corrente dell'insieme.
            </summary>
            <value></value>
            <returns>Elemento corrente nell'insieme.</returns>
            <exception cref="T:System.InvalidOperationException">L'enumeratore è posizionato prima del primo elemento o dopo l'ultimo elemento dell'insieme. </exception>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.IntersectionAdder">
            <summary>
            Computes the intersections between two line segments in <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s
            and adds them to each string.
            The <see cref="T:MapWinGeoProc.NTS.Topology.Noding.ISegmentIntersector"/> is passed to a <see cref="T:MapWinGeoProc.NTS.Topology.Noding.INoder"/>.
            The <see cref="M:MapWinGeoProc.NTS.Topology.Noding.SegmentString.AddIntersections(MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector,System.Int32,System.Int32)"/> method is called whenever the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.INoder"/>
            detects that two <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s might intersect.
            This class is an example of the Strategy pattern.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.IntersectionAdder.IsAdjacentSegments(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="i1"></param>
            <param name="i2"></param>
            <returns></returns>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Noding.IntersectionAdder.hasIntersection">
            These variables keep track of what types of intersections were
            found during ALL edges that have been intersected.
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Noding.IntersectionAdder.NumIntersections">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Noding.IntersectionAdder.NumInteriorIntersections">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Noding.IntersectionAdder.NumProperIntersections">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Noding.IntersectionAdder.NumTests">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.IntersectionAdder.#ctor(MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector)">
            <summary>
            Initializes a new instance of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.IntersectionAdder"/> class.
            </summary>
            <param name="li"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.IntersectionAdder.IsTrivialIntersection(MapWinGeoProc.NTS.Topology.Noding.SegmentString,System.Int32,MapWinGeoProc.NTS.Topology.Noding.SegmentString,System.Int32)">
            <summary>
            A trivial intersection is an apparent self-intersection which in fact
            is simply the point shared by adjacent line segments.
            Note that closed edges require a special check for the point shared by the beginning and end segments.
            </summary>
            <param name="e0"></param>
            <param name="segIndex0"></param>
            <param name="e1"></param>
            <param name="segIndex1"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.IntersectionAdder.ProcessIntersections(MapWinGeoProc.NTS.Topology.Noding.SegmentString,System.Int32,MapWinGeoProc.NTS.Topology.Noding.SegmentString,System.Int32)">
            <summary>
            This method is called by clients
            of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.ISegmentIntersector"/> class to process
            intersections for two segments of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/> being intersected.
            Note that some clients (such as <see cref="T:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain"/>s) may optimize away
            this call for segment pairs which they have determined do not intersect
            (e.g. by an disjoint envelope test).
            </summary>
            <param name="e0"></param>
            <param name="segIndex0"></param>
            <param name="e1"></param>
            <param name="segIndex1"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.IntersectionAdder.LineIntersector">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.IntersectionAdder.ProperIntersectionPoint">
            <summary>
            Returns the proper intersection point, or <c>null</c> if none was found.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.IntersectionAdder.HasIntersection">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.IntersectionAdder.HasProperIntersection">
            <summary>
            A proper intersection is an intersection which is interior to at least two
            line segments.  Note that a proper intersection is not necessarily
            in the interior of the entire <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>, since another edge may have
            an endpoint equal to the intersection, which according to SFS semantics
            can result in the point being on the Boundary of the <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.IntersectionAdder.HasProperInteriorIntersection">
            <summary>
            A proper interior intersection is a proper intersection which is not
            contained in the set of boundary nodes set for this <see cref="T:MapWinGeoProc.NTS.Topology.Noding.ISegmentIntersector"/>.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.IntersectionAdder.HasInteriorIntersection">
            <summary>
            An interior intersection is an intersection which is
            in the interior of some segment.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexOfPoint">
            <summary>
            Computes the <see cref="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation"/> of the point
            on a linear <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>nearest a given <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/>.
            The nearest point is not necessarily unique; this class
            always computes the nearest point closest to the start of the geometry.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexOfPoint.IndexOf(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="linearGeom"></param>
            <param name="inputPt"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexOfPoint.#ctor(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Initializes a new instance of the <see cref="T:LocationIndexOfPoint"/> class.
            </summary>
            <param name="linearGeom">A linear geometry.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexOfPoint.IndexOf(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>     
            Find the nearest location along a linear {@link Geometry} to a given point.
            </summary>
            <param name="inputPt">The coordinate to locate.</param>
            <returns>The location of the nearest point.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexOfPoint.IndexOfAfter(MapWindow.Interfaces.Geometries.ICoordinate,MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation)">
            <summary>
            Find the nearest <see cref="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation"/> along the linear <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>
            to a given <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/> after the specified minimum <see cref="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation"/>.
            If possible the location returned will be strictly greater than the <paramref name="minIndex"/>.
            If this is not possible, the value returned will equal <paramref name="minIndex"/>.
            (An example where this is not possible is when <paramref name="minIndex"/> = [end of line] ).
            </summary>
            <param name="inputPt">The coordinate to locate.</param>
            <param name="minIndex">The minimum location for the point location.</param>
            <returns>The location of the nearest point.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexOfPoint.IndexOfFromStart(MapWindow.Interfaces.Geometries.ICoordinate,MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation)">
            <summary>
            
            </summary>
            <param name="inputPt"></param>
            <param name="minIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexOfPoint.SegmentFraction(MapWinGeoProc.NTS.Topology.Geometries.LineSegment,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="seg"></param>
            <param name="inputPt"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.ByteOrder">
            <summary>
            Byte order
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.IO.ByteOrder.BigIndian">
            <summary>
            LittleIndian
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.IO.ByteOrder.LittleIndian">
            <summary>
            BigIndian
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.WKBGeometryTypes">
            <summary>
            WKB Geometry Types
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.IO.WKBGeometryTypes.WKBPoint">
            <summary>
            Point.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.IO.WKBGeometryTypes.WKBLineString">
            <summary>
            LineString.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.IO.WKBGeometryTypes.WKBPolygon">
            <summary>
            Polygon.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.IO.WKBGeometryTypes.WKBMultiPoint">
            <summary>
            MultiPoint.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.IO.WKBGeometryTypes.WKBMultiLineString">
            <summary>
            MultiLineString.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.IO.WKBGeometryTypes.WKBMultiPolygon">
            <summary>
            MultiPolygon.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.IO.WKBGeometryTypes.WKBGeometryCollection">
            <summary>
            GeometryCollection.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.CoordinateSystemWktReader">
            <summary>
            Creates an object based on the supplied Well Known Text (WKT).
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.CoordinateSystemWktReader.Parse(System.String)">
            <summary>
            Reads and parses a WKT-formatted projection string.
            </summary>
            <param name="wkt">String containing WKT.</param>
            <returns>Object representation of the WKT.</returns>
            <exception cref="T:System.ArgumentException">If a token is not recognised.</exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.CoordinateSystemWktReader.ReadUnit(MapWinGeoProc.NTS.Topology.Converters.WellKnownText.WktStreamTokenizer)">
            <summary>
            Returns a IUnit given a piece of WKT.
            </summary>
            <param name="tokenizer">WktStreamTokenizer that has the WKT.</param>
            <returns>An object that implements the IUnit interface.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.CoordinateSystemWktReader.ReadLinearUnit(MapWinGeoProc.NTS.Topology.Converters.WellKnownText.WktStreamTokenizer)">
            <summary>
            Returns a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.LinearUnit"/> given a piece of WKT.
            </summary>
            <param name="tokenizer">WktStreamTokenizer that has the WKT.</param>
            <returns>An object that implements the IUnit interface.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.CoordinateSystemWktReader.ReadAngularUnit(MapWinGeoProc.NTS.Topology.Converters.WellKnownText.WktStreamTokenizer)">
            <summary>
            Returns a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.AngularUnit"/> given a piece of WKT.
            </summary>
            <param name="tokenizer">WktStreamTokenizer that has the WKT.</param>
            <returns>An object that implements the IUnit interface.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.CoordinateSystemWktReader.ReadAxis(MapWinGeoProc.NTS.Topology.Converters.WellKnownText.WktStreamTokenizer)">
            <summary>
            Returns a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo"/> given a piece of WKT.
            </summary>
            <param name="tokenizer">WktStreamTokenizer that has the WKT.</param>
            <returns>An AxisInfo object.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.CoordinateSystemWktReader.ReadCoordinateSystem(System.String,MapWinGeoProc.NTS.Topology.Converters.WellKnownText.WktStreamTokenizer)">
            <summary>
            
            </summary>
            <param name="coordinateSystem"></param>
            <param name="tokenizer"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.CoordinateSystemWktReader.ReadWGS84ConversionInfo(MapWinGeoProc.NTS.Topology.Converters.WellKnownText.WktStreamTokenizer)">
            <summary>
            Reads either 3, 6 or 7 parameter Bursa-Wolf values from TOWGS84 token
            </summary>
            <param name="tokenizer"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.CoordinateSystemWktReader.ReadEllipsoid(MapWinGeoProc.NTS.Topology.Converters.WellKnownText.WktStreamTokenizer)">
            <summary>
            
            </summary>
            <param name="tokenizer"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.CoordinateSystemWktReader.ReadProjection(MapWinGeoProc.NTS.Topology.Converters.WellKnownText.WktStreamTokenizer)">
            <summary>
            
            </summary>
            <param name="tokenizer"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.CoordinateSystemWktReader.ReadProjectedCoordinateSystem(MapWinGeoProc.NTS.Topology.Converters.WellKnownText.WktStreamTokenizer)">
            <summary>
            
            </summary>
            <param name="tokenizer"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.CoordinateSystemWktReader.ReadGeographicCoordinateSystem(MapWinGeoProc.NTS.Topology.Converters.WellKnownText.WktStreamTokenizer)">
            <summary>
            
            </summary>
            <param name="tokenizer"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.CoordinateSystemWktReader.ReadHorizontalDatum(MapWinGeoProc.NTS.Topology.Converters.WellKnownText.WktStreamTokenizer)">
            <summary>
            
            </summary>
            <param name="tokenizer"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.CoordinateSystemWktReader.ReadPrimeMeridian(MapWinGeoProc.NTS.Topology.Converters.WellKnownText.WktStreamTokenizer)">
            <summary>
            
            </summary>
            <param name="tokenizer"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Quadtree.Root">
            <summary>
            QuadRoot is the root of a single Quadtree.  
            It is centred at the origin,
            and does not have a defined extent.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Quadtree.NodeBase">
            <summary>
            The base class for nodes in a <c>Quadtree</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.NodeBase.GetSubnodeIndex(MapWindow.Interfaces.Geometries.IEnvelope,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary> 
            Returns the index of the subquad that wholly contains the given envelope.
            If none does, returns -1.
            </summary>
            <param name="env"></param>
            <param name="centre"></param>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Index.Quadtree.NodeBase.items">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Index.Quadtree.NodeBase.subnode">
            <summary>
            subquads are numbered as follows:
            2 | 3
            --+--
            0 | 1
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.NodeBase.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.NodeBase.Add(System.Object)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.NodeBase.Remove(MapWindow.Interfaces.Geometries.IEnvelope,System.Object)">
            <summary> 
            Removes a single item from this subtree.
            </summary>
            <param name="itemEnv">The envelope containing the item.</param>
            <param name="item">The item to remove.</param>
            <returns><c>true</c> if the item was found and removed.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.NodeBase.AddAllItems(System.Collections.IList@)">
            <summary>
            Insert items in <c>this</c> into the parameter!
            </summary>
            <param name="resultItems">IList for adding items.</param>
            <returns>Parameter IList with <c>this</c> items.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.NodeBase.IsSearchMatch(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            
            </summary>
            <param name="searchEnv"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.NodeBase.AddAllItemsFromOverlapping(MapWindow.Interfaces.Geometries.IEnvelope,System.Collections.IList@)">
            <summary>
            
            </summary>
            <param name="searchEnv"></param>
            <param name="resultItems"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.NodeBase.Visit(MapWindow.Interfaces.Geometries.IEnvelope,MapWinGeoProc.NTS.Topology.Index.IItemVisitor)">
            <summary>
            
            </summary>
            <param name="searchEnv"></param>
            <param name="visitor"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.NodeBase.VisitItems(MapWindow.Interfaces.Geometries.IEnvelope,MapWinGeoProc.NTS.Topology.Index.IItemVisitor)">
            <summary>
            
            </summary>
            <param name="searchEnv"></param>
            <param name="visitor"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Quadtree.NodeBase.Items">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Quadtree.NodeBase.HasItems">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Quadtree.NodeBase.IsPrunable">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Quadtree.NodeBase.HasChildren">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Quadtree.NodeBase.IsEmpty">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Quadtree.NodeBase.Depth">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Quadtree.NodeBase.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Quadtree.NodeBase.NodeCount">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Root.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Root.Insert(MapWindow.Interfaces.Geometries.IEnvelope,System.Object)">
            <summary> 
            Insert an item into the quadtree this is the root of.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Root.InsertContained(MapWinGeoProc.NTS.Topology.Index.Quadtree.Node,MapWindow.Interfaces.Geometries.IEnvelope,System.Object)">
            <summary> 
            Insert an item which is known to be contained in the tree rooted at
            the given QuadNode root.  Lower levels of the tree will be created
            if necessary to hold the item.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Root.IsSearchMatch(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            
            </summary>
            <param name="searchEnv"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.MultiPoint">
            <summary>  
            Models a collection of <c>Point</c>s.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection">
            <summary>
            Basic implementation of <c>GeometryCollection</c>.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.Empty">
            <summary>
            Represents an empty <c>GeometryCollection</c>.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.geometries">
            <summary>
            Internal representation of this <c>GeometryCollection</c>.        
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.#ctor(MapWindow.Interfaces.Geometries.IGeometry[])">
            <summary>
            
            </summary>
            <param name="geometries">
            The <c>Geometry</c>s for this <c>GeometryCollection</c>,
            or <c>null</c> or an empty array to create the empty
            point. Elements may be empty <c>Geometry</c>s,
            but not <c>null</c>s.
            </param>
            <remarks>
            For create this <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/> is used a standard <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory"/> 
            with <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel"/> <c> == </c> <see cref="F:MapWindow.Interfaces.Geometries.PrecisionModels.Floating"/>.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.#ctor(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Creates a new instance of a geometry collection by turning an array of coordinates
            into points
            </summary>
            <param name="coords">The coordinates to turn into a collection of points</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.#ctor(MapWindow.Interfaces.Geometries.ICoordinate[],MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            Creates a new instance of a geometry collection by turning an array of coordinates
            into points
            </summary>
            <param name="coords">The coordinates to turn into a collection of points</param>
            <param name="factory">An IGeometryFactory to use</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.#ctor(MapWindow.Interfaces.Geometries.IGeometry[],MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            
            </summary>
            <param name="geometries">
            The <c>Geometry</c>s for this <c>GeometryCollection</c>,
            or <c>null</c> or an empty array to create the empty
            point. Elements may be empty <c>Geometry</c>s,
            but not <c>null</c>s.
            </param>
            <param name="factory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.#ctor(MapWindow.Interfaces.Geometries.IGeometryBase[],MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            constructs a collection of geometry objects
            </summary>
            <param name="BaseGeometries">The primative version of geometries</param>
            <param name="factory">An IGeometryFactory for setting parameters</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.GetGeometryN(System.Int32)">
            <summary>
            
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.EqualsExact(MapWindow.Interfaces.Geometries.IGeometry,System.Double)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <param name="tolerance"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.Apply(MapWindow.Interfaces.Geometries.ICoordinateFilter)">
            <summary>
            
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.Apply(MapWindow.Interfaces.Geometries.IGeometryFilter)">
            <summary>
            
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.Apply(MapWindow.Interfaces.Geometries.IGeometryComponentFilter)">
            <summary>
            
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.Normalize">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.ComputeEnvelopeInternal">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.CompareToSameClass(System.Object)">
            <summary>
            
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.GetEnumerator">
            <summary>
            Returns a <c>GeometryCollectionEnumerator</c>:
            this IEnumerator returns the parent geometry as first element.
            In most cases is more useful the code
            <c>geometryCollectionInstance.Geometries.GetEnumerator()</c>: 
            this returns an IEnumerator over geometries composing GeometryCollection.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.Coordinate">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.Coordinates">
            <summary>
            Collects all coordinates of all subgeometries into an Array.
            Note that while changes to the coordinate objects themselves
            may modify the Geometries in place, the returned Array as such 
            is only a temporary container which is not synchronized back.
            </summary>
            <returns>The collected coordinates.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.IsEmpty">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.Dimension">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.BoundaryDimension">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.NumGeometries">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.Geometries">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.NumPoints">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.GeometryType">
            <summary>
            Uses an Enumeration to clarify the type of geometry
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.IsSimple">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.Boundary">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.Area">
            <summary>  
            Returns the area of this <c>GeometryCollection</c>.
            </summary>        
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.Length">
            <summary>  
            Returns the length of this <c>GeometryCollection</c>.
            </summary>        
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.IsHomogeneous">
            <summary>
            Return <c>true</c> if all features in collection are of the same type.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.Item(System.Int32)">
            <summary>
            Returns the iTh element in the collection.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.Count">
            <summary>
            Returns the number of geometries contained by this <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection"/>.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection.Envelope">
            <summary>
            Not Impelmented
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.MultiPoint.Empty">
            <summary>
            Represents an empty <c>MultiPoint</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.MultiPoint.#ctor(MapWindow.Interfaces.Geometries.ICoordinate[],MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            Constructs a <c>MultiPoint</c>.
            </summary>
            <param name="points">
            The <c>Point</c>s for this <c>MultiPoint</c>
            , or <c>null</c> or an empty array to create the empty point.
            Elements may be empty <c>Point</c>s, but not <c>null</c>s.
            </param>
            <param name="factory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.MultiPoint.#ctor(MapWinGeoProc.NTS.Topology.Geometries.Point[])">
            <summary>
            Constructs a <c>MultiPoint</c>.
            </summary>
            <param name="points">
            The <c>Point</c>s for this <c>MultiPoint</c>
            , or <c>null</c> or an empty array to create the empty point.
            Elements may be empty <c>Point</c>s, but not <c>null</c>s.
            </param>
            <remarks>
            For create this <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/> is used a standard <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory"/> 
            with <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel"/> <c> == </c> <see cref="F:MapWindow.Interfaces.Geometries.PrecisionModels.Floating"/>.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.MultiPoint.#ctor(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Creates new Multipoint using interface points
            </summary>
            <param name="points"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.MultiPoint.CastPoints(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Converts an array of point interface variables into local points.
            Eventually I hope to reduce the amount of "casting" necessary, in order
            to allow as much as possible to occur via an interface.
            </summary>
            <param name="rawPoints"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.MultiPoint.EqualsExact(MapWindow.Interfaces.Geometries.IGeometry,System.Double)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <param name="tolerance"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.MultiPoint.GetCoordinate(System.Int32)">
            <summary>
            Returns the <c>Coordinate</c> at the given position.
            </summary>
            <param name="n">The index of the <c>Coordinate</c> to retrieve, beginning at 0.
            </param>
            <returns>The <c>n</c>th <c>Coordinate</c>.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.MultiPoint.Dimension">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.MultiPoint.BoundaryDimension">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.MultiPoint.GeometryType">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.MultiPoint.Boundary">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.MultiPoint.IsSimple">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.MultiPoint.IsValid">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeNodingValidator">
            <summary>
            Validates that a collection of SegmentStrings is correctly noded.
            Throws an appropriate exception if an noding error is found.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeNodingValidator.ToSegmentStrings(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="edges"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeNodingValidator.#ctor(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="edges"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeNodingValidator.checkValid">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.UpdateIM(MapWinGeoProc.NTS.Topology.GeometriesGraph.Label,MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix)">
            <summary> 
            Updates an IM from the label for an edge.
            Handles edges from both L and A geometries.
            </summary>
            <param name="im"></param>
            <param name="label"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.#ctor(MapWindow.Interfaces.Geometries.ICoordinate[],MapWinGeoProc.NTS.Topology.GeometriesGraph.Label)">
            <summary>
            
            </summary>
            <param name="pts"></param>
            <param name="label"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.#ctor(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            
            </summary>
            <param name="pts"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.GetCoordinate(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.AddIntersections(MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector,System.Int32,System.Int32)">
            <summary>
            Adds EdgeIntersections for one or both
            intersections found for a segment of an edge to the edge intersection list.
            </summary>
            <param name="li"></param>
            <param name="segmentIndex"></param>
            <param name="geomIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.AddIntersection(MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector,System.Int32,System.Int32,System.Int32)">
            <summary>
            Add an EdgeIntersection for intersection intIndex.
            An intersection that falls exactly on a vertex of the edge is normalized
            to use the higher of the two possible segmentIndexes.
            </summary>
            <param name="li"></param>
            <param name="segmentIndex"></param>
            <param name="geomIndex"></param>
            <param name="intIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.ComputeIM(MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix)">
            <summary>
            Update the IM with the contribution for this component.
            A component only contributes if it has a labelling for both parent geometries.
            </summary>
            <param name="im"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.Equals(System.Object)">
            <summary>
            Equals is defined to be:
            e1 equals e2
            iff
            the coordinates of e1 are the same or the reverse of the coordinates in e2.
            </summary>
            <param name="o"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.Equals(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge)">
            <summary>
            Equals is defined to be:
            e1 equals e2
            iff
            the coordinates of e1 are the same or the reverse of the coordinates in e2.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.op_Equality(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge,MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge)">
            <summary>
            
            </summary>
            <param name="obj1"></param>
            <param name="obj2"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.op_Inequality(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge,MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge)">
            <summary>
            
            </summary>
            <param name="obj1"></param>
            <param name="obj2"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.IsPointwiseEqual(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge)">
            <returns> 
            <c>true</c> if the coordinate sequences of the Edges are identical.
            </returns>
            <param name="e"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.Write(System.IO.StreamWriter)">
            <summary>
            
            </summary>
            <param name="outstream"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.WriteReverse(System.IO.StreamWriter)">
            <summary>
            
            </summary>
            <param name="outstream"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.Points">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.NumPoints">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.Name">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.Coordinates">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.Coordinate">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.Envelope">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.Depth">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.DepthDelta">
            <summary>
            The depthDelta is the change in depth as an edge is crossed from R to L.
            </summary>
            <returns>The change in depth as the edge is crossed from R to L.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.MaximumSegmentIndex">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.EdgeIntersectionList">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.MonotoneChainEdge">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.IsClosed">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.IsCollapsed">
            <summary> 
            An Edge is collapsed if it is an Area edge and it consists of
            two segments which are equal and opposite (eg a zero-width V).
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.CollapsedEdge">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.Isolated">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge.IsIsolated">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Features.Feature">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Features.Feature.#ctor(MapWinGeoProc.NTS.Topology.Geometries.Geometry,MapWinGeoProc.NTS.Topology.Features.IAttributesTable)">
            <summary>
            
            </summary>
            <param name="geometry"></param>
            <param name="attributes"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Features.Feature.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Features.Feature.Geometry">
            <summary>
            Geometry representation of the feature.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Features.Feature.Attributes">
            <summary>
            Attributes table of the feature.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.CoordinateTransformationFactory">
            <summary>
            Creates coordinate transformations.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.CoordinateTransformationFactory.CreateFromCoordinateSystems(MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystem,MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystem)">
            <summary>
            Creates a transformation between two coordinate systems.
            </summary>
            <remarks>
            This method will examine the coordinate systems in order to construct
            a transformation between them. This method may fail if no path between 
            the coordinate systems is found, using the normal failing behavior of 
            the DCP (e.g. throwing an exception).</remarks>
            <param name="sourceCS">Source coordinate system</param>
            <param name="targetCS">Target coordinate system</param>
            <returns></returns>		
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.CoordinateTransformationFactory.CreateGeog2Geog(MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeographicCoordinateSystem,MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeographicCoordinateSystem)">
            <summary>
            Geographic to geographic transformation
            </summary>
            <remarks>Adds a datum shift if nessesary</remarks>
            <param name="source"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.CoordinateTransformationFactory.CreateGeoc2Geoc(MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeocentricCoordinateSystem,MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeocentricCoordinateSystem)">
            <summary>
            Geocentric to Geocentric transformation
            </summary>
            <param name="source"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.Error">
            <summary>
            Class for recording and retrieving error messages.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Error.ClearErrorLog">
            <summary>
            Deletes all previous error messages.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Error.GetLastErrorMsg">
            <summary>
            Provides access to the last error message recieved through 
            the MapWinGeoProc library.
            </summary>
            <returns>A description of the problem encountered. 
            </returns>
        </member>
        <member name="M:MapWinGeoProc.Error.SetErrorMsg(System.String)">
            <summary>
            Sets the last error message recieved through
            the MapWinGeoProc library.
            </summary>
            <param name="errorMsg">A string describing the problem encountered.</param>
        </member>
        <member name="T:MapWinGeoProc.Topology.Point">
            <summary>
            Point structure with double values
            This will store 3D X, Y and Z values, but has no vector functions.  
            For that, use the vector class.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.Point.X">
            <summary>
            The X coordinate of the point
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.Point.Y">
            <summary>
            The Y coordinate of the point
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.Point.Z">
            <summary>
            The Z coordinate of the point
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology.Point.#ctor">
            <summary>
            Creates a new, blank instance of a point where all the values are 0.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology.Point.#ctor(MapWinGIS.Point)">
            <summary>
            Creates a new instance of the Point structure
            </summary>
            <param name="Point">MapWinGIS.Point to convert into a Point</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.Point.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Creates a new instance of the Point structure with the values specified
            </summary>
            <param name="x">Double, The coordinate in the X direction</param>
            <param name="y">Double, The coordinate in the Y direction</param>
            <param name="z">Double, The coordinate in the Z direction</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.Point.#ctor(System.Double,System.Double)">
            <summary>
            Creates a new 2D instance of Point which has 0 for the Z coordinate and the X, Y values specified
            </summary>
            <param name="x">Double, The X coordinate of the point</param>
            <param name="y">Double, The Y coordinate of the point</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.Point.#ctor(MapWinGeoProc.Topology.Vector)">
            <summary>
            Creates a new 3D point using the Vector U
            </summary>
            <param name="U">Vector where the X, Y, and Z values are translated into point coordinates</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.Point.ClosestPointOn(MapWinGeoProc.Topology.LineSegment)">
            <summary>
            Returns a Point corresponding to the closest point on LineSegment Seg to this point
            </summary>
            <param name="Seg">Returns the closest point on Seg to this point</param>
            <returns>A Point representing the closest location on Seg to this point</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Point.Distance(MapWinGeoProc.Topology.Point)">
            <summary>
            Finds the euclidean distance between the points
            </summary>
            <param name="geom">The geometry to compare with this point</param>
            <returns>Double, the distance between the points</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Point.Distance(MapWinGeoProc.Topology.LineSegment)">
            <summary>
            Returns the shortest distance to the specified segment
            </summary>
            <param name="Seg">The segment to find the distance to</param>
            <returns>Double, the shortest distance to the specified segment</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Point.Intersects(MapWinGIS.Point)">
            <summary>
            Checks each value in the point to see if they are the same
            </summary>
            <param name="Point">The MapWinGIS.Point to compare with this point</param>
            <returns>Boolean, true if the points are the same</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Point.Intersects(MapWinGeoProc.Topology.Point)">
            <summary>
            Checks each value in the point to see if they are the same
            </summary>
            <param name="Point">The Point to compare with this point</param>
            <returns>Boolean, true if the points are the same</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Point.Intersects(MapWinGeoProc.Topology.LineSegment)">
            <summary>
            Checks to see of this point touches the two points of a segment or the line between them.
            </summary>
            <param name="Sgmt">A LineSegment representing the line segment to check</param>
            <returns>True if the point and line segment intersect</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Point.Intersects(MapWinGeoProc.Topology.Polygon)">
            <summary>
            Returns true if this point falls anywhere within the specified polygon
            or on the borders, or on the vertecies.
            </summary>
            <param name="Pgn">A Polygon to check.</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Point.IsCompletelyWithin(MapWinGeoProc.Topology.Polygon)">
            <summary>
            Tests if this point intersects the Polygon but does not touch the border of it
            </summary>
            <param name="Pgn">A Polygon to test</param>
            <returns>Boolean, true if the point is inside the polygon without touching the border</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Point.Within(MapWinGeoProc.Topology.Polygon)">
            <summary>
            Tests if this point is within or touching the boundary of the Polygon
            but does not cross.  (Since points have no size, this is the same as intersect.)
            </summary>
            <param name="Pgn">A Polygon to test</param>
            <returns>Boolean, true if the point is inside the polygon even if it touches</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Point.IsIdenticalTo(MapWinGeoProc.Topology.Point)">
            <summary>
            Checks each value in the point to see if they are the same
            </summary>
            <param name="Point">The Point to compare with this point</param>
            <returns>Boolean, true if the points are the same</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Point.IsIdenticalTo(MapWinGIS.Point)">
            <summary>
            Checks each value in the point to see if they are the same
            </summary>
            <param name="Point">The MapWinGIS.Point to compare with this point</param>
            <returns>Boolean, true if the points are the same</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Point.IsWithinADistanceOf(MapWinGeoProc.Topology.Point,System.Double)">
            <summary>
            Tests a point to determine if it is within the specified distance to this 
            point.
            </summary>
            <param name="Pnt">A Point to test against this point.</param>
            <param name="Dist">The distance to check against inclusive.</param>
            <returns>Boolean, true if the point is within the specified distance.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Point.IsWithinADistanceOf(MapWinGeoProc.Topology.LineSegment,System.Double)">
            <summary>
            Tests a segment to determine if it is within the specified distance to this point.
            </summary>
            <param name="Seg">A segment to test agianst this point.</param>
            <param name="Dist">The distance to return.</param>
            <returns>Returns true if any part of the specified segment is closer than Distance.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Point.To_mwPoint">
            <summary>
            Creates a MapWinGIS.Point from this point.
            </summary>
            <returns>A MapWinGIS.Point with the same X, Y and Z values</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Point.ToVector">
            <summary>
            Converts the point into a vector by assuming that the tail of the vector is the 
            origin (0,0,0)
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Point.TouchesTheBoundaryOf(MapWinGeoProc.Topology.Polygon)">
            <summary>
            Indicates that the point specifically lies on the boundary of the polygon,
            and is not contained by the polygon.  This only applies to area features,
            for line or point features use Intersect.
            </summary>
            <param name="Pgn">the Polygon to test the boundaries of.</param>
            <returns>True if the point lies exactly on the boundary of the polygon.</returns>
        </member>
        <member name="T:MapWinGeoProc.Topology2D.MultiPolygon">
            <summary>
            A group of Polygons, like islands
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.MultiPolygon.Geometries">
            <summary>
            A list of polygons.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.MultiPolygon.#ctor(MapWinGIS.Shape)">
            <summary>
            This will convert even the most complicated polygons into a working 
            collection for topology to use.  Frequently, it will be a simple polygon,
            but sometimes multiple parts aren't holes.
            </summary>
            <param name="mwShape"></param>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.MultiPolygon.NumGeometries">
            <summary>
            Returns an integer count of the polygons
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.MultiPolygon.Dimension">
            <summary>
            This collection is a collection of 2-D polygons
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Toolbox.Selection.#ctor(AxMapWinGIS.AxMap)">
            <summary>
            Creates a new instance of the selection object tuned to a specific map
            </summary>
            <param name="Map"></param>
        </member>
        <member name="M:MapWinGeoProc.Toolbox.Selection.ClearSelectedShapes">
            <summary>
            Clears the values in the selection for all layers
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Toolbox.Selection.ClearSelectedShapes(System.Int32)">
            <summary>
            Clears the shapes selected from a specific layer
            </summary>
            <param name="Layer"></param>
        </member>
        <member name="M:MapWinGeoProc.Toolbox.Selection.GetSelectedShapes(System.Int32)">
            <summary>
            Returns the selected shapes for a specific layer
            </summary>
            <param name="Layer"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Toolbox.Selection.SetSelectedShapes(System.Int32,System.Int32[])">
            <summary>
            Sets the selection for a specific layer.
            </summary>
            <param name="Layer">The Layer index to set the selection for</param>
            <param name="Shapes">An array of integer shape values</param>
        </member>
        <member name="M:MapWinGeoProc.Toolbox.Selection.StartSelectingShapes(System.Int32)">
            <summary>
            Only starts selecting shapes for a single layer
            </summary>
            <param name="Layer">The layer index for the map</param>
        </member>
        <member name="M:MapWinGeoProc.Toolbox.Selection.StartSelectingShapes">
            <summary>
            Selects shapes for all layers
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Toolbox.Selection.StopSelectingShapes">
            <summary>
            This does not restore anything, but simply deactivates the mouse responsiveness
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Toolbox.Selection.Highlight_Selection">
            <summary>
            Use this function to update the entire map to be consistent with the current selection.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Toolbox.Selection.Restore_Layer(System.Int32)">
            <summary>
            This handles the coloring aspects of un-selecting all the shapes in a layer
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Toolbox.Selection.Highlight_Layer(System.Int32)">
            <summary>
            This handles the coloring aspects of selecting all the shapes in a shapefile layer
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Toolbox.Selection.SelectionColor">
            <summary>
            Gets or sets the color to draw the selection with.  The default is cyan.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Toolbox.Selection.SelectionLineThickness">
            <summary>
            Gets or sets the thickness of selected lines
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Toolbox.Selection.ShowSelection">
            <summary>
            Gets or Sets whether the selection should be indicated by changes in color or line thickness.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Toolbox.Selection.SelectionMode">
            <summary>
            Gets or sets the selection mode.  Options are Intersection and Inclusion
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Toolbox.Selection.SelectedShapes">
            <summary>
            Gets or Sets a separate list of selected shape indecies for each layer in the map.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS_Adapter">
            <summary>
            This is a standard adapter that can convert between MapWinGIS.Shapes and Geometries
            </summary>
            <remarks>NOTE!  You will lose any Z or M information by using these tools!</remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS_Adapter.ShapeToGeometry(MapWinGIS.Shape)">
            <summary>
            Converts a MapWinGIS.Shape of any type to the associated geometry.
            Clockwise/Counter clockwise arrangements are important for polygons.
            Any hole that isn't correctly counter-clockwise will be treated as a polygon.
            Any clockwise "hole" that is not contained by at least one polygon will be
            reversed to clockwise and returned as a polygon.
            NULLSHAPE || MULTIPATCH --> throws exception.
            POINT || POINTM || POINTZ --> Geometries.Point
            MULTIPOINT || MULTIPOINTM || MULTIPOINTZ --> Geometries.MultiPoint
            {1 part} POLYLINE || POLYLINEM || POLYLINEZ --> Geometires.LineString
            {n parts} POLYLINE || POLYLINEM || POLYLINEZ --> Geometires.MultiLineString
            {1 shell} POLYGON || POLYGONM || POLYGONZ --> Geometires.Polygon
            {n shells} POLYGON || POLYGONM || POLYGONZ --> Geometries.MultiPolygon
            </summary>
            <param name="mwShape">A MapWinGIS.Shape to convert to a Geometry</param>
            <returns>Geometry representing the shape specified by mwShape.</returns>
            
        </member>
        <member name="M:MapWinGeoProc.NTS_Adapter.IsClockwise(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Determines whether a closed list of coordinates (last point = first) is clockwise
            </summary>
            <param name="Coords">A list of coordinates like those used in Geometries</param>
            <returns>Boolean, true if the list is clockwise</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS_Adapter.GeometryToShape(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            This one way function will convert most geometries into a valid MapWinGIS Shape object.
            </summary>
            <param name="geom">Point, MultiPoint, LineString, MultiLineString, LinearRing, Polygon, MultiPolygon</param>
            <returns>A MapWinGIS.Shape that will hold the specified geometries.</returns>
            <remarks>Shapes are not TypeZ or TypeM!  Adding them to the wrong shapefile can cause problems.</remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS_Adapter.AppendGeometryToShape(MapWindow.Interfaces.Geometries.IGeometry,MapWinGIS.Shape@)">
            <summary>
            This function lets the user set up whether the shape should be regular, type M or type Z.
            This will not interfere with existing shapes in the geometry, but will simply
            add the specified geometry to the end of the existing information.  Sending a null shape
            will create a new shape of the appropriate kind.
            </summary>
            <param name="geom">A Geometries.Geometry specifying what to append to the shape.
            Simply returns mwShape unchanged if geom is null.</param>
            <param name="mwShape">An existing shape with a shapetype already specified.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS_Adapter.GetHoles(MapWinGIS.Shape)">
            <summary>
            This function scans a Polygon/PolygonM/PolygonZ to determine if any of the 
            existing polygons are counter-clockwise.  If they are, then it creates a linear ring
            from the shape.
            </summary>
            <param name="mwShape">A MapWinGIS.Shape Polygon/PolygonM/PolygonZ that might have holes.</param>
            <returns>A List of Linear Rings, each item representing one of the holes from the polygon.</returns>
        </member>
        <member name="T:MapWinGeoProc.NRings">
            <summary>
            Organizes linear rings into polygons
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NRings.Ring">
            <summary>
            The outer shell of the proposed ring
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NRings.Holes">
            <summary>
            A list of the linear rings that should be holes contained by this outer shell
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NRings.#ctor(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            A list version of the polygon for adding and removing holes easilly
            </summary>
            <param name="Coords">A list of coordinates used to define the outer shell of the new NRings list</param>
        </member>
        <member name="T:Iesi.Collections.ListSet">
            <summary>
            Implements a <c>Set</c> based on a list.  Performance is much better for very small lists 
            than either <c>HashedSet</c> or <c>SortedSet</c>.  However, performance degrades rapidly as 
            the data-set gets bigger.  Use a <c>HybridSet</c> instead if you are not sure your data-set
            will always remain very small.  Iteration produces elements in the order they were added.
            However, element order is not guaranteed to be maintained by the various <c>Set</c>
            mathematical operators.  
            </summary>
        </member>
        <member name="M:Iesi.Collections.ListSet.#ctor">
            <summary>
            Creates a new set instance based on a list.
            </summary>
        </member>
        <member name="M:Iesi.Collections.ListSet.#ctor(System.Collections.ICollection)">
            <summary>
            Creates a new set instance based on a list and
            initializes it based on a collection of elements.
            </summary>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
        </member>
        <member name="T:Iesi.Collections.Generic.SortedSet`1">
            <summary>
            Implements a <c>Set</c> based on a sorted tree.  This gives good performance for operations on very
            large data-sets, though not as good - asymptotically - as a <c>HashedSet</c>.  However, iteration
            occurs in order.  Elements that you put into this type of collection must implement <c>IComparable</c>,
            and they must actually be comparable.  You can't mix <c>string</c> and <c>int</c> values, for example.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.SortedSet`1.#ctor">
            <summary>
            Creates a new set instance based on a sorted tree.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.SortedSet`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new set instance based on a sorted tree.
            </summary>
            <param name="comparer">The IComparer to use for sorting.</param>
        </member>
        <member name="M:Iesi.Collections.Generic.SortedSet`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Creates a new set instance based on a sorted tree and
            initializes it based on a collection of elements.
            </summary>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
        </member>
        <member name="M:Iesi.Collections.Generic.SortedSet`1.#ctor(System.Collections.Generic.ICollection{`0},System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new set instance based on a sorted tree and
            initializes it based on a collection of elements.
            </summary>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
            <param name="comparer">The IComparer to use for sorting.</param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Utilities.Assert">
            <summary>
            A utility for making programming assertions.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.Assert.#ctor">
            <summary>
            Only static methods!
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.Assert.IsTrue(System.Boolean)">
            <summary>
            
            </summary>
            <param name="assertion"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.Assert.IsTrue(System.Boolean,System.String)">
            <summary>
            
            </summary>
            <param name="assertion"></param>
            <param name="message"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.Assert.IsEquals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="expectedValue"></param>
            <param name="actualValue"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.Assert.IsEquals(System.Object,System.Object,System.String)">
            <summary>
            
            </summary>
            <param name="expectedValue"></param>
            <param name="actualValue"></param>
            <param name="message"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.Assert.ShouldNeverReachHere">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.Assert.ShouldNeverReachHere(System.String)">
            <summary>
            
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Valid.SweeplineNestedRingTester">
            <summary>
            Tests whether any of a set of <c>LinearRing</c>s are
            nested inside another ring in the set, using a <c>SweepLineIndex</c>
            index to speed up the comparisons.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.SweeplineNestedRingTester.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            
            </summary>
            <param name="graph"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.SweeplineNestedRingTester.Add(MapWinGeoProc.NTS.Topology.Geometries.LinearRing)">
            <summary>
            
            </summary>
            <param name="ring"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.SweeplineNestedRingTester.IsNonNested">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.SweeplineNestedRingTester.BuildIndex">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.SweeplineNestedRingTester.IsInside(MapWinGeoProc.NTS.Topology.Geometries.LinearRing,MapWinGeoProc.NTS.Topology.Geometries.LinearRing)">
            <summary>
            
            </summary>
            <param name="innerRing"></param>
            <param name="searchRing"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Valid.SweeplineNestedRingTester.NestedPoint">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Valid.SweeplineNestedRingTester.OverlapAction">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.SweeplineNestedRingTester.OverlapAction.#ctor(MapWinGeoProc.NTS.Topology.Operation.Valid.SweeplineNestedRingTester)">
            <summary>
            
            </summary>
            <param name="container"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.SweeplineNestedRingTester.OverlapAction.Overlap(MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineInterval,MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineInterval)">
            <summary>
            
            </summary>
            <param name="s0"></param>
            <param name="s1"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Valid.SweeplineNestedRingTester.OverlapAction.IsNonNested">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer">
            <summary>
            Polygonizes a set of Geometrys which contain linework that
            represents the edges of a planar graph.
            Any dimension of Geometry is handled - the constituent linework is extracted
            to form the edges.
            The edges must be correctly noded; that is, they must only meet
            at their endpoints.  The Polygonizer will still run on incorrectly noded input
            but will not form polygons from incorrected noded edges.
            The Polygonizer reports the follow kinds of errors:
            Dangles - edges which have one or both ends which are not incident on another edge endpoint
            Cut Edges - edges which are connected at both ends but which do not form part of polygon
            Invalid Ring Lines - edges which form rings which are invalid
            (e.g. the component lines contain a self-intersection).
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.lineStringAdder">
            <summary>
            Default factory.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.graph">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.dangles">
            <summary>
            Initialized with empty collections, in case nothing is computed
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.cutEdges">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.invalidRingLines">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.holeList">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.shellList">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.polyList">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.#ctor">
            <summary>
            Create a polygonizer with the same {GeometryFactory}
            as the input <c>Geometry</c>s.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.Add(System.Collections.IList)">
            <summary>
            Add a collection of geometries to be polygonized.
            May be called multiple times.
            Any dimension of Geometry may be added;
            the constituent linework will be extracted and used.
            </summary>
            <param name="geomList">A list of <c>Geometry</c>s with linework to be polygonized.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.Add(MapWinGeoProc.NTS.Topology.Geometries.Geometry)">
            <summary>
            Add a point to the linework to be polygonized.
            May be called multiple times.
            Any dimension of Geometry may be added;
            the constituent linework will be extracted and used
            </summary>
            <param name="g">A <c>Geometry</c> with linework to be polygonized.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.Add(MapWinGeoProc.NTS.Topology.Geometries.LineString)">
            <summary>
            Add a linestring to the graph of polygon edges.
            </summary>
            <param name="line">The <c>LineString</c> to add.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.Polygonize">
            <summary>
            Perform the polygonization, if it has not already been carried out.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.FindValidRings(System.Collections.IList,System.Collections.IList,System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="edgeRingList"></param>
            <param name="validEdgeRingList"></param>
            <param name="invalidRingList"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.FindShellsAndHoles(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="edgeRingList"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.AssignHolesToShells(System.Collections.IList,System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="holeList"></param>
            <param name="shellList"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.AssignHoleToShell(MapWinGeoProc.NTS.Topology.Operation.Polygonize.EdgeRing,System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="holeER"></param>
            <param name="shellList"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.Polygons">
            <summary>
            Compute and returns the list of polygons formed by the polygonization.
            </summary>        
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.Dangles">
            <summary> 
            Compute and returns the list of dangling lines found during polygonization.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.CutEdges">
            <summary>
            Compute and returns the list of cut edges found during polygonization.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.InvalidRingLines">
            <summary>
            Compute and returns the list of lines forming invalid rings found during polygonization.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.LineStringAdder">
            <summary>
            Add every linear element in a point into the polygonizer graph.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.LineStringAdder.#ctor(MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer)">
            <summary>
            
            </summary>
            <param name="container"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.Polygonizer.LineStringAdder.Filter(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="g"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMergeGraph">
            <summary>
            A planar graph of edges that is analyzed to sew the edges together. The 
            <c>marked</c> flag on <c>com.vividsolutions.planargraph.Edge</c>s 
            and <c>com.vividsolutions.planargraph.Node</c>s indicates whether they have been
            logically deleted from the graph.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph">
            <summary>
            Represents a directed graph which is embeddable in a planar surface.
            This class and the other classes in this package serve as a framework for
            building planar graphs for specific algorithms. This class must be
            subclassed to expose appropriate methods to construct the graph. This allows
            controlling the types of graph components ({DirectedEdge}s,
            <c>Edge</c>s and <c>Node</c>s) which can be added to the graph. An
            application which uses the graph framework will almost always provide
            subclasses for one or more graph components, which hold application-specific
            data and graph algorithms.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph.edges">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph.dirEdges">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph.nodeMap">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph.#ctor">
            <summary>
            Constructs a PlanarGraph without any Edges, DirectedEdges, or Nodes.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph.FindNode(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Returns the Node at the given location, or null if no Node was there.
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph.Add(MapWinGeoProc.NTS.Topology.Planargraph.Node)">
            <summary>
            Adds a node to the map, replacing any that is already at that location.
            Only subclasses can add Nodes, to ensure Nodes are of the right type.
            </summary>
            <param name="node"></param>
            <returns>The added node.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph.Add(MapWinGeoProc.NTS.Topology.Planargraph.Edge)">
            <summary>
            Adds the Edge and its DirectedEdges with this PlanarGraph.
            Assumes that the Edge has already been created with its associated DirectEdges.
            Only subclasses can add Edges, to ensure the edges added are of the right class.
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph.Add(MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge)">
            <summary>
            Adds the Edge to this PlanarGraph; only subclasses can add DirectedEdges,
            to ensure the edges added are of the right class.
            </summary>
            <param name="dirEdge"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph.GetNodeEnumerator">
            <summary>
            Returns an IEnumerator over the Nodes in this PlanarGraph.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph.GetDirEdgeEnumerator">
            <summary> 
            Returns an Iterator over the DirectedEdges in this PlanarGraph, in the order in which they
            were added.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph.GetEdgeEnumerator">
            <summary>
            Returns an Iterator over the Edges in this PlanarGraph, in the order in which they
            were added.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph.Remove(MapWinGeoProc.NTS.Topology.Planargraph.Edge)">
            <summary>
            Removes an Edge and its associated DirectedEdges from their from-Nodes and
            from this PlanarGraph. Note: This method does not remove the Nodes associated
            with the Edge, even if the removal of the Edge reduces the degree of a
            Node to zero.
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph.Remove(MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge)">
            <summary> 
            Removes DirectedEdge from its from-Node and from this PlanarGraph. Note:
            This method does not remove the Nodes associated with the DirectedEdge,
            even if the removal of the DirectedEdge reduces the degree of a Node to
            zero.
            </summary>
            <param name="de"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph.Remove(MapWinGeoProc.NTS.Topology.Planargraph.Node)">
            <summary>
            Removes a node from the graph, along with any associated DirectedEdges and
            Edges.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph.FindNodesOfDegree(System.Int32)">
            <summary>
            Returns all Nodes with the given number of Edges around it.
            </summary>
            <param name="degree"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph.Nodes">
            <summary>
            Returns the Nodes in this PlanarGraph.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph.Edges">
            <summary>
            Returns the Edges that have been added to this PlanarGraph.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMergeGraph.AddEdge(MapWinGeoProc.NTS.Topology.Geometries.LineString)">
            <summary>
            Adds an Edge, DirectedEdges, and Nodes for the given LineString representation
            of an edge. 
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMergeGraph.GetNode(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="coordinate"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexPointSnapper">
            <summary>
            "Snaps" all <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s in a <see cref="T:MapWinGeoProc.NTS.Topology.Index.ISpatialIndex"/> containing
            <see cref="T:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain"/>s to a given <see cref="T:MapWinGeoProc.NTS.Topology.Noding.Snapround.HotPixel"/>.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexPointSnapper.numberSnaps">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexPointSnapper.#ctor(System.Collections.IList,MapWinGeoProc.NTS.Topology.Index.ISpatialIndex)">
            <summary>
            Initializes a new instance of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexPointSnapper"/> class.
            </summary>
            <param name="monoChains"></param>
            <param name="index"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexPointSnapper.Snap(MapWinGeoProc.NTS.Topology.Noding.Snapround.HotPixel,MapWinGeoProc.NTS.Topology.Noding.SegmentString,System.Int32)">
            <summary>
            Snaps (nodes) all interacting segments to this hot pixel.
            The hot pixel may represent a vertex of an edge,
            in which case this routine uses the optimization
            of not noding the vertex itself
            </summary>
            <param name="hotPixel">The hot pixel to snap to.</param>
            <param name="parentEdge">The edge containing the vertex, if applicable, or <c>null</c>.</param>
            <param name="vertexIndex"></param>
            <returns><c>true</c> if a node was added for this pixel.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexPointSnapper.Snap(MapWinGeoProc.NTS.Topology.Noding.Snapround.HotPixel)">
            <summary>
            
            </summary>
            <param name="hotPixel"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexPointSnapper.QueryVisitor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexPointSnapper.QueryVisitor.#ctor(MapWinGeoProc.NTS.Topology.Geometries.Envelope,MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexPointSnapper.HotPixelSnapAction)">
            <summary>
            
            </summary>
            <param name="env"></param>
            <param name="action"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexPointSnapper.QueryVisitor.VisitItem(System.Object)">
            <summary>
            </summary>
            <param name="item"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexPointSnapper.HotPixelSnapAction">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexPointSnapper.HotPixelSnapAction.#ctor(MapWinGeoProc.NTS.Topology.Noding.Snapround.HotPixel,MapWinGeoProc.NTS.Topology.Noding.SegmentString,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexPointSnapper.HotPixelSnapAction"/> class.
            </summary>
            <param name="hotPixel"></param>
            <param name="parentEdge"></param>
            <param name="vertexIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexPointSnapper.HotPixelSnapAction.Select(MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain,System.Int32)">
            <summary>
            
            </summary>
            <param name="mc"></param>
            <param name="startIndex"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexPointSnapper.HotPixelSnapAction.IsNodeAdded">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.SegmentPointComparator">
            <summary>
            Implements a robust method of comparing the relative position of two points along the same segment.
            The coordinates are assumed to lie "near" the segment.
            This means that this algorithm will only return correct results
            if the input coordinates have the same precision and correspond to rounded values
            of exact coordinates lying on the segment.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentPointComparator.Compare(MapWinGeoProc.NTS.Topology.Noding.Octants,MapWinGeoProc.NTS.Topology.Geometries.Coordinate,MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
             Compares two <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/>s for their relative position along a segment
            lying in the specified <see cref="T:MapWinGeoProc.NTS.Topology.Noding.Octant"/>.
            </summary>
            <param name="octant"></param>
            <param name="p0"></param>
            <param name="p1"></param>
            <returns>
            -1 if node0 occurs first, or
             0 if the two nodes are equal, or
             1 if node1 occurs first.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentPointComparator.RelativeSign(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="x0"></param>
            <param name="x1"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentPointComparator.CompareValue(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="compareSign0"></param>
            <param name="compareSign1"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexOfLine">
            <summary>
            Determines the location of a subline along a linear <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>.
            The location is reported as a pair of <see cref="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation"/>s.
            NOTE: Currently this algorithm is not guaranteed to
            return the correct substring in some situations where
            an endpoint of the test line occurs more than once in the input line.
            (However, the common case of a ring is always handled correctly).
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexOfLine.IndicesOf(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="linearGeom"></param>
            <param name="subLine"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexOfLine.#ctor(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Initializes a new instance of the <see cref="T:LocationIndexOfLine"/> class.
            </summary>
            <param name="linearGeom">The linear geom.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexOfLine.IndicesOf(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="subLine"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter">
            <summary>
            Writes the GML representation of the features of Topology model.
            Uses GML 2.1.1 <c>Geometry.xsd</c> schema for base for features.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.#ctor">
            <summary>
            Initialize a new <c>GMLWriter</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.Write(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Returns an <c>XmlReader</c> with feature informations.
            Use <c>XmlDocument.Load(XmlReader)</c> for obtain a <c>XmlDocument</c> to work.
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.Write(MapWindow.Interfaces.Geometries.IGeometry,System.IO.Stream)">
            <summary>
            Writes a GML feature into a generic <c>Stream</c>, such a <c>FileStream</c> or other streams.
            </summary>
            <param name="geometry"></param>
            <param name="stream"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.Write(MapWindow.Interfaces.Geometries.ICoordinate,System.Xml.XmlTextWriter)">
            <summary>
            
            </summary>
            <param name="coordinate"></param>
            <param name="writer"></param>        
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.Write(MapWindow.Interfaces.Geometries.ICoordinate[],System.Xml.XmlTextWriter)">
            <summary>
            
            </summary>
            <param name="coordinates"></param>
            <param name="writer"></param>        
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.Write(MapWindow.Interfaces.Geometries.IGeometry,System.Xml.XmlTextWriter)">
            <summary>
            
            </summary>
            <param name="geometry"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.Write(MapWindow.Interfaces.Geometries.IPoint,System.Xml.XmlTextWriter)">
            <summary>
            
            </summary>
            <param name="point"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.Write(MapWinGeoProc.NTS.Topology.Geometries.LineString,System.Xml.XmlTextWriter)">
            <summary>
            
            </summary>
            <param name="lineString"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.Write(MapWinGeoProc.NTS.Topology.Geometries.LinearRing,System.Xml.XmlTextWriter)">
            <summary>
            
            </summary>
            <param name="linearRing"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.Write(MapWinGeoProc.NTS.Topology.Geometries.Polygon,System.Xml.XmlTextWriter)">
            <summary>
            
            </summary>
            <param name="polygon"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.Write(MapWinGeoProc.NTS.Topology.Geometries.MultiPoint,System.Xml.XmlTextWriter)">
            <summary>
            
            </summary>
            <param name="multiPoint"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.Write(MapWinGeoProc.NTS.Topology.Geometries.MultiLineString,System.Xml.XmlTextWriter)">
            <summary>
            
            </summary>
            <param name="multiLineString"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.Write(MapWinGeoProc.NTS.Topology.Geometries.MultiPolygon,System.Xml.XmlTextWriter)">
            <summary>
            
            </summary>
            <param name="multiPolygon"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.Write(MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection,System.Xml.XmlTextWriter)">
            <summary>
            
            </summary>
            <param name="geometryCollection"></param>
            <param name="writer"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.GetBytes(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Sets corrent length for Byte Stream.
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.SetByteStreamLength(MapWinGeoProc.NTS.Topology.Geometries.Geometry)">
            <summary>
            Sets corrent length for Byte Stream.
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.SetByteStreamLength(MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection)">
            <summary>
            
            </summary>
            <param name="geometryCollection"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.SetByteStreamLength(MapWinGeoProc.NTS.Topology.Geometries.MultiPolygon)">
            <summary>
            
            </summary>
            <param name="multiPolygon"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.SetByteStreamLength(MapWinGeoProc.NTS.Topology.Geometries.MultiLineString)">
            <summary>
            
            </summary>
            <param name="multiLineString"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.SetByteStreamLength(MapWinGeoProc.NTS.Topology.Geometries.MultiPoint)">
            <summary>
            
            </summary>
            <param name="multiPoint"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.SetByteStreamLength(MapWinGeoProc.NTS.Topology.Geometries.Polygon)">
            <summary>
            
            </summary>
            <param name="polygon"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.SetByteStreamLength(MapWinGeoProc.NTS.Topology.Geometries.LineString)">
            <summary>
            
            </summary>
            <param name="lineString"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.SetByteStreamLength(MapWinGeoProc.NTS.Topology.Geometries.Point)">
            <summary>
            
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.GML2.GMLWriter.NumberFormatter">
            <summary>
            Formatter for double values of coordinates
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.GML2.GMLReader">
            <summary>
            Reads a GML document and creates a representation of the features based or Topology model.
            Uses GML 2.1.1 <c>Geometry.xsd</c> as schema for features.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLReader.#ctor">
            <summary>
            Initialize reader with a standard <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory"/>. 
            </summary>
            <seealso cref="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.Default"/>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLReader.#ctor(MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory)">
            <summary>
            Initialize reader with the given <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory"/>.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLReader.Read(System.Xml.XmlDocument)">
            <summary>
            Read a GML document and returns relative <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>.
            </summary>
            <param name="document"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLReader.Read(System.String)">
            <summary>
            
            </summary>
            <param name="xmlText"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLReader.Read(System.IO.StringReader)">
            <summary>
            
            </summary>
            <param name="stringReader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLReader.ReadCoordinate(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLReader.ReadPoint(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLReader.ReadLineString(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLReader.ReadLinearRing(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLReader.ReadPolygon(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLReader.ReadMultiPoint(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLReader.ReadMultiLineString(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLReader.ReadMultiPolygon(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GML2.GMLReader.ReadGeometryCollection(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.GML2.GMLReader.Factory">
            <summary>
            <c>Geometry</c> builder.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Quadtree.Node">
            <summary>
            Represents a node of a <c>Quadtree</c>.  Nodes contain
            items which have a spatial extent corresponding to the node's position
            in the quadtree.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Node.CreateNode(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            
            </summary>
            <param name="env"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Node.CreateExpanded(MapWinGeoProc.NTS.Topology.Index.Quadtree.Node,MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="addEnv"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Node.#ctor(MapWindow.Interfaces.Geometries.IEnvelope,System.Int32)">
            <summary>
            
            </summary>
            <param name="env"></param>
            <param name="level"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Node.IsSearchMatch(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            
            </summary>
            <param name="searchEnv"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Node.GetNode(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary> 
            Returns the subquad containing the envelope.
            Creates the subquad if
            it does not already exist.
            </summary>
            <param name="searchEnv"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Node.Find(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            Returns the smallest <i>existing</i>
            node containing the envelope.
            </summary>
            <param name="searchEnv"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Node.InsertNode(MapWinGeoProc.NTS.Topology.Index.Quadtree.Node)">
            <summary>
            
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Node.GetSubnode(System.Int32)">
            <summary>
            Get the subquad for the index.
            If it doesn't exist, create it.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Node.CreateSubnode(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Quadtree.Node.Envelope">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainBuilder">
            <summary> 
            A MonotoneChainBuilder implements static functions
            to determine the monotone chains in a sequence of points.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainBuilder.#ctor">
            <summary>
            Only static methods!
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainBuilder.ToIntArray(System.Collections.IList)">
             <summary>
            
             </summary>
             <param name="list"></param>
             <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainBuilder.GetChains(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            
            </summary>
            <param name="pts"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainBuilder.GetChains(MapWindow.Interfaces.Geometries.ICoordinate[],System.Object)">
            <summary>
            Return a list of the <c>MonotoneChain</c>s
            for the given list of coordinates.
            </summary>
            <param name="pts"></param>
            <param name="context"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainBuilder.GetChainStartIndices(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Return an array containing lists of start/end indexes of the monotone chains
            for the given list of coordinates.
            The last entry in the array points to the end point of the point array,
            for use as a sentinel.
            </summary>
            <param name="pts"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainBuilder.FindChainEnd(MapWindow.Interfaces.Geometries.ICoordinate[],System.Int32)">
            <summary>
            
            </summary>
            <param name="pts"></param>
            <param name="start"></param>
            <returns> 
            The index of the last point in the monotone chain starting at <c>start</c>.
            </returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain">
            <summary> 
            MonotoneChains are a way of partitioning the segments of a linestring to
            allow for fast searching of intersections.
            They have the following properties:
            the segments within a monotone chain will never intersect each other
            the envelope of any contiguous subset of the segments in a monotone chain
            is equal to the envelope of the endpoints of the subset.
            Property 1 means that there is no need to test pairs of segments from within
            the same monotone chain for intersection.
            Property 2 allows
            binary search to be used to find the intersection points of two monotone chains.
            For many types of real-world data, these properties eliminate a large number of
            segment comparisons, producing substantial speed gains.
            One of the goals of this implementation of MonotoneChains is to be
            as space and time efficient as possible. One design choice that aids this
            is that a MonotoneChain is based on a subarray of a list of points.
            This means that new arrays of points (potentially very large) do not
            have to be allocated.
            MonotoneChains support the following kinds of queries:
            Envelope select: determine all the segments in the chain which
            intersect a given envelope.
            Overlap: determine all the pairs of segments in two chains whose
            envelopes overlap.
            This implementation of MonotoneChains uses the concept of internal iterators
            to return the resultsets for the above queries.
            This has time and space advantages, since it
            is not necessary to build lists of instantiated objects to represent the segments
            returned by the query.
            However, it does mean that the queries are not thread-safe.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain.#ctor(MapWindow.Interfaces.Geometries.ICoordinate[],System.Int32,System.Int32,System.Object)">
            <summary>
            
            </summary>
            <param name="pts"></param>
            <param name="start"></param>
            <param name="end"></param>
            <param name="context"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain.GetLineSegment(System.Int32,MapWinGeoProc.NTS.Topology.Geometries.LineSegment@)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="ls"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain.Select(MapWindow.Interfaces.Geometries.IEnvelope,MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainSelectAction)">
            <summary> 
            Determine all the line segments in the chain whose envelopes overlap
            the searchEnvelope, and process them.
            </summary>
            <param name="searchEnv"></param>
            <param name="mcs"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain.ComputeSelect(MapWindow.Interfaces.Geometries.IEnvelope,System.Int32,System.Int32,MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainSelectAction)">
            <summary>
            
            </summary>
            <param name="searchEnv"></param>
            <param name="start0"></param>
            <param name="end0"></param>
            <param name="mcs"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain.ComputeOverlaps(MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain,MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainOverlapAction)">
            <summary>
            
            </summary>
            <param name="mc"></param>
            <param name="mco"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain.ComputeOverlaps(System.Int32,System.Int32,MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain,System.Int32,System.Int32,MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChainOverlapAction)">
            <summary>
            
            </summary>
            <param name="start0"></param>
            <param name="end0"></param>
            <param name="mc"></param>
            <param name="start1"></param>
            <param name="end1"></param>
            <param name="mco"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain.Id">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain.Context">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain.Envelope">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain.StartIndex">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain.EndIndex">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Chain.MonotoneChain.Coordinates">
            <summary>
            Return the subsequence of coordinates forming this chain.
            Allocates a new array to hold the Coordinates.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.ArrayListVisitor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.ArrayListVisitor.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.ArrayListVisitor.VisitItem(System.Object)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.ArrayListVisitor.Items">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.Utilities.LinearComponentExtracter">
            <summary> 
            Extracts all the 1-dimensional (<c>LineString</c>) components from a <c>Geometry</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.LinearComponentExtracter.GetLines(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary> 
            Extracts the linear components from a single point.
            If more than one point is to be processed, it is more
            efficient to create a single <c>LineExtracterFilter</c> instance
            and pass it to multiple geometries.
            </summary>
            <param name="geom">The point from which to extract linear components.</param>
            <returns>The list of linear components.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.LinearComponentExtracter.#ctor(System.Collections.IList)">
            <summary> 
            Constructs a LineExtracterFilter with a list in which to store LineStrings found.
            </summary>
            <param name="lines"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.LinearComponentExtracter.Filter(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays">
            <summary>
            Useful utility functions for handling Coordinate arrays.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays.PointNotInList(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[],MapWinGeoProc.NTS.Topology.Geometries.Coordinate[])">
            <summary>
            Finds a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> in a list of <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/>s 
            which is not contained in another list of <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/>s.
            </summary>
            <param name="testPts">The <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/>s to test.</param>
            <param name="pts">An array of <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/>s to test the input points against.</param>
            <returns>
            A <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> from <paramref name="testPts"/> 
            which is not in <paramref name="pts"/>, or <c>null</c>.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays.Compare(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[],MapWinGeoProc.NTS.Topology.Geometries.Coordinate[])">
            <summary>
            Compares two <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> arrays
            in the forward direction of their coordinates,
            using lexicographic ordering.
            </summary>
            <param name="pts1"></param>
            <param name="pts2"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays.IncreasingDirection(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Determines which orientation of the <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> array is (overall) increasing.
            In other words, determines which end of the array is "smaller"
            (using the standard ordering on <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/>).
            Returns an integer indicating the increasing direction.
            If the sequence is a palindrome, it is defined to be
            oriented in a positive direction.
            </summary>
            <param name="pts">The array of Coordinates to test.</param>
            <returns>
            <c>1</c> if the array is smaller at the start or is a palindrome,
            <c>-1</c> if smaller at the end.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays.IsEqualReversed(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[],MapWinGeoProc.NTS.Topology.Geometries.Coordinate[])">
            <summary>
            Determines whether two <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> arrays of equal length
            are equal in opposite directions.
            </summary>
            <param name="pts1"></param>
            <param name="pts2"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays.CopyDeep(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[])">
            <summary>
            Creates a deep copy of the argument <c>Coordinate</c> array.
            </summary>
            <param name="coordinates">Array of Coordinates.</param>
            <returns>Deep copy of the input.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays.ToCoordinateArray(System.Collections.IList)">
            <summary>
            Converts the given <see cref="T:System.Collections.IList"/> of 
            <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/>s into a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> array.
            </summary>
            <param name="coordList"><see cref="T:System.Collections.IList"/> of coordinates.</param>
            <returns></returns>
            <exception cref="T:System.InvalidCastException">
            If <paramref name="coordList"/> contains not only <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/>s.
            </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays.ToCoordinateArray(System.Collections.Generic.IList{MapWinGeoProc.NTS.Topology.Geometries.Coordinate})">
            <summary>
            Converts the given <see cref="T:System.Collections.IList"/> of 
            <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/>s into a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> array.
            </summary>
            <param name="coordList"><see cref="T:System.Collections.IList"/> of coordinates.</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays.HasRepeatedPoints(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Returns whether Equals returns true for any two consecutive
            coordinates in the given array.
            </summary>
            <param name="coord">Array of Coordinates.</param>
            <returns>true if coord has repeated points; false otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays.AtLeastNCoordinatesOrNothing(System.Int32,MapWinGeoProc.NTS.Topology.Geometries.Coordinate[])">
            <summary>
            Returns either the given coordinate array if its length is greater than
            the given amount, or an empty coordinate array.
            </summary>
            <param name="n">Length amount.</param>
            <param name="c">Array of Coordinates.</param>
            <returns>New Coordinate array.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays.RemoveRepeatedPoints(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            If the coordinate array argument has repeated points,
            constructs a new array containing no repeated points.
            Otherwise, returns the argument.
            </summary>
            <param name="coord"></param>
            <returns></returns>        
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays.Reverse(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Reverses the coordinates in an array in-place.
            </summary>
            <param name="coord">Array of Coordinates.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays.Equals(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[],MapWinGeoProc.NTS.Topology.Geometries.Coordinate[])">
            <summary>
            Returns <c>true</c> if the two arrays are identical, both <c>null</c>, or pointwise
            equal (as compared using Coordinate.Equals).
            </summary>
            <param name="coord1">First array of Coordinates.</param>
            <param name="coord2">Second array of Coordinates.</param>
            <returns><c>true</c> if two Coordinates array are equals; false otherwise</returns>
            <seealso cref="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.Equals(System.Object)"/>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays.Equals(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[],MapWinGeoProc.NTS.Topology.Geometries.Coordinate[],System.Collections.Generic.IComparer{MapWinGeoProc.NTS.Topology.Geometries.Coordinate[]})">
            <summary>
            Returns <c>true</c> if the two arrays are identical, both <c>null</c>, or pointwise
            equal, using a user-defined <see cref="T:System.Collections.IComparer"/> 
            for <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/>s.
            </summary>
            <param name="coord1">An array of <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/>s.</param>
            <param name="coord2">Another array of <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/>s.</param>
            <param name="coordinateComparer">
             A <see cref="T:System.Collections.IComparer"/> for <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/>s.
            </param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays.MinCoordinate(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Returns the minimum coordinate, using the usual lexicographic comparison.
            </summary>
            <param name="coordinates">Array to search.</param>
            <returns>The minimum coordinate in the array, found using <c>CompareTo</c>.</returns>
            <seeaalso cref="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.CompareTo(System.Object)"/>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays.Scroll(MapWindow.Interfaces.Geometries.ICoordinate[],MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Shifts the positions of the coordinates until <c>firstCoordinate</c> is first.
            </summary>
            <param name="coordinates">Array to rearrange.</param>
            <param name="firstCoordinate">Coordinate to make first.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays.IndexOf(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Returns the index of <paramref name="coordinate"/> in <paramref name="coordinates"/>.
            The first position is 0; the second is 1; etc.
            </summary>
            <param name="coordinate">A <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> to search for.</param>
            <param name="coordinates">A <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> array to search.</param>
            <returns>The position of <c>coordinate</c>, or -1 if it is not found.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays.Extract(MapWindow.Interfaces.Geometries.ICoordinate[],System.Int32,System.Int32)">
            <summary>
            Extracts a subsequence of the input <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> array
            from indices <paramref name="start"/> to <paramref name="end"/> (inclusive).
            </summary>
            <param name="pts">The input array.</param>
            <param name="start">The index of the start of the subsequence to extract.</param>
            <param name="end">The index of the end of the subsequence to extract.</param>
            <returns>A subsequence of the input array.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays.ForwardComparator">
            <summary>
            Compares two <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> arrays
            in the forward direction of their coordinates,
            using lexicographic ordering.
            </summary>        
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays.ForwardComparator.Compare(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[],MapWinGeoProc.NTS.Topology.Geometries.Coordinate[])">
            <summary>
            Compares the specified <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/>s arrays.
            </summary>
            <param name="pts1"></param>
            <param name="pts2"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays.BidirectionalComparator">
            <summary>
            A comparator for <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> arrays modulo their directionality.
            E.g. if two coordinate arrays are identical but reversed
            they will compare as equal under this ordering.
            If the arrays are not equal, the ordering returned
            is the ordering in the forward direction.
            </summary>        
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays.BidirectionalComparator.Compare(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[],MapWinGeoProc.NTS.Topology.Geometries.Coordinate[])">
            <summary>
            
            </summary>
            <param name="pts1"></param>
            <param name="pts2"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArrays.BidirectionalComparator.OLDcompare(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[],MapWinGeoProc.NTS.Topology.Geometries.Coordinate[])">
            <summary>
            
            </summary>
            <param name="pts1"></param>
            <param name="pts2"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SweepLineSegment">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SweepLineSegment.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge,System.Int32)">
            <summary>
            
            </summary>
            <param name="edge"></param>
            <param name="ptIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SweepLineSegment.ComputeIntersections(MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SweepLineSegment,MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector)">
            <summary>
            
            </summary>
            <param name="ss"></param>
            <param name="si"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SweepLineSegment.MinX">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SweepLineSegment.MaxX">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleMCSweepLineIntersector">
            <summary> 
            Finds all intersections in one or two sets of edges,
            using an x-axis sweepline algorithm in conjunction with Monotone Chains.
            While still O(n^2) in the worst case, this algorithm
            drastically improves the average-case time.
            The use of MonotoneChains as the items in the index
            seems to offer an improvement in performance over a sweep-line alone.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleMCSweepLineIntersector.#ctor">
            <summary>
            A SimpleMCSweepLineIntersector creates monotone chains from the edges
            and compares them using a simple sweep-line along the x-axis.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleMCSweepLineIntersector.ComputeIntersections(System.Collections.IList,MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector,System.Boolean)">
            <summary>
            
            </summary>
            <param name="edges"></param>
            <param name="si"></param>
            <param name="testAllSegments"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleMCSweepLineIntersector.ComputeIntersections(System.Collections.IList,System.Collections.IList,MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector)">
            <summary>
            
            </summary>
            <param name="edges0"></param>
            <param name="edges1"></param>
            <param name="si"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleMCSweepLineIntersector.Add(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="edges"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleMCSweepLineIntersector.Add(System.Collections.IList,System.Object)">
            <summary>
            
            </summary>
            <param name="edges"></param>
            <param name="edgeSet"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleMCSweepLineIntersector.Add(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge,System.Object)">
            <summary>
            
            </summary>
            <param name="edge"></param>
            <param name="edgeSet"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleMCSweepLineIntersector.PrepareEvents">
            <summary>
            Because Delete Events have a link to their corresponding Insert event,
            it is possible to compute exactly the range of events which must be
            compared to a given Insert event object.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleMCSweepLineIntersector.ComputeIntersections(MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector)">
            <summary>
            
            </summary>
            <param name="si"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleMCSweepLineIntersector.ProcessOverlaps(System.Int32,System.Int32,MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SweepLineEvent,MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector)">
            <summary>
            
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <param name="ev0"></param>
            <param name="si"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.startDe">
            <summary>
            The directed edge which starts the list of edges for this EdgeRing.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.geometryFactory">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge,MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            
            </summary>
            <param name="start"></param>
            <param name="geometryFactory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.GetCoordinate(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.AddHole(MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing)">
            <summary>
            
            </summary>
            <param name="ring"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.ToPolygon(MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            
            </summary>
            <param name="geometryFactory"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.ComputeRing">
            <summary>
            Compute a LinearRing from the point list previously collected.
            Test if the ring is a hole (i.e. if it is CCW) and set the hole flag
            accordingly.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.GetNext(MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge)">
            <summary>
            
            </summary>
            <param name="de"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.SetEdgeRing(MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge,MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing)">
            <summary>
            
            </summary>
            <param name="de"></param>
            <param name="er"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.ComputePoints(MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge)">
            <summary> 
            Collect all the points from the DirectedEdges of this ring into a contiguous list.
            </summary>
            <param name="start"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.ComputeMaxNodeDegree">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.SetInResult">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.MergeLabel(MapWinGeoProc.NTS.Topology.GeometriesGraph.Label)">
            <summary>
            
            </summary>
            <param name="deLabel"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.MergeLabel(MapWinGeoProc.NTS.Topology.GeometriesGraph.Label,System.Int32)">
            <summary> 
            Merge the RHS label from a DirectedEdge into the label for this EdgeRing.
            The DirectedEdge label may be null.  This is acceptable - it results
            from a node which is NOT an intersection node between the Geometries
            (e.g. the end node of a LinearRing).  In this case the DirectedEdge label
            does not contribute any information to the overall labelling, and is simply skipped.
            </summary>
            <param name="deLabel"></param>
            <param name="geomIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.AddPoints(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="edge"></param>
            <param name="isForward"></param>
            <param name="isFirstEdge"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.ContainsPoint(MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary> 
            This method will cause the ring to be computed.
            It will also check any holes, if they have been assigned.
            </summary>
            <param name="p"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.IsIsolated">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.IsHole">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.LinearRing">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.Label">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.IsShell">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.Shell">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.Edges">
            <summary> 
            Returns the list of DirectedEdges that make up this EdgeRing.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing.MaxNodeDegree">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.RobustLineIntersector">
            <summary> 
            A robust version of <c>LineIntersector</c>.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector">
            <summary> 
            A LineIntersector is an algorithm that can both test whether
            two line segments intersect and compute the intersection point
            if they do.
            The intersection point may be computed in a precise or non-precise manner.
            Computing it precisely involves rounding it to an integer.  (This assumes
            that the input coordinates have been made precise by scaling them to
            an integer grid.)
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.DontIntersect">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.DoIntersect">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.Collinear">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.ComputeEdgeDistance(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary> 
            Computes the "edge distance" of an intersection point p along a segment.
            The edge distance is a metric of the point along the edge.
            The metric used is a robust and easy to compute metric function.
            It is not equivalent to the usual Euclidean metric.
            It relies on the fact that either the x or the y ordinates of the
            points in the edge are unique, depending on whether the edge is longer in
            the horizontal or vertical direction.
            NOTE: This function may produce incorrect distances
            for inputs where p is not precisely on p1-p2
            (E.g. p = (139,9) p1 = (139,10), p2 = (280,1) produces distanct 0.0, which is incorrect.
            My hypothesis is that the function is safe to use for points which are the
            result of rounding points which lie on the line, but not safe to use for truncated points.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.NonRobustComputeEdgeDistance(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            This function is non-robust, since it may compute the square of large numbers.
            Currently not sure how to improve this.
            </summary>
            <param name="p"></param>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.result">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.inputLines">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.intPt">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.intLineIndex">
            <summary> 
            The indexes of the endpoints of the intersection lines, in order along
            the corresponding line
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.isProper">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.pa">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.pb">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.precisionModel">
            <summary> 
            If MakePrecise is true, computed intersection coordinates will be made precise
            using <c>Coordinate.MakePrecise</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.ComputeIntersection(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary> 
            Compute the intersection of a point p and the line p1-p2.
            This function computes the bool value of the hasIntersection test.
            The actual value of the intersection (if there is one)
            is equal to the value of <c>p</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.ComputeIntersection(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Computes the intersection of the lines p1-p2 and p3-p4.
            This function computes both the bool value of the hasIntersection test
            and the (approximate) value of the intersection point itself (if there is one).
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.ComputeIntersect(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="q1"></param>
            <param name="q2"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.GetIntersection(System.Int32)">
            <summary> 
            Returns the intIndex'th intersection point.
            </summary>
            <param name="intIndex">is 0 or 1.</param>
            <returns>The intIndex'th intersection point.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.ComputeIntLineIndex">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.IsIntersection(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary> 
            Test whether a point is a intersection point of two line segments.
            Note that if the intersection is a line segment, this method only tests for
            equality with the endpoints of the intersection segment.
            It does not return true if the input point is internal to the intersection segment.
            </summary>
            <returns><c>true</c> if the input point is one of the intersection points.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.IsInteriorIntersection">
            <summary> 
            Tests whether either intersection point is an interior point of one of the input segments.
            </summary>
            <returns>
            <c>true</c> if either intersection point is in the interior of one of the input segment.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.IsInteriorIntersection(System.Int32)">
            <summary>
            Tests whether either intersection point is an interior point of the specified input segment.
            </summary>
            <returns> 
            <c>true</c> if either intersection point is in the interior of the input segment.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.GetIntersectionAlongSegment(System.Int32,System.Int32)">
            <summary> 
            Computes the intIndex'th intersection point in the direction of
            a specified input line segment.
            </summary>
            <param name="segmentIndex">is 0 or 1.</param>
            <param name="intIndex">is 0 or 1.</param>
            <returns>
            The intIndex'th intersection point in the direction of the specified input line segment.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.GetIndexAlongSegment(System.Int32,System.Int32)">
            <summary>
            Computes the index of the intIndex'th intersection point in the direction of
            a specified input line segment.
            </summary>
            <param name="segmentIndex">is 0 or 1.</param>
            <param name="intIndex">is 0 or 1.</param>
            <returns>
            The index of the intersection point along the segment (0 or 1).
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.ComputeIntLineIndex(System.Int32)">
            <summary>
            
            </summary>
            <param name="segmentIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.GetEdgeDistance(System.Int32,System.Int32)">
            <summary> 
            Computes the "edge distance" of an intersection point along the specified input line segment.
            </summary>
            <param name="segmentIndex">is 0 or 1.</param>
            <param name="intIndex">is 0 or 1.</param>
            <returns>The edge distance of the intersection point.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.MakePrecise">
            <summary>
            Force computed intersection to be rounded to a given precision model
            </summary>        
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.PrecisionModel">
            <summary> 
            Force computed intersection to be rounded to a given precision model.
            No getter is provided, because the precision model is not required to be specified.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.IsCollinear">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.IsEndPoint">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.HasIntersection">
            <summary> 
            Tests whether the input geometries intersect.
            </summary>
            <returns><c>true</c> if the input geometries intersect.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.IntersectionNum">
            <summary>
            Returns the number of intersection points found.  This will be either 0, 1 or 2.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector.IsProper">
            <summary>
            Tests whether an intersection is proper.
            The intersection between two line segments is considered proper if
            they intersect in a single point in the interior of both segments
            (e.g. the intersection is a single point and is not equal to any of the endpoints). 
            The intersection between a point and a line segment is considered proper
            if the point lies in the interior of the segment (e.g. is not equal to either of the endpoints).
            </summary>
            <returns><c>true</c>  if the intersection is proper.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.RobustLineIntersector.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.RobustLineIntersector.ComputeIntersection(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="p"></param>
            <param name="p1"></param>
            <param name="p2"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.RobustLineIntersector.ComputeIntersect(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="q1"></param>
            <param name="q2"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.RobustLineIntersector.ComputeCollinearIntersection(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="q1"></param>
            <param name="q2"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.RobustLineIntersector.Intersection(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary> 
            This method computes the actual value of the intersection point.
            To obtain the maximum precision from the intersection calculation,
            the coordinates are normalized by subtracting the minimum
            ordinate values (in absolute value).  This has the effect of
            removing common significant digits from the calculation to
            maintain more bits of precision.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="q1"></param>
            <param name="q2"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.RobustLineIntersector.NormalizeToMinimum(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="n1"></param>
            <param name="n2"></param>
            <param name="n3"></param>
            <param name="n4"></param>
            <param name="normPt"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.RobustLineIntersector.NormalizeToEnvCentre(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
             Normalize the supplied coordinates to
            so that the midpoint of their intersection envelope
            lies at the origin.
            </summary>
            <param name="n00"></param>
            <param name="n01"></param>
            <param name="n10"></param>
            <param name="n11"></param>
            <param name="normPt"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.RobustLineIntersector.SmallestInAbsValue(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="x1"></param>
            <param name="x2"></param>
            <param name="x3"></param>
            <param name="x4"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.RobustLineIntersector.IsInSegmentEnvelopes(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary> 
            Test whether a point lies in the envelopes of both input segments.
            A correctly computed intersection point should return <c>true</c>
            for this test.
            Since this test is for debugging purposes only, no attempt is
            made to optimize the envelope test.
            </summary>
            <param name="intPt"></param>
            <returns><c>true</c> if the input point lies within both input segment envelopes.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointPoint">
            <summary> 
            Computes a point in the interior of an point point.
            Algorithm:
            Find a point which is closest to the centroid of the point.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointPoint.#ctor(MapWinGeoProc.NTS.Topology.Geometries.Geometry)">
            <summary>
            
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointPoint.Add(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary> 
            Tests the point(s) defined by a Geometry for the best inside point.
            If a Geometry is not of dimension 0 it is not tested.
            </summary>
            <param name="geom">The point to add.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointPoint.Add(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="point"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointPoint.InteriorPoint">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.MapWinException">
            <summary>
            This class can be used to efficiently specify an appropriate exception
            based on the error code returned by any of the MapWinGIS classes
            </summary>
        </member>
        <member name="M:MapWinGeoProc.MapWinException.#ctor(System.Int32)">
            <summary>
            This creates a new MapWinException given an error code from one of the MapWinGIS objects
            </summary>
            <param name="errorCode">int The error code returned from the LastErrorCode method</param>
        </member>
        <member name="M:MapWinGeoProc.MapWinException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Creates a MapWinException from Serialized data
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:MapWinGeoProc.MapWinException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serializes this object
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:MapWinGeoProc.MapWinException.GetErrorMessage(System.Int32)">
            <summary>
            Returns the error message that belongs to a particular error code
            </summary>
            <param name="ErrorCode">Integer, the numeric code for the error</param>
            <returns>String, a Message for the specified error</returns>
        </member>
        <member name="P:MapWinGeoProc.MapWinException.ErrorCode">
            <summary>
            Gets the numerical equivalent for the Error Code based on the MapWinGIS
            </summary>
        </member>
        <member name="T:MapWinGeoProc.SpatialReference">
            <summary>
            Projects all points in a grid or shapefile from the original
            coordinate system to a new coordinate system using Proj.4 (proj.dll).
            </summary>
        </member>
        <member name="M:MapWinGeoProc.SpatialReference.ProjectGrid(System.String@,System.String@,System.String@,System.String@,System.Boolean)">
            <summary>
            Transforms a grid from one coordinate system to another.
            </summary>
            <param name="sourceProj">Proj.4 initialization string for input coordinate system.</param>
            <param name="destProj">Proj.4 initialization string for output coordinate system.</param>
            <param name="inputGrid">The full path to the input grid file.</param>
            <param name="resultGrid">The full path to where the result grid file will be saved.</param>
            <param name="trimResult">True if user wants excess rows/columns of NoData removed from result. Ensures minimum file size.</param>
            <returns>True if projection was successful, false if an error occurs.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialReference.ProjectGrid(System.String@,System.String@,System.String@,System.String@,System.Boolean,MapWinGIS.ICallback)">
            <summary>
            Transforms a grid from one coordinate system to another.
            </summary>
            <param name="sourceProj">Proj.4 initialization string for input coordinate system.</param>
            <param name="destProj">Proj.4 initialization string for output coordinate system.</param>
            <param name="inputGrid">The full path to the input grid file.</param>
            <param name="resultGrid">The full path to where the result grid file will be saved.</param>
            <param name="trimResult">True if user wants excess rows/columns of NoData removed from result. Ensures minimum file size.</param>
            <param name="ICallBack">A MapWinGIS ICallBack for status messages</param>
            <returns>True if projection was successful, false if an error occurs.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialReference.ReprojectLabels(System.String,System.String,System.String,System.String)">
            <summary>
            Reproject the location of labels in the specified file.
            </summary>
            <param name="src">Source filename (.lbl file)</param>
            <param name="dst">Destination filename (.lbl file)</param>
            <param name="srcproj">Source projection (proj4 format)</param>
            <param name="dstproj">Destination projection (proj4 format)</param>
        </member>
        <member name="M:MapWinGeoProc.SpatialReference.FillGrid(System.String@,System.String@,System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,MapWinGIS.ICallback)">
            <summary>
            Fills the result grid with values from the input grid.
            </summary>
            <param name="inputGF">The path to the input grid.</param>
            <param name="resultGF">The path to the result grid.</param>
            <param name="newNumRows">The number of rows in the result grid.</param>
            <param name="newNumCols">The number of cols in the result grid.</param>
            <param name="rowClearCount">The number of rows that should be filled before
            <param name="newXll">The Xll center of the result grid.</param>
            <param name="newYll">The Yll center of the result grid.</param>
            <param name="cellSize">The calculated size of a cell in the result grid.</param>
            <param name="oldXll">The Xll center of the input grid.</param>
            <param name="oldYll">The Yll center of the input grid.</param>
            <param name="oldDx">The dX value of the input grid.</param>
            <param name="oldDy">The dY value of the input grid.</param>
            <param name="ICallBack">A MapWinGIS ICallback for status messages</param>
            the unmanaged resources are disposed of.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialReference.ProjectGrid(System.String@,System.String@,MapWinGIS.Grid@,MapWinGIS.Grid@,System.Boolean)">
            <summary>
            Transforms a grid from one coordinate system to another.
            For large grids (>50MB) use the save-to-file version of this function. 
            </summary>
            <param name="sourceProj">Proj.4 initialization string for input coordinate system.</param>
            <param name="destProj">Proj.4 initialization string for output coordinate system.</param>
            <param name="inputGrid">The reference to the in-memory input grid.</param>
            <param name="resultGrid">The output parameter resultGrid which will reside in memory.</param>
            <param name="trimResult">True if user wants excess rows/columns of NoData removed from result. Ensures minimum file size.</param>
            <returns>True if projection was successful, false if an error occurs.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialReference.ProjectGrid(System.String@,System.String@,MapWinGIS.Grid@,MapWinGIS.Grid@,System.Boolean,MapWinGIS.ICallback)">
            <summary>
            Transforms a grid from one coordinate system to another.
            For large grids (>50MB) use the save-to-file version of this function. 
            </summary>
            <param name="sourceProj">Proj.4 initialization string for input coordinate system.</param>
            <param name="destProj">Proj.4 initialization string for output coordinate system.</param>
            <param name="inputGrid">The reference to the in-memory input grid.</param>
            <param name="resultGrid">The output parameter resultGrid which will reside in memory.</param>
            <param name="trimResult">True if user wants excess rows/columns of NoData removed from result. Ensures minimum file size.</param>
            <param name="ICallBack">A MapWinGIS.ICallback for progress messages </param>
            <returns>True if projection was successful, false if an error occurs.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialReference.memory_ProjectGrid(System.String@,System.String@,MapWinGIS.Grid@,MapWinGIS.Grid@,System.Boolean,MapWinGIS.ICallback)">
            <summary>
            In memory version
            </summary>
            <param name="sourceProj">Source Projection </param>
            <param name="destProj">Destination Projection</param>
            <param name="inputGrid">MapWinGIS.Grid to project</param>
            <param name="resultGrid">MapWinGIS.Grid after projection</param>
            <param name="trimResult">Boolean True if the result should be trimmed</param>
            <param name="ICallBack">A MapWinGIS.ICallback for status and error messages</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialReference.ProjectImage(System.String,System.String,System.String,System.String,MapWinGIS.ICallback)">
            <summary>
            Transforms a grid from one coordinate system to another.
            
            </summary>
            <param name="sourceProj">Proj.4 initialization string for input coordinate system.</param>
            <param name="destProj">Proj.4 initialization string for output coordinate system.</param>
            <param name="inputImage">The full path to the input image file.</param>
            <param name="resultImage">The full path to where the result image file will be saved.</param>
            <param name="ICallBack">An ICallback interface for progress and error messages</param>
            <remarks>throws exceptions in the case of errors</remarks>
        </member>
        <member name="M:MapWinGeoProc.SpatialReference.RectifyToWorldFile(System.String,System.String,MapWinGIS.ICallback)">
            <summary>
            Arcview will create worldfiles with rotational/skew terms that are not explicitly stored
            in the image, but rather are stored as coefficients in the world file.  This function
            creates an output image that is rectfied so that it has 0 for the rotational terms, 
            but should have the same positioning as the original image.
            </summary>
            <param name="inputImage">String sourcefile to be rectified.</param>
            <param name="resultImage">(Optional) ouput filename.  Default is inputImage + "_Rect"</param>
            <param name="ICallBack">A MapWinGIS.ICallback interface object for progress messages.</param>
        </member>
        <member name="M:MapWinGeoProc.SpatialReference.GetUTMZone(System.Double)">
            <summary>
            Returns an appropriate UTM zone given a longitude in degrees.
            </summary>
            <param name="Degrees_Longitude">Degrees of longitude that you need a UTM zone for.</param>
            <returns>Returns an integer for the appropriate UTM zone; e.g. "12" for UTM Zone 12</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialReference.ProjectShapefile(System.String@,System.String@,System.String@,System.String@)">
            <summary>
            Transforms a shapefile from one coordinate system to another. 
            This version saves the new result shapefile to disk.
            </summary>
            <param name="sourceProj">Proj.4 initialization string for input coordinate system.</param>
            <param name="destProj">Proj.4 initialization string for output coordinate system.</param>
            <param name="inputSF">The full path to the input shapefile that will be projected.</param>
            <param name="resultSF">The full path to where the projected result shapefile will be saved.</param>
            <returns>True if projection was successful, false if an error occurs.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialReference.ProjectShapefile(System.String@,System.String@,System.String@)">
            <summary>
            Transforms a shapefile from one coordinate system to another. 
            This version saves the new result shapefile to disk.
            The source projection is inferred from the input shapefile. If the
            .prj file is missing, the function will return false.
            </summary>
            <param name="destProj">Proj.4 initialization string for output coordinate system.</param>
            <param name="inputSF">The full path to the input shapefile that will be projected.</param>
            <param name="resultSF">The full path to where the projected result shapefile will be saved.</param>
            <returns>True if projection was successful, false if an error occurs.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialReference.ProjectShapefile(System.String@,MapWinGIS.Shapefile@,MapWinGIS.Shapefile@)">
            <summary>
            Transforms a shapefile from one coordinate system to another. 
            This version saves the new result shapefile to disk.
            The source projection is inferred from the input shapefile. If the
            .prj file is missing, the function will return false.
            </summary>
            <param name="destProj">Proj.4 initialization string for output coordinate system.</param>
            <param name="inputSF">The input shapefile that will be projected.</param>
            <param name="resultSF">The result shapefile.</param>
            <returns>True if projection was successful, false if an error occurs.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialReference.ProjectShapefile(System.String@,System.String@,MapWinGIS.Shapefile@)">
            <summary>
            Transforms a shapefile from one coordinate system to another.
            This version over-writes the original shapefile.
            </summary>
            <param name="sourceProj">Proj.4 initialization string for input coordinate system.</param>
            <param name="destProj">Proj.4 initialization string for output coordinate system.</param>
            <param name="shpFile">The full path to the shapefile that will be projected and over-written.</param>
            <returns>True if projection was successful, false if an error occurs.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialReference.ProjectShapefile(System.String@,System.String@,MapWinGIS.Shapefile@,MapWinGIS.Shapefile@)">
            <summary>
            Transforms a shapefile from one coordinate system to another. 
            This version saves the result shapefile in memory.
            </summary>
            <param name="sourceProj">Proj.4 initialization string for input coordinate system.</param>
            <param name="destProj">Proj.4 initialization string for output coordinate system.</param>
            <param name="inputSF">Reference to input shapefile loaded in memory.</param>
            <param name="resultSF">Out parameter for projected shapefile results residing in memory.</param>
            <returns>True if projection was successful, false if an error occurs.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialReference.Distance(System.Double,System.Double)">
            <summary>
            Computes the distance between two values. Minimizes
            the chance of overflow by not taking the square of any number.
            </summary>
            <param name="v1">The first value.</param>
            <param name="v2">The second value.</param>
            <returns>The distance between the first and second value.</returns>	
        </member>
        <member name="M:MapWinGeoProc.SpatialReference.ConvertAndProjectPoint(System.Double@,System.Double@)">
            <summary>
            Projects a 2D point from one coordinate system to another
            using Proj.4 function: pj_transform.
            This function assumes that the caller has already checked to see
            if conversion to radians or degrees is necessary, then performs
            the necessary conversion before or after projecting the point.
            </summary>
            <param name="x">X value of point to project.</param>
            <param name="y">Y value of point to project.</param>
            <returns>True if projection was successful, false if an error was encountered.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialReference.ConvertAndProjectPoint(MapWinGIS.Point)">
            <summary>
            Projects a 2D point from one coordinate system to another
            using Proj.4 function: pj_transform.
            This function assumes that the caller has already checked to see
            if conversion to radians or degrees is necessary, then performs
            the necessary conversion before or after projecting the point.
            Call InitializeGlobals before this.
            </summary>
            <param name="InputPoint">A MapWinGIS.Point specifying the point to transform.</param>
            <returns>A MapWinGIS.Point containing the projected information</returns>
            <remarks>Will throw an Application exception if there is an error.</remarks>
        </member>
        <member name="M:MapWinGeoProc.SpatialReference.ProjectPoint(System.Double@,System.Double@,System.String,System.String)">
            <summary>
            Projects a 2D point from one coordinate system to another
            using Proj.4 function: pj_transform.
            </summary>
            <param name="x">X value of point to project.</param>
            <param name="y">Y value of point to project.</param>
            <param name="srcPrj4String">Source projection string (proj4 format)</param>
            <param name="destPrj4String">Destination projection string (proj4 format)</param>
            <returns>True if projection was successful, false if an error was encountered.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialReference.FreeProjPointers">
            <summary>
            Releases memory used by the srcPrj and destPrj structures.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.SpatialReference.GetErrorMsg(System.Int32)">
            <summary>
            Returns the error message associated with prj_transform.
            </summary>
            <param name="retcode">The return value of prj_transform.</param>
            <returns>The message string corresponding to a known error.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialReference.InitializeGlobalVariables(System.String@,System.String@)">
            <summary>
            Sets the global projection variables: srcPrj, destPrj, convertToRadians, and convertToDegrees.
            </summary>
            <param name="sourceProj">The proj4 source projection.</param>
            <param name="destProj">The proj4 destination projection.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="T:MapWinGeoProc.SpatialJoinTypes">
            <summary>
            An enumeration which is intended to eventually contain a list of spatial join types (only nearest is supported)
            </summary>
        </member>
        <member name="F:MapWinGeoProc.SpatialJoinTypes.Nearest">
            <summary>
            An enum element representing the Nearest topology operation
            </summary>
        </member>
        <member name="T:MapWinGeoProc.SpatialOperations">
            <summary>
            Contains public methods for users to clip grids and shapes with.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.ClipGridWithPolygon(System.String@,MapWinGIS.Shape@,System.String@)">
            <summary>
            Creates a new grid containing data from the input grid that
            falls within the polygon shape.
            </summary>
            <param name="inputGFPath">Full path to the input grid file.</param>
            <param name="polygon">The 2D polygon used for clipping the input grid.</param>
            <param name="resultGFPath">Full path to where the resulting grid will be saved.</param>
            <returns>True if clipping was successful, false otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.ClipGridWithPolygon(System.String@,MapWinGIS.Shape@,System.String@,System.Boolean)">
            <summary>
            Creates a new grid containing data from the input grid that
            falls within the polygon shape or within the polygon extents.
            </summary>
            <param name="inputGFPath">Full path to the input grid file.</param>
            <param name="polygon">The 2D polygon used for clipping the input grid.</param>
            <param name="resultGFPath">Full path to where the resulting grid will be saved.</param>
            <param name="clipToExtents">True if clipping to polygon extents rather than actual polygon shape.</param>
            <returns>True if clipping was successful, false otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.SelectWithPolygon(System.String@,MapWinGIS.Shape@,System.String@)">
            <summary>
            Selects all points/lines/polygons in the input shapefile that intersect the polygon shape.
            Returns the selected shapes in a new shapefile.
            </summary>
            <param name="inputSFPath">The full path to the shapefile containing shapes for selection.</param>
            <param name="polygon">The polygon used for selecting shapes from the shapefile.</param>
            <param name="resultSFPath">The full path to where the selected shapes should be saved.</param>
            <returns>False if an error was encountered or no shapes selected, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.SelectWithPolygon(System.String@,MapWinGIS.Shape@,System.String@,System.Boolean)">
            <summary>
            Selects all points/lines/polygons in the input shapefile that intersect the polygon shape.
            Returns the selected shapes in a new shapefile.
            </summary>
            <param name="inputSFPath">The full path to the shapefile containing shapes for selection.</param>
            <param name="polygon">The polygon used for selecting shapes from the shapefile.</param>
            <param name="resultSFPath">The full path to where the selected shapes should be saved.</param>
            <param name="SkipMWShapeID">Indicates whether to skip creating an MWShapeID field in the result.</param>
            <returns>False if an error was encountered or no shapes selected, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.SelectWithPolygon(System.String@,MapWinGIS.Shape@,System.Collections.ArrayList@)">
            <summary>
            Selects all points/lines/polygons in the input shapefile that intersect the polygon shape.
            Returns the indexes of the shapes that are found to fall in or cross the polygon.
            </summary>
            <param name="inputSFPath">The full path to the shapefile containing shapes for selection.</param>
            <param name="polygon">The polygon used for selecting shapes from the shapefile.</param>
            <param name="results">An arraylist of the resulting shape indices.</param>
            <returns>False if no shapes were found, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.ClipShapesWithPolygon(System.String@,MapWinGIS.Shape@,System.String@)">
            <summary>
            Saves all points/lines/polygons within the polygon's border to a new shapefile.
            </summary>
            <param name="inputSFPath">Full path to the input shapefile that will be clipped.</param>
            <param name="polygon">2D polygon used for clipping objects in inputSF.</param>
            <param name="resultSFPath">Full path to where the resulting shapefile should be saved.</param>
            <returns>True if clipping was successful, false if an error was encountered.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.ClipShapesWithPolygon(System.String@,MapWinGIS.Shape@,System.String@,System.Boolean)">
            <summary>Saves all points/lines/polygons within the polygon's border to a new shapefile.</summary>
            <param name="inputSFPath">Full path to the input shapefile that will be clipped.</param>
            <param name="polygon">2D polygon used for clipping objects in inputSF.</param>
            <param name="resultSFPath">Full path to where the resulting shapefile should be saved.</param>
            <param name="speedOptimized">True if speed of computation is more important than accuracy when dealing with line shapefiles.</param>
            <returns>True if clipping was successful, false if an error was encountered.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.ClipShapesWithPolygon(System.String@,MapWinGIS.Shape@,System.String@,System.Boolean,System.Boolean)">
            <summary>Saves all points/lines/polygons within the polygon's border to a new shapefile.</summary>
            <param name="inputSFPath">Full path to the input shapefile that will be clipped.</param>
            <param name="polygon">2D polygon used for clipping objects in inputSF.</param>
            <param name="resultSFPath">Full path to where the resulting shapefile should be saved.</param>
            <param name="speedOptimized">True if speed of computation is more important than accuracy when dealing with line shapefiles.</param>
            <param name="copyAttributes">True if copying Attributes</param>
            <returns>True if clipping was successful, false if an error was encountered.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.ClipShapesWithPolygon(MapWinGIS.Shapefile@,MapWinGIS.Shape@,MapWinGIS.Shapefile@)">
            <summary>Returns all points/lines/polygons inside the polygon's border as a new shapefile (in memory).</summary>
            <param name="inputSF">Input shapefile of lines, points, or polygons in need of clipping.</param>
            <param name="polygon">2D polygon shape used for clipping the shapefile.</param>
            <param name="resultSF">Output polygon shapefile which will contain all shapes that fall inside the boundaries of poly.</param>
            <returns>True if clipping was successful, false if an error occured. </returns> 
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.ClipShapesWithPolygon(MapWinGIS.Shapefile@,MapWinGIS.Shape@,MapWinGIS.Shapefile@,System.Boolean)">
            <summary>Returns all points/lines/polygons inside the polygon's border as a new shapefile (in memory).</summary>
            <param name="inputSF">Input shapefile of lines, points, or polygons in need of clipping.</param>
            <param name="polygon">2D polygon shape used for clipping the shapefile.</param>
            <param name="resultSF">Output polygon shapefile which will contain all shapes that fall inside the boundaries of poly.</param>
            <param name="speedOptimized">True if speed of computation is more important than accuracy when dealing with line shapefiles.</param>
            <returns>True if clipping was successful, false if an error occured. </returns> 
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.ClipShapesWithPolygon(MapWinGIS.Shapefile@,MapWinGIS.Shape@,MapWinGIS.Shapefile@,System.Boolean,System.Boolean)">
            <summary>Returns all points/lines/polygons inside the polygon's border as a new shapefile (in memory).</summary>
            <param name="inputSF">Input shapefile of lines, points, or polygons in need of clipping.</param>
            <param name="polygon">2D polygon shape used for clipping the shapefile.</param>
            <param name="resultSF">Output polygon shapefile which will contain all shapes that fall inside the boundaries of poly.</param>
            <param name="speedOptimized">True if speed of computation is more important than accuracy when dealing with line shapefiles.</param>
            <param name="copyAttributes">True if copying attributes over</param>
            <returns>True if clipping was successful, false if an error occured. </returns> 
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.ClipPolygonSFWithLineSF(MapWinGIS.Shapefile@,MapWinGIS.Shapefile@,MapWinGIS.Shapefile@)">
            <summary>
            In Development: Prone to errors! 
            For clipping multiple polygons with multiple lines.
            </summary>
            <param name="polySF">The polygon shapefile.</param>
            <param name="lineSF">The line shapefile.</param>
            <param name="resultSF">The result shapefile containing the polygon sections.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.ClipPolygonWithLine(MapWinGIS.Shape@,MapWinGIS.Shape@,System.String@)">
            <summary>
            Divides a polygon into multiple sections depending on where a line crosses it. Saves the resulting
            polygon sections to a new polygon shapefile.
            </summary>
            <param name="polygon">The polygon to be divided.</param>
            <param name="line">The line that will be used to divide the polgyon.</param>
            <param name="resultSFPath">The full path to where the resulting polygons should be saved.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.ClipPolygonWithLine(MapWinGIS.Shape@,MapWinGIS.Shape@,MapWinGIS.Shapefile@)">
            <summary>
            Divides a polygon into multiple sections depending on where a line crosses it. Saves the resulting
            polygon sections to a new polygon shapefile.
            </summary>
            <param name="polygon">The polygon to be divided.</param>
            <param name="line">The line that will be used to divide the polgyon.</param>
            <param name="resultSF">The in-memory shapefile where resulting polygons should be saved.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.ClipPolygonWithLine(MapWinGIS.Shape@,MapWinGIS.Shape@,System.String@,System.Boolean)">
            <summary>
            Divides a polygon into multiple sections depending on where a line crosses it. Saves the resulting
            polygon sections to a new polygon shapefile.
            </summary>
            <param name="polygon">The polygon to be divided.</param>
            <param name="line">The line that will be used to divide the polgyon.</param>
            <param name="resultSFPath">The full path to where the resulting polygons should be saved.</param>
            <param name="speedOptimized">True if a line follows the assumption that only one intersection
            occurs for any 2pt segment. And only 2pt segments that have a point inside->outside or outside->inside
            will be tested for interesection.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.ClipPolygonWithLine(MapWinGIS.Shape@,MapWinGIS.Shape@,MapWinGIS.Shapefile@,System.Boolean)">
            <summary>
            Divides a polygon into multiple sections depending on where a line crosses it. Saves the resulting
            polygon sections to a new polygon shapefile.
            </summary>
            <param name="polygon">The polygon to be divided.</param>
            <param name="line">The line that will be used to divide the polgyon.</param>
            <param name="resultSF">The in-memory shapefile where resulting polygons should be saved.</param>
            <param name="speedOptimized">True if a line follows the assumption that only one intersection
            occurs for any 2pt segment. And only 2pt segments that have a point inside->outside or outside->inside
            will be tested for interesection.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.Difference(MapWinGIS.Shape,MapWinGIS.Shape)">
            <summary>Returns a new polygon representing the point set difference of poly1 with poly2.</summary>
            <param name="poly1">The 2D polygon in need of clipping.</param>
            <param name="poly2">The 2D polygon used for clipping poly1.</param>
            <returns>Shape containing all points in poly1 that are not in poly2.</returns> 
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.Union(MapWinGIS.Shape,MapWinGIS.Shape)">
            <summary>Returns a new polygon representing the point set combination of polygon1 with polygon2.</summary>
            <param name="poly1">The 2D polygon in need of clipping.</param>
            <param name="poly2">The 2D polygon used for clipping poly1.</param>
            <returns>Shape containing all points in poly1 and poly2.</returns> 
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.Intersection(MapWinGIS.Shape,MapWinGIS.Shape)">
            <summary>Returns a new polygon representing the point set intersection of polygon1 with polygon2.</summary>
            <param name="poly1">The 2D polygon in need of clipping.</param>
            <param name="poly2">The 2D polygon used for clipping poly1.</param>
            <returns>Shape containing all points in poly1 that are also in poly2.</returns> 
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.Intersects(MapWinGIS.Shape,MapWinGIS.Shape)">
            <summary>
            Tests to see if there is an intersection between two polygons
            </summary>
            <param name="poly1">A MapWinGIS.Shape to test</param>
            <param name="poly2">A Second MapWinGIS.Shape to compare the first shape against</param>
            <returns>Boolean, true if the polygons intersect</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.SymmetricDifference(MapWinGIS.Shape,MapWinGIS.Shape)">
            <summary>Returns a new polygon representing the point set exclusive OR of polygon1 with polygon2.</summary>
            <param name="poly1">The 2D polygon in need of clipping.</param>
            <param name="poly2">The 2D polygon used for clipping poly1.</param>
            <returns>Shape containing all points in poly1 and poly2, but not both.</returns> 
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.MergeShapes(MapWinGIS.Shape@,MapWinGIS.Shape@,MapWinGIS.Shape@)">
            <summary>
            Merges two lines (at matching end points) or two polygons (along common border) to make one result shape.
            </summary>
            <param name="shp1">First shape.</param>
            <param name="shp2">Second shape.</param>
            <param name="resultShp">The result of merging shp1 and shp2.</param>
            <returns>True if shapes were merged, false otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.MergeShapes(MapWinGIS.Shapefile@,System.Int32,System.Int32,MapWinGIS.Shape@)">
            <summary>
            Merges two shapes within the same shapefile together.
            If lines, merging occurs at endpoints. If polygons, union is taken.
            </summary>
            <param name="sf">The shapefile containing the shapes to be merged.</param>
            <param name="indexOne">The index to the first shape.</param>
            <param name="indexTwo">The index to the second shape.</param>
            <param name="resultShp">The merged result shape.</param>
            <returns>True if the shapes were mereged, false otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.BufferShape(MapWinGIS.Shape@,System.Double,MapWinGIS.Shape@)">
            <summary>
            Creates a buffer around the input shape at the distance specified.
            </summary>
            <param name="shape">The shape to be buffered.</param>
            <param name="distance">Distance from shape's border that the buffer should be created.</param>
            <param name="resultShp">The resulting buffer shape.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.BufferSF(System.String@,System.String@,System.Double,System.Boolean)">
            <summary>
            Buffers all shapes in the input shapefile.
            </summary>
            <param name="inputSFPath">Full path to the input shapefile.</param>
            <param name="resultSFPath">Full path to the resulting buffer shapefile.</param>
            <param name="distance">Distance from a shape's border at which the corresponding buffer should be created.</param>
            <param name="uniteOverlaps">True if overlapping shapes should be combined.</param>
            <returns>False if an error occured, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.BufferLine(MapWinGIS.Shape@,System.Double,MapWinGeoProc.Enumerations.Buffer_LineSide,MapWinGeoProc.Enumerations.Buffer_CapStyle,MapWinGIS.Shape@)">
            <summary>
            Creates a polygon buffer around the line at the distance specified.
            </summary>
            <param name="line">The line to be buffered.</param>
            <param name="distance">The distance from the line that the buffer should be created.
            Only positive values are allowed.</param>
            <param name="side">The side of the line that should be buffered.</param>
            <param name="capStyle">Edge treatment - pointed or rounded caps.</param>
            <param name="resultShp">The resulting buffer shape.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.BufferLineSF(System.String@,System.String@,System.Double,System.Boolean,MapWinGeoProc.Enumerations.Buffer_LineSide,MapWinGeoProc.Enumerations.Buffer_CapStyle)">
            <summary>
            Creates a buffer around each line in the input shapefile.
            </summary>
            <param name="inputSFPath">Full path to the line shapefile.</param>
            <param name="resultSFPath">Full path to the resulting buffer shapefile. </param>
            <param name="distance">Distance from line at which buffer shape should be created.</param>
            <param name="uniteOverlaps">True if overlapping shapes should be combined.</param>
            <param name="side">Specifies which side of the line should be buffered.</param>
            <param name="capStyle">Edge treatment (Pointed or Rounded caps);</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.BufferPolygon(MapWinGIS.Shape@,System.Double,MapWinGeoProc.Enumerations.Buffer_HoleTreatment,MapWinGeoProc.Enumerations.Buffer_CapStyle,MapWinGIS.Shape@)">
            <summary>
            Creates a buffer around (or inside of) the input polygon at the distance specified.
            </summary>
            <param name="polygon">The polygon shape to be buffered.</param>
            <param name="distance">The distance from the polygon's border that the buffer should be created.
            Positive or Negative values are allowed.</param>
            <param name="holeTreatment">For multiPart polygons with holes, specifies what should be done with holes.
            0 = ignore (no holes will be included in result buffer), 1 = opposite (if distance is positive, hole will shrink),
            2 = same (if distance is positive, hole will grow), 3 = keep original (the hole will not be buffered but will still exist inside of the buffer shape).</param>
            <param name="capStyle">Edge treatment. 0 = pointed, 1 = rounded.</param>
            <param name="resultShp">The resulting buffer shape.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.BufferPolygonSF(System.String@,System.String@,System.Double,System.Boolean,MapWinGeoProc.Enumerations.Buffer_HoleTreatment,MapWinGeoProc.Enumerations.Buffer_CapStyle)">
            <summary>
            Creates a buffer around each polygon in the input shapefile.
            </summary>
            <param name="inputSFPath">Full path to the polygon shapefile.</param>
            <param name="resultSFPath">Full path to the resulting buffer shapefile.</param>
            <param name="distance">Distance from polygon border at which the corresponding buffer should be created.</param>
            <param name="uniteOverlaps">True if overlapping buffers should be combined.</param>
            <param name="holeTreatment">For multiPart polygons with holes, specifies what should be done with holes.
            Ignore (no holes will be included in result buffer), Opposite (if distance is positive, hole will shrink),
            Same (if distance is positive, hole will grow), Original (the hole will not be buffered but will still exist inside of the buffer shape).</param>
            <param name="capStyle">Edge treatment (Pointed or Rounded caps).</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.Erase(System.String@,MapWinGIS.Shape@,System.String@)">
            <summary>
            Removes portions of the input shapefile that fall within the polygon's border.
            </summary>
            <param name="inputSFPath">The full path to the input shapefile.</param>
            <param name="polygon">The overlay polygon.</param>
            <param name="resultSFPath">The full path to the resulting shapefile.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.Erase(System.String@,MapWinGIS.Shape@,System.String@,System.Boolean)">
            <summary>
            Removes portions of the input shapefile that fall within the polygon's border.
            </summary>
            <param name="inputSFPath">The full path to the input shapefile.</param>
            <param name="polygon">The overlay polygon.</param>
            <param name="resultSFPath">The full path to the resulting shapefile.</param>
            <param name="SkipMWShapeID">Indicates whether to skip creating an MWShapeID field in the result.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
            
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.Erase(System.String@,MapWinGIS.Shape@,System.String@,System.Boolean,System.Boolean)">
            <summary>
            Removes portions of the input shapefile that fall within the polygon's border.
            </summary>
            <param name="inputSFPath">The full path to the input shapefile.</param>
            <param name="polygon">The overlay polygon.</param>
            <param name="resultSFPath">The full path to the resulting shapefile.</param>
            <param name="SkipMWShapeID">Indicates whether to skip creating an MWShapeID field in the result.</param>
            <param name="CopyAttributes">Indicates whether to copy attributes or not.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
            
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.Erase(System.String@,System.String@,System.String@)">
            <summary>
            Removes portions of the input shapefile that fall within the erase polygons.
            </summary>
            <param name="inputSFPath">Full path to input shapefile.</param>
            <param name="polySFPath">Full path to the erase polygon shapefile.</param>
            <param name="resultSFPath">Full path to where the result shapefile should be saved.</param>
            <returns>Fals if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.Erase(System.String@,System.String@,System.String@,System.Boolean)">
            <summary>
            Removes portions of the input shapefile that fall within the erase polygons.
            </summary>
            <param name="inputSFPath">Full path to input shapefile.</param>
            <param name="polySFPath">Full path to the erase polygon shapefile.</param>
            <param name="resultSFPath">Full path to where the result shapefile should be saved.</param>
            <param name="SkipMWShapeID">Indicates whether to skip creating an MWShapeID field in the result.</param>
            <returns>Fals if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.Identity(System.String@,System.String@,System.String@)">
            <summary>
            Computes a geometric intersection of the input shapes and the indentity shapes.
            The input shapes, or portions thereof that overlap the identity shapes, will get
            the attributes of those identity shapes.
            </summary>
            <param name="inputSFPath">The full path to the input shapefile.</param>
            <param name="identitySFPath">The full path to the identity shapefile.</param>
            <param name="resultSFPath">The full path to the result shapefile.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.GetShapeNearestToPoint(MapWinGIS.Shapefile@,MapWinGIS.Point@,System.Int32@,System.Double@)">
            <summary>
            Function which will output the index and distance to the nearest shape in the provided shapefile to the provided point. -1 will be returned if nothing is found
            </summary>
            <param name="InputSF"></param>
            <param name="InputPoint"></param>
            <param name="OutIndex"></param>
            <param name="OutDistance"></param>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.GetShapeNearestToPoint(MapWinGIS.Shapefile@,MapWinGIS.Point@,MapWinGIS.Extents@,System.Int32@,System.Double@)">
            <summary>
            Function which will output the index and distance to the nearest shape in the provided shapefile to the provided point, limited by the extents box inputted such that any values outside of it will not be included. -1 will be returned if nothing is found
            </summary>
            <param name="InputSF"></param>
            <param name="InputPoint"></param>
            <param name="LimitBox"></param>
            <param name="OutIndex"></param>
            <param name="OutDistance"></param>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.GetShapeNearestToPoint(MapWinGIS.Shapefile@,MapWinGIS.Point@,System.Double,System.Int32@,System.Double@)">
            <summary>
            Function which will output the index and distance to the nearest shape in the provided shapefile to the provided point, limited by an extents generated by the size inputted such that any values outside of it will not be included. -1 will be returned if nothing is found
            </summary>
            <param name="InputSF"></param>
            <param name="InputPoint"></param>
            <param name="ExtentSize"></param>
            <param name="OutIndex"></param>
            <param name="OutDistance"></param>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.GetShapeNearestToPoint(MapWinGIS.Shapefile@,MapWinGIS.Point@,System.Int32[]@,System.Int32@,System.Double@)">
            <summary>
            Function which will output the index and distance to the nearest shape in the provided shapefile to the provided point, limited by index list inputted such that any values outside of it will not be included. -1 will be returned if nothing is found
            </summary>
            <param name="InputSF"></param>
            <param name="InputPoint"></param>
            <param name="IndexList"></param>
            <param name="OutIndex"></param>
            <param name="OutDistance"></param>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.Distance(System.Double,System.Double,System.Double,System.Double,System.String)">
            <summary>
            Gives the distance between two projected points
            </summary>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="Units"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.LLDistance(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Gives the distance between two lat/long points
            </summary>
            <param name="Lat1"></param>
            <param name="Long1"></param>
            <param name="Lat2"></param>
            <param name="Long2"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.SpatialJoin(System.String,System.String,System.String,MapWinGeoProc.SpatialJoinTypes)">
            <summary>
            A spatial join function which will append the attributes of the Join shapefile to the attributes of the Target shapefile according to a Join type (Only nearest supported so far).
            </summary>
            <param name="TargetSFPath"></param>
            <param name="JoinSFPath"></param>
            <param name="OutputSFPath"></param>
            <param name="JoinType"></param>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.SpatialJoin(System.String,System.String,System.String,MapWinGeoProc.SpatialJoinTypes,System.Double)">
            <summary>
            A spatial join function which will append the attributes of the Join shapefile to the attributes of the Target shapefile according to a Join type (Only nearest supported so far). The nearest operation will be limited by the search radius provided.
            </summary>
            <param name="TargetSFPath"></param>
            <param name="JoinSFPath"></param>
            <param name="OutputSFPath"></param>
            <param name="JoinType"></param>
            <param name="SearchRadius"></param>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.ConvexHull(MapWinGIS.Shape@,MapWinGIS.Shape@)">
            <summary>
            Not Implemented
            Computes the convex hull of a polygon. 
            The convex hull is the smallest convex polygon that contains all the points in the input polgyon. 
            Uses the Graham Scan algorithm. 
            </summary>
            <param name="polygon">The input polygon shape.</param>
            <param name="resultShp">The resulting convex hull of the input polygon.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.SpatialOperations.SelectByAttribute(System.String@,System.Int32,System.Int32,System.Int32,System.String@)">
            <summary>
            Selects all shapes in the input shapefile based on a field value.
            </summary>
            <param name="inputSFPath">The full path to the input shapefile.</param>
            <param name="fieldID">The table ID of the field used for selection.</param>
            <param name="testValLoc">The location of a value used for comparison purposes.</param>
            <param name="compType">The type of comparison to be performed (==, >=, !=, etc)</param>
            <param name="resultSFPath">The full path to the result shapefile.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="T:KDTreeDLL.NearestNeighborList">
            <summary>
            Bjoern Heckel's solution to the KD-Tree n-nearest-neighbor problem
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Hydrology">
            <summary>
            The Hydrology algorithms are especially designed for working with DEMs in the context
            of modeling hydrological processes.  
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.Fill(MapWinGIS.ICallback)">
            <summary>
            An overload of the Fill function which will generate a GeoprocDialog for the Fill function
            </summary>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.Fill">
            <summary>
            An overload of the Fill function which will generate a GeoprocDialog for the Fill function
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.Fill(System.Boolean)">
            <summary>
            This overload does not take a callback, but allows the user to show the progress dialog.
            </summary>
            <param name="ShowProgressDialog">Boolean, true will display the progress dialog.</param>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.Fill(System.String,System.String,MapWinGIS.ICallback)">
            <summary>
            Fills depressions in an image
            - Files specified by parameters
            - Progress and status messages will be sent back via ICallBack
            - Frames will be sized to default values
            </summary>
            <param name="SourceFile">String filename of unfilled DEM</param>
            <param name="DestFile">String filename of output file</param>
            <param name="ICallBack">
            A MapWinGIS ICallback parameter for progress or status messages
            </param>
            <remarks>
            Images too large to process all at once are broken down into a framework.
            A frame represents what will be loaded into memory at any given time.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.Fill(System.String,System.String,System.Boolean)">
            <summary>
            Fills depressions in an image.
            - File names obtained through parameters
            - Progress will be shown through a dialog if ShowProgress is true
            - Frames will be sized to default values
            </summary>
            <param name="SourceFile">String the full path of a source DEM to fill</param>
            <param name="DestFile">String, the full path of the output filled dem</param>
            <param name="ShowProgressDialog">
            Boolean.  Function will display a dialog depicting progress if true.
            </param>
            
            <remarks>
            Images too large to process all at once are broken down into a framework.
            A frame represents what will be loaded into memory at any given time.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.Fill(System.String,System.String,System.Boolean,System.Boolean,System.Int32,System.Int32,MapWinGIS.ICallback)">
            <summary>
            Fills the depressions in the SourceFile and saves the output to DestFile
            </summary>
            <param name="SourceFile">String filename: Input file</param>
            <param name="DestFile">String filename: Output file</param>
            <param name="Overwrite">Boolean, true to overwrite destfile and associated files silently, false to show a messagebox.</param>
            <param name="ShowProgressDialog">Boolean, True to display the progress dialog with status grid</param>
            <param name="FrameWidth">Integer, The width of the smaller grids to use</param>
            <param name="FrameHeight">Integer, The height of the sub-images to use</param>
            <param name="ICallBack">A MapWinGIS.ICallback for status messages</param>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.Fill(MapWinGIS.Grid,MapWinGIS.Grid@,MapWinGIS.ICallback)">
            <summary>
            /// Fills depressions in an image.
            - Grids obtained through parameters
            - Progress and status messages will be sent back via ICallBack
            - Frames will be sized to default values
            </summary>
            <param name="mwSourceGrid">MapWinGIS.Grid object to Fill</param>
            <param name="mwDestGrid">
            MapWinGIS.Grid object Output.
            Specifies output filename and extents.  Everything else will be obtained from original grid.
            </param>
            <param name="ICallBack">A MapWinGIS ICallback to receive errors and status messages</param>
            /// <remarks>
            Images too large to process all at once are broken down into a framework.
            A frame represents what will be loaded into memory at any given time.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.Fill(MapWinGIS.Grid,MapWinGIS.Grid@,System.Boolean)">
            <summary>
            /// Fills depressions in an image.
            - Grids obtained through parameters
            - Progress will be shown through a dialog if ShowProgress is true
            - Frames will be sized to default values
            </summary>
            <param name="mwSourceGrid">MapWinGIS.Grid object to Fill</param>
            <param name="mwDestGrid">
            MapWinGIS.Grid object Output.
            Specifies output filename and extents.  Everything else will be obtained from original grid.
            </param>
            <param name="ShowProgressDialog">
            Boolean.  Function will display a dialog depicting progress if true.
            </param>
            /// <remarks>
            Images too large to process all at once are broken down into a framework.
            A frame represents what will be loaded into memory at any given time.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.File_Fill(System.String,System.String,System.Boolean,System.Boolean,System.Int32,System.Int32,MapWinGIS.ICallback)">
            <summary>
             Internal File handling
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.do_Fill(MapWinGIS.Grid,MapWinGIS.Grid@,System.Boolean,System.Int32,System.Int32,MapWinGIS.ICallback)">
            <summary>
            Performs a Pitfill.  Returns true unless the operation was canceled by the dialog
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.Mask(System.String,System.String,System.String,MapWinGIS.ICallback)">
            <summary>
            A hydrology function to clip by a mask grid
            </summary>
            <param name="DEMPath">Path to the DEM to clip</param>
            <param name="MaskGridPath">Path of the mask grid</param>
            <param name="MaskResultPath">Result grid</param>
            <param name="callback">Icallback for progress</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.Mask(System.String,System.String,System.Collections.ArrayList,System.String,MapWinGIS.ICallback)">
            <summary>
            A hydrology function to clip by shapefile
            </summary>
            <param name="DEMPath">Path to the dem to clip</param>
            <param name="MaskShapePath">path to the shape path</param>
            <param name="SelectedIndexesList">Arraylist of selected integer indexes from shapefile</param>
            <param name="MaskResultPath">Result of the masking</param>
            <param name="callback">Icallback for progress</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.Mask(System.String,MapWinGIS.Extents,System.String,MapWinGIS.ICallback)">
            <summary>
            A hydrology function to clip by extents
            </summary>
            <param name="DEMPath">Path to the grid to mask</param>
            <param name="MaskExtents">Path to the extents to mask by</param>
            <param name="MaskResultPath">Path to the Resulting masked file</param>
            <param name="callback">Icallback for progress</param>
            <returns>0 on success, -1 on fail</returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.CanyonBurnin(System.String,System.String,System.String,MapWinGIS.ICallback)">
            <summary>
            Hydrology burnin function to lower DEM cell values along a given stream polyline
            </summary>
            <param name="StreamNetShapePath">Path to the stream polyline</param>
            <param name="DEMPath">Path to the DEM to burn</param>
            <param name="BurnedDEMResultPath">Resultant burned DEM</param>
            <param name="callback">Icallback for progress</param>
            <returns>0 on success -1 on fail</returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.D8(System.String,System.String,System.String,TKTAUDEMLib.ItkCallback)">
            <summary>
            Not Implemented
            Generates a D8 directional grid by assigning a number from 1 to 8 (0 to 7 in some algorithms) based on a direction to the lowest elevation cell surrounding that cell.
            </summary>
            <param name="PitFillPath">Path of a pit-filled DEM.</param>
            <param name="D8ResultPath">Output result file of a D8 directional grid.</param>
            <param name="D8SlopeResultPath">Path to an output grid containing the slope from the cell to the lowest elevation surrounding cell.</param>
            <param name="tauCallback"> A taudem callback object for internal status messages</param>
            <returns>Integer representing successful creation on 0 or some error state otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.D8(TKTAUDEMLib.ItkCallback)">
            <summary>
            An overload of D8 which will generate a GeoprocDialog and execute the d8 from that.
            </summary>
            <param name="tauCallback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.D8">
            <summary>
            An overload of D8 which will generate a GeoprocDialog and execute the d8 from that.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.AreaD8(System.String,System.String,System.String,System.Boolean,System.Boolean,TKTAUDEMLib.ItkCallback)">
            <summary>
            Not Implemented
            Generates an area D8 grid which shows the paths of highest flow and can be used to delineate stream networks.
            </summary>
            <param name="D8Path">Path to a D8 grid to be converted into an area D8 grid.</param>
            <param name="OutletsPath">Optional path to a point shape file which is used to designate outlet points on a grid. If this path is given, the resulting area D8 grid will only include values for those areas of the grid which flow into the outlet points given. All other portions of the grid will be set to 0.</param>
            <param name="AreaD8ResultPath">Path to an area D8 output grid, </param>
            <param name="UseOutlets">Boolean true for using outlets in delineation d8 areas</param>
            <param name="UseEdgeContamCheck">Boolean true to ignore off-grid contributing area</param>
            <param name="tauCallback"> A taudem callback object for internal status messages</param>
            <returns>Integer representing successful creation on 0 or some error state otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.AreaD8(TKTAUDEMLib.ItkCallback)">
            <summary>
            An overload of the AreaD8 function which will generate a GeoprocDialog for the AreaD8 function
            </summary>
            <param name="tauCallback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.AreaD8">
            <summary>
            An overload of the AreaD8 function which will generate a GeoprocDialog for the AreaD8 function
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.DInf(System.String,System.String,System.String,TKTAUDEMLib.ItkCallback)">
            <summary>
            A function to call the Taudem d-infinity calculations
            </summary>
            <param name="PitFillPath"></param>
            <param name="DInfResultPath"></param>
            <param name="DInfSlopeResultPath"></param>
            <param name="tauCallback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.DInf(TKTAUDEMLib.ItkCallback)">
            <summary>
            An overload of Dinf which will generate a GeoprocDialog and execute the dinf from that.
            </summary>
            <param name="tauCallback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.DInf">
            <summary>
            An overload of Dinf which will generate a GeoprocDialog and execute the dinf from that.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.AreaDInf(System.String,System.String,System.String,System.Boolean,System.Boolean,TKTAUDEMLib.ItkCallback)">
            <summary>
            Function to call the Taudem AreaDinfDecay function
            </summary>
            <param name="DInfPath"></param>
            <param name="OutletsPath"></param>
            <param name="AreaDInfResultPath"></param>
            <param name="UseOutlets"></param>
            <param name="UseEdgeContamCheck"></param>
            <param name="tauCallback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.AreaDInf(TKTAUDEMLib.ItkCallback)">
            <summary>
            An overload of the AreaDInf function which will generate a GeoprocDialog for the AreaDInf function
            </summary>
            <param name="tauCallback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.AreaDInf">
            <summary>
            An overload of the AreaDInf function which will generate a GeoprocDialog for the AreaDInf function
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.DelinStreamGrids(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Boolean,System.Boolean,TKTAUDEMLib.ItkCallback)">
            <summary>
            A function which will make appropriate calls to Taudem in order to form the network grids used in delineation
            </summary>
            <param name="DemGridPath"></param>
            <param name="PitFillPath"></param>
            <param name="D8Path"></param>
            <param name="D8SlopePath"></param>
            <param name="AreaD8Path"></param>
            <param name="OutletsPath"></param>
            <param name="StrahlOrdResultPath"></param>
            <param name="LongestUpslopeResultPath"></param>
            <param name="TotalUpslopeResultPath"></param>
            <param name="StreamGridResultPath"></param>
            <param name="StreamOrdResultPath"></param>
            <param name="TreeDatResultPath"></param>
            <param name="CoordDatResultPath"></param>
            <param name="Threshold"></param>
            <param name="UseOutlets"></param>
            <param name="UseEdgeContamCheck"></param>
            <param name="tauCallback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.DelinStreamGrids(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Boolean,System.Boolean,System.Boolean,TKTAUDEMLib.ItkCallback)">
            <summary>
            An overload of delinStreamGrids which allows the use of Dinf in the delineation
            </summary>
            <param name="DemGridPath"></param>
            <param name="PitFillPath"></param>
            <param name="D8Path"></param>
            <param name="D8SlopePath"></param>
            <param name="AreaD8Path"></param>
            <param name="AreaDInfPath"></param>
            <param name="OutletsPath"></param>
            <param name="StrahlOrdResultPath"></param>
            <param name="LongestUpslopeResultPath"></param>
            <param name="TotalUpslopeResultPath"></param>
            <param name="StreamGridResultPath"></param>
            <param name="StreamOrdResultPath"></param>
            <param name="TreeDatResultPath"></param>
            <param name="CoordDatResultPath"></param>
            <param name="Threshold"></param>
            <param name="UseOutlets"></param>
            <param name="UseEdgeContamCheck"></param>
            <param name="UseDinf"></param>
            <param name="tauCallback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.DelinStreamGrids(TKTAUDEMLib.ItkCallback)">
            <summary>
            An overload of the DelinStreamGrids function which will generate a GeoprocDialog for the DelinStreamGrids function
            </summary>
            <param name="tauCallback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.DelinStreamGrids">
            <summary>
            An overload of the DelinStreamGrids function which will generate a GeoprocDialog for the DelinStreamGrids function
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.DelinStreamsAndSubBasins(System.String,System.String,System.String,System.String,System.String,TKTAUDEMLib.ItkCallback)">
            <summary>
            A function which makes calls to TauDEM to delineate streams shapefile and subbasin grid
            </summary>
            <param name="D8Path"></param>
            <param name="TreeDatPath"></param>
            <param name="CoordDatPath"></param>
            <param name="StreamShapeResultPath"></param>
            <param name="WatershedGridResultPath"></param>
            <param name="tauCallback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.DelinStreamsAndSubBasins(TKTAUDEMLib.ItkCallback)">
            <summary>
            An overload of the DelinStreamsAndSubBasins function which will generate a GeoprocDialog for the DelinStreamsAndSubBasins function
            </summary>
            <param name="tauCallback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.DelinStreamsAndSubBasins">
            <summary>
            An overload of the DelinStreamsAndSubBasins function which will generate a GeoprocDialog for the DelinStreamsAndSubBasins function
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.CreateNetworkOutlets(System.String,System.String,System.String,MapWinGIS.ICallback)">
            <summary>
            A function to generate a network outlets shapefile from the tree.dat and coords.dat files.
            </summary>
            <param name="TreeDatPath">The path to the tree.dat file</param>
            <param name="CoordDatPath">The path to the coords.dat file</param>
            <param name="OutletsShapeResultPath">The output path for the network outlets shapefile</param>
            <param name="callback">A callback for progress messages</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.SubbasinsToShape(System.String,System.String,System.String,MapWinGIS.ICallback)">
            <summary>
            A function which uses the mapwingis utils to convert the subbasin grid to a polygon shapefile
            </summary>
            <param name="D8Path"></param>
            <param name="WatershedGridPath"></param>
            <param name="WatershedShapeResultPath"></param>
            <param name="callback">A MapWinGIS.ICallback used to return error messages etc.</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.SubbasinsToShape(System.String,System.String,System.String,TKTAUDEMLib.ItkCallback,MapWinGIS.ICallback)">
            <summary>
            Subbasin to shape overload for backward compatibility with the tau callback usage. Actually doesn't do anything unfortunately, so useless code
            </summary>
            <param name="D8Path"></param>
            <param name="WatershedGridPath"></param>
            <param name="WatershedShapeResultPath"></param>
            <param name="tauCallback"></param>
            <param name="mwCallback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.SubbasinsToShape(MapWinGIS.ICallback)">
            <summary>
            An overload of the SubbasinsToShape function which will generate a GeoprocDialog for the SubbasinsToShape function
            </summary>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.SubbasinsToShape">
            <summary>
            An overload of the SubbasinsToShape function which will generate a GeoprocDialog for the SubbasinsToShape function
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.ApplyStreamAttributes(System.String,System.String,System.String,MapWinGeoProc.Hydrology.ElevationUnits,MapWinGIS.ICallback)">
            <summary>
            Hydrology function used to add to the stream shapefile attributes 
            </summary>
            <param name="StreamNetworkShapePath"></param>
            <param name="DEMPath"></param>
            <param name="SubBasinShapePath"></param>
            <param name="elevUnits"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.ApplyWatershedLinkAttributes(System.String,System.String,MapWinGIS.ICallback)">
            <summary>
            Hydrology function to apply the watershed link attributes copied or interpretted from the stream network
            </summary>
            <param name="SubBasinShapePath"></param>
            <param name="StreamNetworkShapePath"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.ApplyWatershedAreaAttributes(System.String,MapWinGIS.ICallback)">
            <summary>
            A function to apply area attributes to a watershed polygon shapefile
            </summary>
            <param name="SubBasinShapePath"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.ApplyWatershedSlopeAttribute(System.String,System.String,MapWinGeoProc.Hydrology.ElevationUnits,MapWinGIS.ICallback)">
            <summary>
            Hydrology function used to add to the subbasin shapefile average slope attribute
            </summary>
            <param name="SubBasinShapePath"></param>
            <param name="SlopeGridPath"></param>
            <param name="elevUnits"></param>
            <param name="callback"></param>
            <returns></returns>
            
        </member>
        <member name="M:MapWinGeoProc.Hydrology.ApplyWatershedSlopeAttribute(System.String,System.String,System.String,MapWinGeoProc.Hydrology.ElevationUnits,MapWinGIS.ICallback)">
            <summary>
            Hydrology function used to add to the subbasin shapefile average slope attribute
            </summary>
            <param name="SubBasinGridPath"></param>
            <param name="SubBasinShapePath"></param>
            <param name="SlopeGridPath"></param>
            <param name="elevUnits"></param>
            <param name="callback"></param>
            <returns></returns>
            
        </member>
        <member name="M:MapWinGeoProc.Hydrology.BuildJoinedBasins(System.String,System.String,MapWinGIS.ICallback)">
            <summary>
            A function to create the joined basins from a watershed shapefile that has had the basic apply attributes set on it
            </summary>
            <param name="SubBasinShapePath"></param>
            <param name="JoinBasinShapeResultPath"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.BuildJoinedBasins(System.String,System.String,System.String,MapWinGIS.ICallback)">
            <summary>
            Overload of BuildJoinedBasins that takes an outlets shape path used for Inlets resolution. If no outlets/inlets path given, it will treat all points as outlets
            </summary>
            <param name="SubBasinShapePath"></param>
            <param name="OutletsShapePath"></param>
            <param name="JoinBasinShapeResultPath"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.ApplyJoinBasinAreaAttributes(System.String,MapWinGeoProc.Hydrology.ElevationUnits,MapWinGIS.ICallback)">
            <summary>
            A function to apply attributes to a joined basin shapefile
            </summary>
            <param name="JoinBasinShapePath"></param>
            <param name="elevUnits"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.ApplyJoinBasinStreamAttributes(System.String,System.String,System.String,MapWinGIS.ICallback)">
            <summary>
            A function that gets the mean width, mean height, length, and slope of the primary stream in the basin
            </summary>
            <param name="NetworkShapePath">The path to the streams network shapefile</param>
            <param name="BasinShapePath">The path to the unjoined watershed shapefile</param>
            <param name="JoinBasinShapePath">The path to the Joined Basins shapefile</param>
            <param name="callback">A mapwindow callback</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.ApplyWatershedElevationAttribute(System.String,System.String,MapWinGIS.ICallback)">
            <summary>
            Hydrology function used to add to the subbasin shapefile average elevation attribute
            </summary>
            <param name="SubBasinShapePath"></param>
            <param name="ElevGridPath"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.ApplyWatershedElevationAttribute(System.String,System.String,System.String,MapWinGIS.ICallback)">
            <summary>
            Hydrology function used to add to the subbasin shapefile average elevation attribute
            </summary>
            <param name="SubBasinGridPath"></param>
            <param name="SubBasinShapePath"></param>
            <param name="ElevGridPath"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.CreateSWATFig(System.String,System.String,MapWinGIS.ICallback)">
            <summary>
            A function to generate a *.fig file from joined basins for use in SWAT.
            </summary>
            <param name="JoinBasinShapePath"></param>
            <param name="ResultFigPath"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.Hydrology.LastErrorInfo">
            <summary>
            A string holding the last error generated in this class
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Hydrology.ErrorLog">
            <summary>
            This is a dataformat to hold some strings with error information
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Hydrology.ErrorLog.log">
            <summary>
            A stringbuilder with log of errors
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Hydrology.ErrorLog.LastErrorMessage">
            <summary>
            The last error thrown in Hydrology
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Hydrology.ErrorLog.LastFunctionCalled">
            <summary>
            The last function called
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Hydrology.ErrorLog.LastLocation">
            <summary>
            The last progress message before the error
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Hydrology.ErrorLog.clear">
            <summary>
            Clears the local error information
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Hydrology.ElevationUnits">
            <summary>
            Enum for elevation units used in DEMs
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Hydrology.ElevationUnits.meters">
            <summary>
            Meters = 0
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Hydrology.ElevationUnits.centimeters">
            <summary>
            Centimeters = 1
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Hydrology.ElevationUnits.feet">
            <summary>
            Feet = 2
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Generalization.DPSimplification">
            <summary>
            This class provides methods for generalization of polyline
            shapefiles using the Douglas-Peucker line simplification
            algorithm
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Generalization.DPSimplification.Generalize(System.String,System.String,System.Double,MapWinGIS.ICallback)">
            <summary>
            Generalization of polyline
            shapefiles using the Douglas-Peucker line simplification
            algorithm. This method will output a line shapefile.
            </summary>
            <param name="inFileName">Input shapefile</param>
            <param name="outFileName">Output shapefile</param>
            <param name="tolerance">tolerance parameter - 
            specfies the maximum allowed distance between original polyline
            and simplified polyline</param>
            <param name="cback">Use this parameter for reporting progress. Set to null if not needed</param>
        </member>
        <member name="T:MapWinGeoProc.Topology.Adapter">
            <summary>
            Supports some functions related to polygon adjacency etc.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology.Adapter.GetCategory(MapWinGIS.Shape)">
            <summary>
            reads a MapWinGIS.Shape to find the ShapeCategory
            </summary>
            <param name="Shape">A MapWinGIS.Shape object to learn the category of</param>
            <returns>A ShapeCategories enumeration</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Adapter.ShapeBoundariesTouch(MapWinGIS.Shape,MapWinGIS.Shape)">
            <summary>
            Checks whether the borders of a polygon shape, lines of line shapes, or points of point shapes touch.
            </summary>
            <param name="Shape1">A MapWinGIS.Shape object to test</param>
            <param name="Shape2">A MapWinGIS.Shape object to test</param>
            <returns>True if the boundaries touch</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Adapter.PointsWithinEnvelope(MapWinGIS.Shape,MapWinGIS.Extents)">
            <summary>
            Finds a list of point indecies from a MapWinGIS.Shape that are within the extents specified
            </summary>
            <param name="Shape">Any shapefile with points.</param>
            <param name="Envelope">A MapWinGIS.Extents object representing the area of interrest</param>
            <returns>Returns a list of integer point indecies in Shape that are within Envelope</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Adapter.PointsWithinRect(MapWinGIS.Shape,MapWinGeoProc.Topology.Envelope)">
            <summary>
            Finds a list of point indecies from a MapWinGIS.Shape that are within the rectangle specified
            </summary>
            <param name="Shape">A mapWinGIS.Shape object to select points from</param>
            <param name="Rect">A Envelope structure representing a rectangle to search</param>
            <returns>A List of integer values representing the index values of the points within the rectangle</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Adapter.LineSegmentsWithinEnvelope(MapWinGIS.Shape,MapWinGIS.Extents)">
            <summary>
            Finds the points within extents for polygons and polylines and automatically creates a list
            of appropriate line segments representing all the segments found within the extents.
            </summary>
            <param name="LineOrPolygon">A MapWinGIS.Shape that is a line or polygon shape</param>
            <param name="Envelope">A MapWinGIS.Extents object showing the area of interrest</param>
            <returns>A list of LineSegment structures that have at least one point within or on extents</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Adapter.LineSegmentsWithinRect(MapWinGIS.Shape,MapWinGeoProc.Topology.Envelope)">
            <summary>
            Finds the points within extents for polygons and polylines and automatically creates a list
            of appropriate line segments representing all the segments found within the extents.
            </summary>
            <param name="LineOrPolygon">A MapWinGIS.Shape that is a line or polygon shape</param>
            <param name="Rect">A Envelope defining the region of interrest</param>
            <returns>A list of all segments that have at least one point within or on the extents</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Adapter.EnvelopeIntersect(MapWinGIS.Shapefile,System.Int32,System.Int32)">
            <summary>
            Determines if two shapes in the same shapefile have rectangular extents that touch or intersect.
            </summary>
            <param name="mwShapefile">A MapWinGIS.Shapefile containing both shapes to compare</param>
            <param name="ShapeIndex1">The integer index of the first shape</param>
            <param name="ShapeIndex2">The integer index of the second shape</param>
            <returns>Boolean, true if the extents overlap or touch</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Adapter.EnvelopeIntersect(MapWinGIS.Shape,MapWinGIS.Shape)">
            <summary>
            Determines if two MapWinGIS.Shape objects have rectangular extents that touch or intersect
            </summary>
            <param name="Shape1">A MapWinGIS.Shape to test the rectangular extents of</param>
            <param name="Shape2">A Second MapWinGIS.Shape to test the rectangular extents of</param>
            <returns>Boolean, true if the extents overlap or touch.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Adapter.ShapesWithIntersectingEnvelope(MapWinGIS.Shapefile,System.Int32)">
            <summary>
            Returns a System.Collections.List if integer shape indecies
            </summary>
            <param name="mwShapefile">The MapWinGIS.Shapefile to find shapes from</param>
            <param name="ShapeIndex">The integer shape index in shapefile of the shape to compare with</param>
            <returns>A System.Collections.List of integers that are the shape indecies of shapes overlapping extents</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Adapter.ShapesWithIntersectingEnvelope(MapWinGIS.Shapefile,MapWinGIS.Shape)">
            <summary>
            Returns a System.Collections.List if integer shape indecies
            </summary>
            <param name="mwShapefile">The MapWinGIS.Shapefile to find shapes from</param>
            <param name="Shape">The MapWinGIS.Shape to compare with (not necessarilly in the same shapefile)</param>
            <returns>A System.Collections.List of integers that are the shape indecies of shapes overlapping extents</returns>
            <remarks>Even if Shape is in the shapefile, its index will also be returned</remarks>
        </member>
        <member name="T:MapWinGeoProc.Topology2D.Angle">
            <summary>
            A geometric angle mesured in degrees or radians
            the angle will wrap around, so setting larger values will
            result in an appropriate angle.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.Angle.PI">
            <summary>
            The value of 3.14159 or whatever from Math.PI
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Angle.#ctor(System.Double)">
            <summary>
            Creates a new instance of an angle with the Radians specified
            </summary>
            <param name="Radians">The angle in radians</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Angle.Copy">
            <summary>
            Returns a new instance of the Angle class with the same angle as this object.
            </summary>
            <returns>Angle which has the same values</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Angle.Equals(System.Object)">
            <summary>
            False for anything that is not an angle.
            Tests two angles to see if they have the same value.
            </summary>
            <param name="obj">An object to test.</param>
            <returns>Boolean, true if the angles have the same value.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Angle.GetHashCode">
            <summary>
            Gets a hash code 
            </summary>
            <returns>Int hash code</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Angle.op_Explicit(System.Double)~MapWinGeoProc.Topology2D.Angle">
            <summary>
            Returns a new angle object with an angle of Value in radians
            </summary>
            <param name="Value">The double value indicating the angle</param>
            <returns>An Angle structure with the specified value</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Angle.op_Explicit(MapWinGeoProc.Topology2D.Angle)~System.Double">
            <summary>
            Returns a double specifying the radian value of the angle
            </summary>
            <param name="Value">The angle structure to determine the angle of</param>
            <returns>A Double with the angle in radians</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Angle.op_Equality(MapWinGeoProc.Topology2D.Angle,MapWinGeoProc.Topology2D.Angle)">
            <summary>
            Returns true if the two angles are equal to each other.
            </summary>
            <param name="A">An angle to compare</param>
            <param name="B">A second angle.</param>
            <returns>Boolean, true if they are equal.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Angle.op_Inequality(MapWinGeoProc.Topology2D.Angle,MapWinGeoProc.Topology2D.Angle)">
            <summary>
            Returns true if the two angles are equal to each other.
            </summary>
            <param name="A">An angle to compare</param>
            <param name="B">A second angle.</param>
            <returns>Boolean, true if they are equal.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Angle.op_Addition(MapWinGeoProc.Topology2D.Angle,MapWinGeoProc.Topology2D.Angle)">
            <summary>
            Returns the sum of the two angles, cycling if greater than 2 pi.
            </summary>
            <param name="A">An angle to add</param>
            <param name="B">A second angle to add</param>
            <returns>A new Angle structure equal to the sum of the two angles</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Angle.op_Subtraction(MapWinGeoProc.Topology2D.Angle,MapWinGeoProc.Topology2D.Angle)">
            <summary>
            Returns the difference of two angles.
            </summary>
            <param name="A">An angle to subtract from</param>
            <param name="B">The angle to subtract</param>
            <returns>A new angle structure with a sum equal to the two angles</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Angle.op_Division(MapWinGeoProc.Topology2D.Angle,MapWinGeoProc.Topology2D.Angle)">
            <summary>
            Divides angle A by angle B
            </summary>
            <param name="A">An angle to divide</param>
            <param name="B">An angle to divide into A</param>
            <returns>A new angle with the quotient of the division</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Angle.op_Multiply(MapWinGeoProc.Topology2D.Angle,MapWinGeoProc.Topology2D.Angle)">
            <summary>
            Multiplies angle A by Angle B.
            </summary>
            <param name="A">An angle to multiply</param>
            <param name="B">A second angle to multiply.</param>
            <returns>A new angle with the product of the two angles.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Angle.Cos(MapWinGeoProc.Topology2D.Angle)">
            <summary>
            Returns the mathematical Cos of the angle specified
            </summary>
            <param name="Value">The Angle to find the cosign of</param>
            <returns>Double, the cosign of the angle specified</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Angle.Sin(MapWinGeoProc.Topology2D.Angle)">
            <summary>
            Returns the mathematical Sin of the angle specified
            </summary>
            <param name="Value">The Angle to find the Sin of</param>
            <returns>Double, the Sin of the Angle</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Angle.Tan(MapWinGeoProc.Topology2D.Angle)">
            <summary>
            Returns the mathematical Tan of the angle specified
            </summary>
            <param name="Value">The Angle to find the Tan of</param>
            <returns>Double, the Tan of the Angle</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Angle.ATan(System.Double)">
            <summary>
            Returns the mathematical ATan of the value specified
            </summary>
            <param name="Value">The Double to find the ATan of</param>
            <returns>Angle, the ATan of the Value specified</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Angle.ACos(System.Double)">
            <summary>
            Returns the mathematical ACos of the value specified
            </summary>
            <param name="Value">The Double to find the ACos of</param>
            <returns>Angle, the ACos of the Value specified</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Angle.ASin(System.Double)">
            <summary>
            Returns the mathematical ASin of the value specified
            </summary>
            <param name="Value">The Double to find the ASin of</param>
            <returns>Angle, the ASin of the Value specified</returns>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.Angle.Degrees">
            <summary>
            Gets or sets the angle in degrees, ranging from -360 to 360
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.Angle.Degrees_Pos">
            <summary>
            Gets or sets the angle in degrees ranging from 0 to 360
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.Angle.Radians">
            <summary>
            Only allows values from -2PI to 2PI.
            </summary>
        </member>
        <member name="T:RTools.Util.Token">
            <summary>
            Token class used by StreamTokenizer.
            This represents a single token in the input stream.
            This is subclassed to provide specific token types,
            such as CharToken, FloatToken, etc.
            </summary>
        </member>
        <member name="F:RTools.Util.Token.lineNumber">
            <summary>
            The line number in the input stream where this token originated.
            This is base-1.
            </summary>
        </member>
        <member name="F:RTools.Util.Token.obj">
            <summary>
            A storage object for the data of this token.
            </summary>
        </member>
        <member name="F:RTools.Util.Token.untermError">
            <summary>
            Backer for UntermError.
            </summary>
        </member>
        <member name="F:RTools.Util.Token.untermErrorMsg">
            An error message associated with unterm error.
        </member>
        <member name="M:RTools.Util.Token.#ctor(System.Int32)">
            <summary>
            Construct a Token with the specified line number.
            </summary>
            <param name="line">The line number where this
            token comes from.</param>
        </member>
        <member name="M:RTools.Util.Token.Equals(System.Object)">
            <summary>
            Equals override.
            </summary>
            <param name="other">The object to compare to.</param>
            <returns>bool - true for equals, false otherwise.</returns>
        </member>
        <member name="M:RTools.Util.Token.Equals(System.String)">
            <summary>
            Equals overload.
            </summary>
            <param name="s">The string to compare to.</param>
            <returns>bool</returns>
        </member>
        <member name="M:RTools.Util.Token.Equals(System.Char)">
            <summary>
            Equals overload.
            </summary>
            <param name="c">The char to compare to.</param>
            <returns>bool</returns>
        </member>
        <member name="M:RTools.Util.Token.op_Equality(RTools.Util.Token,System.Object)">
            <summary>
            Operator== overload.  Compare a token and an object.
            </summary>
            <param name="t">The token to compare.</param>
            <param name="o">The other object.</param>
            <returns>bool</returns>
        </member>
        <member name="M:RTools.Util.Token.op_Inequality(RTools.Util.Token,System.Object)">
            <summary>
            Operator!= overload.  Compare a token and an object.
            </summary>
            <param name="t">The token to compare.</param>
            <param name="o">The other object.</param>
            <returns>bool</returns>
        </member>
        <member name="M:RTools.Util.Token.op_Equality(RTools.Util.Token,System.Char)">
            <summary>
            Operator== overload.  Compare a token and a char.
            </summary>
            <param name="t">The token to compare.</param>
            <param name="c">The char.</param>
            <returns>bool</returns>
        </member>
        <member name="M:RTools.Util.Token.op_Inequality(RTools.Util.Token,System.Char)">
            <summary>
            Operator!= overload.  Compare a token and a char.
            </summary>
            <param name="t">The token to compare.</param>
            <param name="c">The char.</param>
            <returns>bool</returns>
        </member>
        <member name="M:RTools.Util.Token.op_Equality(RTools.Util.Token,System.String)">
            <summary>
            Operator== overload.  Compare a token and a string.
            </summary>
            <param name="t">The token to compare.</param>
            <param name="s">The string.</param>
            <returns>bool</returns>
        </member>
        <member name="M:RTools.Util.Token.op_Inequality(RTools.Util.Token,System.String)">
            <summary>
            Operator!= overload.  Compare a token and a string.
            </summary>
            <param name="t">The token to compare.</param>
            <param name="s">The string.</param>
            <returns>bool</returns>
        </member>
        <member name="M:RTools.Util.Token.GetHashCode">
            <summary>
            Override.  Returns the ToString().GetHashCode().
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:RTools.Util.Token.ToLineString">
            <summary>
            Produce a string which includes the line number.
            </summary>
            <returns></returns>
        </member>
        <member name="M:RTools.Util.Token.ToDebugString">
            <summary>
            Produce a string which includes the token type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:RTools.Util.Token.ConvertToType(System.Type)">
            <summary>
            Create an object of the specified type corresponding to
            this token.
            </summary>
            <param name="t">The type of object to create.</param>
            <returns>The new object, or null for error.</returns>
        </member>
        <member name="P:RTools.Util.Token.LineNumber">
            <summary>
            The line number where this token was found.  This is base-1.
            </summary>
        </member>
        <member name="P:RTools.Util.Token.Object">
            <summary>
            The Object stored by this token.  This will be
            a primitive C# type.
            </summary>
        </member>
        <member name="P:RTools.Util.Token.UntermError">
            <summary>
            Whether or not there was an unterminated token problem
            when creating this token.  See UntermErrorMessage for
            a message associated with the problem.
            </summary>
        </member>
        <member name="P:RTools.Util.Token.UntermErrorMsg">
            <summary>
            The error message if there was an unterminated token error
            creating this token.
            </summary>
        </member>
        <member name="P:RTools.Util.Token.StringValue">
            <summary>
            Return this token's value as a string.
            </summary>
            <returns>This token's value as a string.</returns>
        </member>
        <member name="T:RTools.Util.EolToken">
            <summary>
            Represents end-of-lines (line separator characters).
            </summary>
        </member>
        <member name="M:RTools.Util.EolToken.#ctor">
            <summary>Default constructor.</summary>
        </member>
        <member name="M:RTools.Util.EolToken.#ctor(System.Int32)">
            <summary>Constructor that takes line number.</summary>
        </member>
        <member name="M:RTools.Util.EolToken.ToDebugString">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="M:RTools.Util.EolToken.ToString">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="M:RTools.Util.EolToken.Equals(System.Object)">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="M:RTools.Util.EolToken.GetHashCode">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="P:RTools.Util.EolToken.StringValue">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="T:RTools.Util.EofToken">
            <summary>
            Represents end of file/stream.
            </summary>
        </member>
        <member name="M:RTools.Util.EofToken.#ctor">
            <summary>Default constructor.</summary>
        </member>
        <member name="M:RTools.Util.EofToken.#ctor(System.Int32)">
            <summary>Constructor that takes line number.</summary>
        </member>
        <member name="M:RTools.Util.EofToken.ToString">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="M:RTools.Util.EofToken.ToDebugString">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="M:RTools.Util.EofToken.Equals(System.Object)">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="M:RTools.Util.EofToken.GetHashCode">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="P:RTools.Util.EofToken.StringValue">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="T:RTools.Util.StringToken">
            <summary>
            Abstract base class for string tokens.
            </summary>
        </member>
        <member name="M:RTools.Util.StringToken.#ctor(System.String)">
            <summary>Default constructor.</summary>
        </member>
        <member name="M:RTools.Util.StringToken.#ctor(System.String,System.Int32)">
            <summary>Constructor with the specified value
            and line number.</summary>
        </member>
        <member name="M:RTools.Util.StringToken.ToDebugString">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="M:RTools.Util.StringToken.ToString">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="M:RTools.Util.StringToken.GetHashCode">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="P:RTools.Util.StringToken.StringValue">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="T:RTools.Util.WordToken">
            <summary>
            Token type for words, meaning sequences of word
            characters.
            </summary>
        </member>
        <member name="M:RTools.Util.WordToken.#ctor(System.String)">
            <summary>Constructor with the specified value.</summary>
        </member>
        <member name="M:RTools.Util.WordToken.#ctor(System.String,System.Int32)">
            <summary>Constructor with the specified value
            and line number.</summary>
        </member>
        <member name="T:RTools.Util.QuoteToken">
            <summary>
            Token type for Quotes such as "this is a quote".
            </summary>
        </member>
        <member name="M:RTools.Util.QuoteToken.#ctor(System.String)">
            <summary>Constructor with the specified value.</summary>
        </member>
        <member name="M:RTools.Util.QuoteToken.#ctor(System.String,System.Int32)">
            <summary>Constructor with the specified value
            and line number.</summary>
        </member>
        <member name="T:RTools.Util.CommentToken">
            <summary>
            Token type for comments, including line and block
            comments.
            </summary>
        </member>
        <member name="M:RTools.Util.CommentToken.#ctor(System.String)">
            <summary>Constructor with the specified value.</summary>
        </member>
        <member name="M:RTools.Util.CommentToken.#ctor(System.String,System.Int32)">
            <summary>Constructor with the specified value
            and line number.</summary>
        </member>
        <member name="T:RTools.Util.WhitespaceToken">
            <summary>
            Token type for whitespace such as spaces and tabs.
            </summary>
        </member>
        <member name="M:RTools.Util.WhitespaceToken.#ctor(System.String)">
            <summary>Constructor with the specified value.</summary>
        </member>
        <member name="M:RTools.Util.WhitespaceToken.#ctor(System.String,System.Int32)">
            <summary>Constructor with the specified value
            and line number.</summary>
        </member>
        <member name="T:RTools.Util.CharToken">
            <summary>
            Token type for characters, meaning non-word characters.
            </summary>
        </member>
        <member name="M:RTools.Util.CharToken.#ctor(System.String,System.Int32)">
            <summary>Constructor with the specified value
            and line number.</summary>
        </member>
        <member name="M:RTools.Util.CharToken.#ctor(System.Char)">
            <summary>Constructor with the specified value.</summary>
        </member>
        <member name="M:RTools.Util.CharToken.#ctor(System.Char,System.Int32)">
            <summary>Constructor with the specified value.</summary>
        </member>
        <member name="M:RTools.Util.CharToken.ToDebugString">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="M:RTools.Util.CharToken.ToString">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="M:RTools.Util.CharToken.GetHashCode">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="M:RTools.Util.CharToken.Equals(System.Object)">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="P:RTools.Util.CharToken.StringValue">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="T:RTools.Util.FloatToken">
            <summary>
            Token type for floating point numbers, stored internally as a Double.
            </summary>
        </member>
        <member name="M:RTools.Util.FloatToken.#ctor(System.String)">
            <summary>
            Constructor with the specified value.
            </summary>
        </member>
        <member name="M:RTools.Util.FloatToken.#ctor(System.Single)">
            <summary>
            Constructor with the specified value.
            </summary>
        </member>
        <member name="M:RTools.Util.FloatToken.#ctor(System.Double)">
            <summary>
            Constructor with the specified value.
            </summary>
        </member>
        <member name="M:RTools.Util.FloatToken.#ctor(System.String,System.Int32)">
            <summary>
            Constructor with the specified value and line number.
            </summary>
        </member>
        <member name="M:RTools.Util.FloatToken.#ctor(System.Double,System.Int32)">
            <summary>
            Constructor with the specified value and line number.
            </summary>
        </member>
        <member name="M:RTools.Util.FloatToken.ToDebugString">
            <summary>
            Override, see base <see cref="T:RTools.Util.Token"/>
            </summary>
        </member>
        <member name="M:RTools.Util.FloatToken.ToString">
            <summary>
            Override, see base <see cref="T:RTools.Util.Token"/>
            </summary>
        </member>
        <member name="M:RTools.Util.FloatToken.GetHashCode">
            <summary>
            Override, see base <see cref="T:RTools.Util.Token"/>
            </summary>
        </member>
        <member name="M:RTools.Util.FloatToken.Equals(System.Object)">
            <summary>
            Override, see base <see cref="T:RTools.Util.Token"/>
            </summary>
        </member>
        <member name="P:RTools.Util.FloatToken.StringValue">
            <summary>
            Override, see base <see cref="T:RTools.Util.Token"/>
            </summary>
        </member>
        <member name="T:RTools.Util.IntToken">
            <summary>
            Token type for integer tokens. This handles both Int32 and Int64.
            </summary>
        </member>
        <member name="M:RTools.Util.IntToken.#ctor(System.Int32)">
            <summary>Constructor with the specified value.</summary>
        </member>
        <member name="M:RTools.Util.IntToken.#ctor(System.Int64)">
            <summary>Constructor with the specified value.</summary>
        </member>
        <member name="M:RTools.Util.IntToken.#ctor(System.String)">
            <summary>Constructor with the specified value.</summary>
        </member>
        <member name="M:RTools.Util.IntToken.#ctor(System.String,System.Int32)">
            <summary>Constructor with the specified value
            and line number.</summary>
        </member>
        <member name="M:RTools.Util.IntToken.#ctor(System.Int32,System.Int32)">
            <summary>Constructor with the specified value
            and line number.</summary>
        </member>
        <member name="M:RTools.Util.IntToken.#ctor(System.Int64,System.Int32)">
            <summary> 
            Constructor for a 64 bit int 
            </summary> 
        </member>
        <member name="M:RTools.Util.IntToken.ParseHex(System.String,System.Int32)">
            <summary>
            Parse a string known to be a hex string.  This is faster
            than Parse which doesn't assume the number is Hex.  This will
            throw an exception if the input number isn't hex.
            </summary>
            <param name="s">The hex number as a string.</param>
            <param name="lineNumber">The line where this token was found.</param>
            <returns>A new IntToken set to the value in the input string.</returns>
        </member>
        <member name="M:RTools.Util.IntToken.Parse(System.String)">
            <summary>
            Convert the input string to an integer, if possible
            </summary>
            <param name="s">The string to parse.</param>
        </member>
        <member name="M:RTools.Util.IntToken.ToDebugString">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="M:RTools.Util.IntToken.ToString">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="M:RTools.Util.IntToken.GetHashCode">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="M:RTools.Util.IntToken.Equals(System.Object)">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="P:RTools.Util.IntToken.StringValue">
            <summary>Override, see base <see cref="T:RTools.Util.Token"/></summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Precision.CommonBitsOp">
            <summary> 
            Provides versions of Geometry spatial functions which use
            common bit removal to reduce the likelihood of robustness problems.
            In the current implementation no rounding is performed on the
            reshifted result point, which means that it is possible
            that the returned Geometry is invalid.
            Client classes should check the validity of the returned result themselves.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBitsOp.#ctor">
            <summary>
            Creates a new instance of class, which reshifts result <c>Geometry</c>s.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBitsOp.#ctor(System.Boolean)">
            <summary>
            Creates a new instance of class, specifying whether
            the result <c>Geometry</c>s should be reshifted.
            </summary>
            <param name="returnToOriginalPrecision"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBitsOp.Intersection(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Computes the set-theoretic intersection of two <c>Geometry</c>s, using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry.</param>
            <returns>The Geometry representing the set-theoretic intersection of the input Geometries.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBitsOp.Union(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Computes the set-theoretic union of two <c>Geometry</c>s, using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry.</param>
            <returns>The Geometry representing the set-theoretic union of the input Geometries.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBitsOp.Difference(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Computes the set-theoretic difference of two <c>Geometry</c>s, using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry, to be subtracted from the first.</param>
            <returns>The Geometry representing the set-theoretic difference of the input Geometries.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBitsOp.SymDifference(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary
            > Computes the set-theoretic symmetric difference of two geometries,
            using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry.</param>
            <returns>The Geometry representing the set-theoretic symmetric difference of the input Geometries.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBitsOp.Buffer(MapWindow.Interfaces.Geometries.IGeometry,System.Double)">
            <summary>
            Computes the buffer a point, using enhanced precision.
            </summary>
            <param name="geom0">The Geometry to buffer.</param>
            <param name="distance">The buffer distance.</param>
            <returns>The Geometry representing the buffer of the input Geometry.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBitsOp.ComputeResultPrecision(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            If required, returning the result to the orginal precision if required.
            In this current implementation, no rounding is performed on the
            reshifted result point, which means that it is possible
            that the returned Geometry is invalid.
            </summary>
            <param name="result">The result Geometry to modify.</param>
            <returns>The result Geometry with the required precision.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBitsOp.RemoveCommonBits(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Computes a copy of the input <c>Geometry</c> with the calculated common bits
            removed from each coordinate.
            </summary>
            <param name="geom0">The Geometry to remove common bits from.</param>
            <returns>A copy of the input Geometry with common bits removed.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBitsOp.RemoveCommonBits(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Computes a copy of each input <c>Geometry</c>s with the calculated common bits
            removed from each coordinate.
            </summary>
            <param name="geom0">A Geometry to remove common bits from.</param>
            <param name="geom1">A Geometry to remove common bits from.</param>
            <returns>
            An array containing copies
            of the input Geometry's with common bits removed.
            </returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Valid.ConsistentAreaTester">
            <summary> 
            Checks that a {GeometryGraph} representing an area
            (a <c>Polygon</c> or <c>MultiPolygon</c> )
            is consistent with the SFS semantics for area geometries.
            Checks include:
            Testing for rings which self-intersect (both properly and at nodes).
            Testing for duplicate rings.
            If an inconsistency if found the location of the problem is recorded.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.ConsistentAreaTester.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            
            </summary>
            <param name="geomGraph"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Valid.ConsistentAreaTester.InvalidPoint">
            <summary>
            Returns the intersection point, or <c>null</c> if none was found.
            </summary>        
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Valid.ConsistentAreaTester.IsNodeConsistentArea">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Valid.ConsistentAreaTester.IsNodeEdgeAreaLabelsConsistent">
            <summary>
            Check all nodes to see if their labels are consistent.
            If any are not, return false.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Valid.ConsistentAreaTester.HasDuplicateRings">
            <summary>
            Checks for two duplicate rings in an area.
            Duplicate rings are rings that are topologically equal
            (that is, which have the same sequence of points up to point order).
            If the area is topologically consistent (determined by calling the
            <c>isNodeConsistentArea</c>,
            duplicate rings can be found by checking for EdgeBundles which contain more than one EdgeEnd.
            (This is because topologically consistent areas cannot have two rings sharing
            the same line segment, unless the rings are equal).
            The start point of one of the equal rings will be placed in invalidPoint.
            Returns <c>true</c> if this area Geometry is topologically consistent but has two duplicate rings.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeGraph">
            <summary>
            Represents a planar graph of edges that can be used to compute a
            polygonization, and implements the algorithms to compute the
            EdgeRings formed by the graph.
            The marked flag on DirectedEdges is used to indicate that a directed edge
            has be logically deleted from the graph.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeGraph.GetDegreeNonDeleted(MapWinGeoProc.NTS.Topology.Planargraph.Node)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeGraph.GetDegree(MapWinGeoProc.NTS.Topology.Planargraph.Node,System.Int64)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="label"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeGraph.DeleteAllEdges(MapWinGeoProc.NTS.Topology.Planargraph.Node)">
            <summary>
            Deletes all edges at a node.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeGraph.#ctor(MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            Create a new polygonization graph.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeGraph.AddEdge(MapWinGeoProc.NTS.Topology.Geometries.LineString)">
            <summary>
            Add a <c>LineString</c> forming an edge of the polygon graph.
            </summary>
            <param name="line">The line to add.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeGraph.GetNode(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeGraph.ComputeNextCWEdges">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeGraph.ConvertMaximalToMinimalEdgeRings(System.Collections.IList)">
            <summary>
            Convert the maximal edge rings found by the initial graph traversal
            into the minimal edge rings required by NTS polygon topology rules.
            </summary>
            <param name="ringEdges">The list of start edges for the edgeRings to convert.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeGraph.FindIntersectionNodes(MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeDirectedEdge,System.Int64)">
            <summary>
            Finds all nodes in a maximal edgering which are self-intersection nodes
            </summary>
            <param name="startDE"></param>
            <param name="label"></param>
            <returns> 
            The list of intersection nodes found,
            or null if no intersection nodes were found.       
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeGraph.GetEdgeRings">
            <summary>
            Computes the EdgeRings formed by the edges in this graph.        
            </summary>
            <returns>A list of the{EdgeRings found by the polygonization process.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeGraph.FindLabeledEdgeRings(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="dirEdges">A List of the DirectedEdges in the graph.</param>
            <returns>A List of DirectedEdges, one for each edge ring found.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeGraph.DeleteCutEdges">
            <summary>
            Finds and removes all cut edges from the graph.
            </summary>
            <returns>A list of the <c>LineString</c>s forming the removed cut edges.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeGraph.Label(System.Collections.IList,System.Int64)">
            <summary>
            
            </summary>
            <param name="dirEdges"></param>
            <param name="label"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeGraph.ComputeNextCWEdges(MapWinGeoProc.NTS.Topology.Planargraph.Node)">
            <summary>
            
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeGraph.ComputeNextCCWEdges(MapWinGeoProc.NTS.Topology.Planargraph.Node,System.Int64)">
            <summary>
            Computes the next edge pointers going CCW around the given node, for the
            given edgering label.
            This algorithm has the effect of converting maximal edgerings into minimal edgerings
            </summary>
            <param name="node"></param>
            <param name="label"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeGraph.FindDirEdgesInRing(MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeDirectedEdge)">
            <summary>
            Traverse a ring of DirectedEdges, accumulating them into a list.
            This assumes that all dangling directed edges have been removed
            from the graph, so that there is always a next dirEdge.
            </summary>
            <param name="startDE">The DirectedEdge to start traversing at.</param>
            <returns>A List of DirectedEdges that form a ring.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeGraph.FindEdgeRing(MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeDirectedEdge)">
            <summary>
            
            </summary>
            <param name="startDE"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeGraph.DeleteDangles">
            <summary>
            Marks all edges from the graph which are "dangles".
            Dangles are which are incident on a node with degree 1.
            This process is recursive, since removing a dangling edge
            may result in another edge becoming a dangle.
            In order to handle large recursion depths efficiently,
            an explicit recursion stack is used.
            </summary>
            <returns>A List containing the LineStrings that formed dangles.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation">
            <summary>
            Represents a location along a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.LineString"/> or <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.MultiLineString"/>.
            The referenced geometry is not maintained within this location, 
            but must be provided for operations which require it.
            Various methods are provided to manipulate the location value
            and query the geometry it references.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation.GetEndLocation(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Gets a location which refers to the end of a linear <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>.
            </summary>
            <param name="linear">The linear geometry.</param>
            <returns>A new <c>LinearLocation</c>.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation.PointAlongSegmentByFraction(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,System.Double)">
            <summary>
            Computes the <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> of a point a given fraction
            along the line segment <c>(p0, p1)</c>.
            If the fraction is greater than 1.0 the last
            point of the segment is returned.
            If the fraction is less than or equal to 0.0 the first point
            of the segment is returned.
            </summary>
            <param name="p0">The first point of the line segment.</param>
            <param name="p1">The last point of the line segment.</param>
            <param name="fraction">The length to the desired point.</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:LinearLocation"/> class:
            creates a location referring to the start of a linear geometry.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation.#ctor(System.Int32,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:LinearLocation"/> class:
            creates a location referring to the start of a linear geometry.
            </summary>
            <param name="segmentIndex">Index of the segment.</param>
            <param name="segmentFraction">The segment fraction.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:LinearLocation"/> class:
            creates a location referring to the start of a linear geometry.
            </summary>
            <param name="componentIndex">Index of the component.</param>
            <param name="segmentIndex">Index of the segment.</param>
            <param name="segmentFraction">The segment fraction.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation.Normalize">
            <summary>
            Ensures the individual values are locally valid.
            Does not ensure that the indexes are valid for
            a particular linear geometry.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation.Clamp(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Ensures the indexes are valid for a given linear <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>.
            </summary>
            <param name="linear">A linear geometry.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation.SnapToVertex(MapWindow.Interfaces.Geometries.IGeometry,System.Double)">
            <summary>
            Snaps the value of this location to
            the nearest vertex on the given linear <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>,
            if the vertex is closer than <paramref name="minDistance"/>.
            </summary>
            <param name="linearGeom">A linear geometry.</param>
            <param name="minDistance">The minimum allowable distance to a vertex.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation.GetSegmentLength(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Gets the length of the segment in the given
            Geometry containing this location.
            </summary>
            <param name="linearGeom">A linear geometry.</param>
            <returns>The length of the segment.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation.SetToEnd(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Sets the value of this location to
            refer the end of a linear geometry.
            </summary>
            <param name="linear">The linear geometry to set.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation.GetCoordinate(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Gets the <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> along the
            given linear <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/> which is
            referenced by this location.
            </summary>
            <param name="linearGeom">A linear geometry.</param>
            <returns>The <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> at the location.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation.IsValid(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Tests whether this location refers to a valid
            location on the given linear <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>.
            </summary>
            <param name="linearGeom">A linear geometry.</param>
            <returns><c>true</c> if this location is valid.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation.CompareTo(System.Object)">
            <summary>
            Compares the current instance with another object of the same type.
            </summary>
            <param name="obj">
            The <c>LineStringLocation</c> with which this 
            <c>Coordinate</c> is being compared.
            </param>
            <returns>
            A negative integer, zero, or a positive integer as this 
            <c>LineStringLocation</c> is less than, equal to, 
            or greater than the specified <c>LineStringLocation</c>.
            </returns>
            <exception cref="T:System.ArgumentException">
            <paramref name="obj" /> is not the same type as this instance. 
            </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation.CompareTo(MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation)">
            <summary>
            Compares the current instance with another object of the same type.
            </summary>
            <param name="other">
            The <c>LineStringLocation</c> with which this 
            <c>Coordinate</c> is being compared.
            </param>
            <returns>
            A negative integer, zero, or a positive integer as this 
            <c>LineStringLocation</c> is less than, equal to, 
            or greater than the specified <c>LineStringLocation</c>.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation.CompareLocationValues(System.Int32,System.Int32,System.Double)">
            <summary>
            Compares this object with the specified index values for order.
            </summary>
            <param name="componentIndex1">The component index.</param>
            <param name="segmentIndex1">The segment index.</param>
            <param name="segmentFraction1">The segment fraction.</param>
            <returns>
            A negative integer, zero, or a positive integer as this <c>LineStringLocation</c>
            is less than, equal to, or greater than the specified locationValues.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation.CompareLocationValues(System.Int32,System.Int32,System.Double,System.Int32,System.Int32,System.Double)">
            <summary>
            Compares two sets of location values for order.
            </summary>
            <param name="componentIndex0">The first component index.</param>
            <param name="segmentIndex0">The first segment index.</param>
            <param name="segmentFraction0">The first segment fraction.</param>
            <param name="componentIndex1">The second component index.</param>
            <param name="segmentIndex1">The second segment index.</param>
            <param name="segmentFraction1">The second segment fraction.</param>
            <returns>
            A negative integer, zero, or a positive integer
            as the first set of location values is less than, equal to, 
            or greater than the second set of locationValues.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation.Clone">
            <summary>
            Copies this location.
            </summary>
            <returns>A copy of this location.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation.ComponentIndex">
            <summary>
            Gets the component index for this location.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation.SegmentIndex">
            <summary>
            Gets the segment index for this location.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation.SegmentFraction">
            <summary>
            Gets the segment fraction for this location.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation.IsVertex">
            <summary>
            Tests whether this location refers to a vertex:
            returns <c>true</c> if the location is a vertex.
            </summary>        
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthLocationMap">
            <summary>
            Computes the <see cref="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation"/> for a given length
            along a linear <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>
            Negative lengths are measured in reverse from end of the linear geometry.
            Out-of-range values are clamped.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthLocationMap.GetLocation(MapWinGeoProc.NTS.Topology.Geometries.Geometry,System.Double)">
            <summary>
            Computes the <see cref="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation"/> for a
            given length along a linear <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>.
            </summary>
            <param name="linearGeom">The linear geometry to use.</param>
            <param name="length">The length index of the location.</param>
            <returns>The <see cref="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation"/> for the length.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthLocationMap.GetLength(MapWinGeoProc.NTS.Topology.Geometries.Geometry,MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation)">
            <summary>
            Computes the length for a given <see cref="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation"/>
            on a linear <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>.
            </summary>
            <param name="linearGeom">The linear geometry to use.</param>
            <param name="loc">The <see cref="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation"/> index of the location.</param>
            <returns>The length for the <see cref="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation"/>.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthLocationMap.#ctor(MapWinGeoProc.NTS.Topology.Geometries.Geometry)">
            <summary>
            Initializes a new instance of the <see cref="T:LengthLocationMap"/> class.
            </summary>
            <param name="linearGeom">A linear geometry.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthLocationMap.GetLocation(System.Double)">
            <summary>
            Compute the <see cref="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation"/> corresponding to a length.
            Negative lengths are measured in reverse from end of the linear geometry.
            Out-of-range values are clamped.
            </summary>
            <param name="length">The length index.</param>
            <returns>The corresponding <see cref="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation"/>.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthLocationMap.GetLocationForward(System.Double)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthLocationMap.GetLength(MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation)">
            <summary>
            
            </summary>
            <param name="loc"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.ShapefileReader">
            <summary>
            This class represnts an ESRI Shapefile.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileReader.#ctor(System.String,MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory)">
            <summary>
            Initializes a new instance of the Shapefile class with the given parameters.
            </summary>
            <param name="filename">The filename of the shape file to read (with .shp).</param>
            <param name="geometryFactory">The GeometryFactory to use when creating Geometry objects.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileReader.#ctor(System.String)">
            <summary>
            Initializes a new instance of the Shapefile class with the given parameter 
            and a standard GeometryFactory.
            </summary>
            <param name="filename">The filename of the shape file to read (with .shp).</param>        
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileReader.ReadAll">
            <summary>
            Reads the shapefile and returns a GeometryCollection representing all the records in the shapefile.
            </summary>
            <returns>GeometryCollection representing every record in the shapefile.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileReader.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ShapefileReader.Header">
            <summary>
            Gets the bounds of the shape file.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.ShapefileReader.ShapefileEnumerator">
            <summary>
            Summary description for ShapefileEnumerator.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileReader.ShapefileEnumerator.#ctor(MapWinGeoProc.NTS.Topology.IO.ShapefileReader)">
            <summary>
            Initializes a new instance of the ShapefileEnumerator class.
            </summary>
            <param name="shapefile"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileReader.ShapefileEnumerator.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileReader.ShapefileEnumerator.MoveNext">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ShapefileReader.ShapefileEnumerator.Current">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractNode">
            <summary> 
            A node of the STR tree. The children of this node are either more nodes
            (AbstractNodes) or real data (ItemBoundables). If this node contains real data
            (rather than nodes), then we say that this node is a "leaf node".
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractNode.#ctor(System.Int32)">
            <summary> 
            Constructs an AbstractNode at the given level in the tree
            </summary>
            <param name="level">
            0 if this node is a leaf, 1 if a parent of a leaf, and so on; the
            root node will have the highest level.
            </param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractNode.ComputeBounds">
            <summary>
            Returns a representation of space that encloses this Boundable,
            preferably not much bigger than this Boundable's boundary yet fast to
            test for intersection with the bounds of other Boundables. The class of
            object returned depends on the subclass of AbstractSTRtree.
            </summary>
            <returns> 
            An Envelope (for STRtrees), an Interval (for SIRtrees), or other
            object (for other subclasses of AbstractSTRtree).
            </returns>        
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractNode.AddChildBoundable(MapWinGeoProc.NTS.Topology.Index.Strtree.IBoundable)">
            <summary>
            Adds either an AbstractNode, or if this is a leaf node, a data object
            (wrapped in an ItemBoundable).
            </summary>
            <param name="childBoundable"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractNode.ChildBoundables">
            <summary> 
            Returns either child AbstractNodes, or if this is a leaf node, real data (wrapped
            in ItemBoundables).
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractNode.Bounds">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Strtree.AbstractNode.Level">
            <summary>
            Returns 0 if this node is a leaf, 1 if a parent of a leaf, and so on; the
            root node will have the highest level.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.TopologyException">
            <summary> 
            Indicates an invalid or inconsistent topological situation encountered during processing
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.TopologyException.MsgWithCoord(System.String,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="msg"></param>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.TopologyException.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.TopologyException.#ctor(System.String,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="msg"></param>
            <param name="pt"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.TopologyException.Coordinate">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.NodeMap">
            <summary> 
            A map of nodes, indexed by the coordinate of the node.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.NodeMap.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.NodeFactory)">
            <summary>
            
            </summary>
            <param name="nodeFact"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.NodeMap.AddNode(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary> 
            This method expects that a node has a coordinate value.
            </summary>
            <param name="coord"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.NodeMap.AddNode(MapWinGeoProc.NTS.Topology.GeometriesGraph.Node)">
            <summary>
            
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.NodeMap.Add(MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd)">
            <summary> 
            Adds a node for the start point of this EdgeEnd
            (if one does not already exist in this map).
            Adds the EdgeEnd to the (possibly new) node.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.NodeMap.Find(MapWindow.Interfaces.Geometries.ICoordinate)">
            <returns> 
            The node if found; null otherwise.
            </returns>
            <param name="coord"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.NodeMap.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.NodeMap.GetBoundaryNodes(System.Int32)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.NodeMap.Write(System.IO.StreamWriter)">
            <summary>
            
            </summary>
            <param name="outstream"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.NodeMap.Values">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Features.AttributesTable">
            <summary>
            Stores all attributes associated with a single <c>Geometry</c> feature.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Features.AttributesTable.#ctor">
            <summary>
            Initialize a new attribute table.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Features.AttributesTable.GetNames">
            <summary>
            Returns a <c>string</c> array containing 
            all names of present attributes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Features.AttributesTable.GetValues">
            <summary>
            Returns a <c>object</c> array containing 
            all values of present attributes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Features.AttributesTable.Exists(System.String)">
            <summary>
            Verifies if attribute specified already exists.
            </summary>
            <param name="attributeName"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Features.AttributesTable.AddAttribute(System.String,System.Object)">
            <summary>
            Build a field with the given value and add it to attributes table.        
            </summary>
            <param name="attributeName">Name of the new attribute.</param>        
            <param name="attributeValue">Value for attribute (can be null).</param>
            <exception cref="T:System.ArgumentException">If attribute already exists.</exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Features.AttributesTable.DeleteAttribute(System.String)">
            <summary>
            Delete the specified attribute from the table.
            </summary>
            <param name="attributeName"></param>       
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Features.AttributesTable.GetType(System.String)">
            <summary>
            Return the <c>System.Type</c> of the specified attribute, 
            useful for casting values retrieved with GetValue methods.
            </summary>
            <param name="attributeName"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Features.AttributesTable.GetValue(System.String)">
            <summary>
            Get the value of the specified attribute.
            </summary>
            <param name="attributeName"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Features.AttributesTable.SetValue(System.String,System.Object)">
            <summary>
            Set the value of the specified attribute.
            </summary>
            <param name="attributeName"></param>
            <param name="attributeValue"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Features.AttributesTable.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Features.AttributesTable.Item(System.String)">
            <summary>
            Get / Set the value of the specified attribute.
            </summary>
            <param name="attributeName"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.TransverseMercator">
            <summary>
            Summary description for MathTransform.
            </summary>
            <remarks>
            <para>Universal (UTM) and Modified (MTM) Transverses Mercator projections. This
            is a cylindrical projection, in which the cylinder has been rotated 90°.
            Instead of being tangent to the equator (or to an other standard latitude),
            it is tangent to a central meridian. Deformation are more important as we
            are going futher from the central meridian. The Transverse Mercator
            projection is appropriate for region wich have a greater extent north-south
            than east-west.</para>
            
            <para>Reference: John P. Snyder (Map Projections - A Working Manual,
                       U.S. Geological Survey Professional Paper 1395, 1987)</para>
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.TransverseMercator.#ctor(System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectionParameter})">
            <summary>
            Creates an instance of an TransverseMercatorProjection projection object.
            </summary>
            <param name="parameters">List of parameters to initialize the projection.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.TransverseMercator.#ctor(System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectionParameter},System.Boolean)">
            <summary>
            Creates an instance of an TransverseMercatorProjection projection object.
            </summary>
            <param name="parameters">List of parameters to initialize the projection.</param>
            <param name="inverse">Flag indicating wether is a forward/projection (false) or an inverse projection (true).</param>
            <remarks>
            <list type="bullet">
            <listheader><term>Items</term><description>Descriptions</description></listheader>
            <item><term>semi_major</term><description>Semi major radius</description></item>
            <item><term>semi_minor</term><description>Semi minor radius</description></item>
            <item><term>scale_factor</term><description></description></item>
            <item><term>central meridian</term><description></description></item>
            <item><term>latitude_origin</term><description></description></item>
            <item><term>false_easting</term><description></description></item>
            <item><term>false_northing</term><description></description></item>
            </list>
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.TransverseMercator.DegreesToMeters(MapWinGeoProc.NTS.Topology.Geometries.Point)">
            <summary>
            Converts coordinates in decimal degrees to projected meters.
            </summary>
            <param name="lonlat">The point in decimal degrees.</param>
            <returns>Point in projected meters</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.TransverseMercator.MetersToDegrees(MapWinGeoProc.NTS.Topology.Geometries.Point)">
            <summary>
            Converts coordinates in projected meters to decimal degrees.
            </summary>
            <param name="p">Point in meters</param>
            <returns>Transformed point in decimal degrees</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projections.TransverseMercator.Inverse">
            <summary>
            Returns the inverse of this projection.
            </summary>
            <returns>IMathTransform that is the reverse of the current projection.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IParameterInfo">
            <summary>
            The IParameterInfo interface provides an interface through which clients of a
            Projected Coordinate System or of a Projection can set the parameters of the
            projection. It provides a generic interface for discovering the names and default
            values of parameters, and for setting and getting parameter values. Subclasses of
            this interface may provide projection specific parameter access methods.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.IParameterInfo.DefaultParameters">
            <summary>
            Returns the default parameters for this projection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.IParameterInfo.GetParameterByName(System.String)">
            <summary>
            Gets the parameter by its name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IParameterInfo.NumParameters">
            <summary>
            Gets the number of parameters expected.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IParameterInfo.Parameters">
            <summary>
            Gets or sets the parameters set for this projection.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IFittedCoordinateSystem">
            <summary>
            A coordinate system which sits inside another coordinate system. The fitted 
            coordinate system can be rotated and shifted, or use any other math transform
            to inject itself into the base coordinate system.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.IFittedCoordinateSystem.ToBase">
            <summary>
            Gets Well-Known Text of a math transform to the base coordinate system. 
            The dimension of this fitted coordinate system is determined by the source 
            dimension of the math transform. The transform should be one-to-one within 
            this coordinate system's domain, and the base coordinate system dimension 
            must be at least as big as the dimension of this coordinate system.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IFittedCoordinateSystem.BaseCoordinateSystem">
            <summary>
            Gets underlying coordinate system.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.FrameworkStatus">
            <summary>
            This is a user control to show the status of differnet grid portions of a grid being analyzed.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.FrameworkStatus.myFramework">
            <summary>
            A convenient link to the specific framework where an image is being analyzed
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.FrameworkStatus.#ctor">
            <summary>
            This initializes this user control.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.FrameworkStatus.Redraw">
            <summary>
            After the control has been updated, call this function to allow it to recreate the status colors.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.FrameworkStatus.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.FrameworkStatus.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.FrameworkStatus.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Compatibility.Raster">
            <summary>
            Wrap any calls to this in a try block to catch exceptions.
            Errors occuring in Methods without a boolean return type
            will throw exceptions if there is an error.
            </summary>
            <remarks>
            When MapWinExceptions are generated, they automatically register
            the contents of the error message with the logger.  Knowing that
            Raster object was involved may be useful, so that part is logged
            here.  The exception should be wrapped in a try-block so that
            the exception can be logged from the calling function.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.#ctor">
            <summary>
            Creates a new instance of the Raster wrapper for the grid
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.#ctor(MapWinGIS.Grid)">
            <summary>
            Creates a Raster from a specific instance of an m_Grid
            </summary>
            <param name="MapWinGIS_Grid">MapWinGIS.Grid to create a Raster from</param>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.CellToProj(System.Int32,System.Int32,System.Double@,System.Double@)">
            <summary>
            Given a Row and Column, it figures out the georeferenced X, Y location
            corresponding to the center of that grid cell.
            </summary>
            <param name="Column">Integer, Column of the grid cell to get the coordinates of</param>
            <param name="Row">Integer, Row of the grid cell to get the coordinates of</param>
            <param name="x">The double value of the horizontal coordinate</param>
            <param name="y">The double value of the vertical coordinate</param>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.CellToProjX(System.Int32)">
            <summary>
            Finds the X-coordinate or Longitude corresponding to the specified Column.
            This uses XllCenter + dX * Column.
            </summary>
            <param name="Column">The Integer column to find the X-coordinate of</param>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.CellToProjY(System.Int32)">
            <summary>
            Finds the Y-coordiante or Longitude corresponding to the specified Row.
            This uses YllCenter + dY * (NumRows - Row);
            </summary>
            <param name="Row">The integer column to find the Y-coordinate of</param>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.Clear(System.Double)">
            <summary>
            This calls the MapWinGIS.Clear(value) method.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.Close">
            <summary>
            Wraps MapWinGIS.Close()
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.CreateNew(System.String,MapWindow.Interfaces.Raster.GridFileType,System.Double,System.Double,System.Double,System.Double,System.Double,System.String,System.Int32,System.Int32,MapWindow.Interfaces.Raster.GridDataType,System.Boolean,System.Double,System.Boolean)">
            <summary>
            Creates a new instance of a MapWinGIS Grid according to the parameters required by IRaster
            </summary>
            <param name="Filename">The string full path filename of the grid</param>
            <param name="newFileType">A MapWindow.Interfaces.Type.GridFileType specifying a file format</param>
            <param name="dX">Double, specifies the cell width of a single "pixel" for the grid</param>
            <param name="dY">Double, specifies the cell height of a single pixel of the grid</param>
            <param name="xllCenter">Double, The longitude/X-coordinate of the lower left pixel in the grid</param>
            <param name="yllCenter">Double, The latitude/Y-coordinate of the lower left pixel of the grid</param>
            <param name="noDataVal">Double, The value to use as a no-data value in the grid</param>
            <param name="projection">String: the proj-4 string to use to describe the grid projection</param>
            <param name="nCols">Int, the number of columns in the grid</param>
            <param name="nrows">Int, the number of rows in the grid</param>
            <param name="DataType">A MapWindow.Interfaces.Type.GridDataType that specifies the numeric data format</param>
            <param name="CreateINRam">Boolean, if true, the entire element will be created in ram</param>
            <param name="initialValue">The intial value for the grid</param>
            <param name="applyinitialValue">I'm not sure this is an option in the old grid</param>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.Dispose">
            <summary>
            Releases com objects
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.Equals">
            <summary>
            I don't really know that we want to code this here
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.GetFloatWindow(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a value like float Values[Y][X] where the block describes the window being specified
            </summary>
            <param name="StartRow">The 0 based row index corresponding to the Top (0,0 is Top, Left)</param>
            <param name="EndRow">The 0 based row index corresponding to the Bottom (0,0 is Top, Left)</param>
            <param name="StartCol">The 0 based column index corresponding to the Left (0,0 is Top, Left)</param>
            <param name="EndCol">The 0 based column index corresponding to the Right (0,0 is Top, Left)</param>
            <exception cref="T:System.ApplicationException">Returns an exception if there is a failure</exception>
            <remarks>The real return is in the Vals array that was dimensioned before calling this function.</remarks>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.GetFloatValues">
            <summary>
            Converts all the values into a jagged array.
            The coordinates are stored [Y][X] in the resulting array.
            The index values range from 0 to NumCols - 1 for X and 0 to NumRows - 1 for Y
            </summary>
            <returns>A jagged array of float values organized as array[Y][X]</returns>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.GetRow(System.Int32,System.Single@)">
            <summary>
            Returns a one dimensional array of float values corresponding to a single row.
            The array should be dimensioned to the Number of columns in the grid.
            </summary>
            <param name="Row">The row to retrieve values from.</param>
            <param name="Vals">Float, the 0 index of an array of floats dimensioned with NumColumns elements</param>
            <returns>bool, in this case always true.  If an exception is thrown then return isn't used</returns>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.GetRow(System.Int32)">
            <summary>
            This is another version of GetRow that dimensions the values for you and returns
            the appropriate result.
            </summary>
            <param name="Row">The row to retrieve values from</param>
            <returns>A one dimensional array of floats based on the specified window</returns>
            <remarks>This will throw exceptions if there is a problem, but logging every call would be too noisy</remarks>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.GetValue(System.Int32,System.Int32)">
            <summary>
            Returns a value for a specific row and column.
            This is VERY slow through all the interfaces and COM so
            use the others where possible.  This is ok if you just
            need to get an idea for the pixels along a line or something.
            </summary>
            <param name="Column">The grid column (horizontal index) where to obtain a value</param>
            <param name="Row">The grid row (vertical index) where to obtain a value</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.GetValue(System.Double,System.Double)">
            <summary>
            Returns a value for a specific row and column.
            This is VERY slow through all the interfaces and COM so
            use the others where possible.  This is ok if you just
            need to get an idea for the pixels along a line or something.
            </summary>
            <param name="X">The X coordinate of the geographic location to find the nearest cell value</param>
            <param name="Y">The Y coordinate of the geographic lcoation to find the nearest cell value</param>
            <returns>A late bound object corresponding to the appropriate type</returns>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.Open(System.String,System.Boolean,MapWindow.Interfaces.Raster.GridFileType)">
            <summary>
            Attempts to open a file using the specified parameters.  Given the popularity of the
            float data type, the grid will make an effort to open everything as a float data type.
            </summary>
            <param name="Filename">The Filename of the grid to open</param>
            <param name="InRam">Specifies whether or not the grid is in ram.</param>
            <param name="FileType">The file format as specified by a MapWindow.Interfaces.Types.GridFileType</param>
            <exception cref="T:System.ApplicationException">Returns an exception if there is a failure</exception>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.OpenBand(System.Int32)">
            <summary>
            Not Implemented (MapWindow5.0 capability)
            </summary>
            <param name="BandNumber"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.ProjToCell(System.Double,System.Double,System.Int32@,System.Int32@)">
            <summary>
            Fills the two referenced parameters (column, row) with a closest match
            to the double coordinates specified (x, y)
            </summary>
            <param name="x">The X-coordinate or longitude to find the nearest cell to</param>
            <param name="y">The Y-coordinate or latitude to find the nearest cell to</param>
            <param name="column">The Integer index of the grid column</param>
            <param name="row">The Integer index of the grid row</param>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.ProjToCellX(System.Double)">
            <summary>
            This returns an integer Column that corresponds to the X-coordinate
            This uses (X - XLLcenter)/dx;
            </summary>
            <param name="X">Double, the X-coordinate to find the column for</param>
            <returns>Integer, the index of the column that overlaps with the X coordinate</returns>
            <remarks>Uses Math.Floor((X - Left) / dX)</remarks>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.ProjToCellY(System.Double)">
            <summary>
            This returns an integer Row that corresponds to the Y-coordinate.
            </summary>
            <param name="Y">Double, the Y-coordinate to find the row for</param>
            <returns>The integer row corresponding to the specified Y coordinate</returns>
            <remarks>Uses Numrows - Floor( (Y - Bottom) / DY )</remarks>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.PutFloatWindow(System.Single[][],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            An Accessor for the MapWinGIS.Grid PutFloatWindow method.
            </summary>
            <param name="Vals">A Jagged Array like float Values[Y][X] </param>
            <param name="StartRow">The Integer index of the Top row, inclusive</param>
            <param name="EndRow">The Integer index of the Bottom row, inclusive</param>
            <param name="StartCol">The Integer index of the Left column, inclusive</param>
            <param name="EndCol">The Integer index of the Right column, inclusive</param>
            <exception cref="T:System.ApplicationException">Returns an exception if there is a failure</exception>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.PutRow(System.Int32,System.Single@)">
            <summary>
            This version takes the first value in the float array, instead of the array.
            This one has no checking beforehand to ensure that your array length matches
            the row size and will cause an error and a false value if there is a problem.
            </summary>
            <param name="row">The Integer index of the row to save the values to</param>
            <param name="Vals">A referenced float value for the 0 index member of the array.</param>
            <returns>Bool, false if there was an error.</returns>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.PutRow(System.Int32,System.Single[])">
            <summary>
            This is just a variant of the other PutRow that accepts the 
            </summary>
            <param name="row">The Integer row index to put values in</param>
            <param name="Vals">The float values to be stored in the grid</param>
            <remarks>This throws exceptions rather than returning boolean values.</remarks>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.PutValue(System.Int32,System.Int32,System.Object)">
            <summary>
            This wraps the set_Value function in the grid object.
            This is very slow, so only use this for cases where only a few points are needed.
            </summary>
            <param name="Column">The grid column for the submitted value</param>
            <param name="Row">The grid row for the submitted value</param>
            <param name="Value">The value being specified</param>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.PutValue(System.Double,System.Double,System.Object)">
            <summary>
            Returns a value for a specific row and column.
            This is VERY slow through all the interfaces and COM so
            use the others where possible.  This is ok if you just
            need to get an idea for the pixels along a line or something.
            </summary>
            <param name="X">The X coordinate of the geographic location to find the nearest cell value</param>
            <param name="Y">The Y coordinate of the geographic lcoation to find the nearest cell value</param>
            <param name="Value">A late bound object corresponding to the new value to set</param>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.PutValues(System.Single[][])">
            <summary>
            Given a jagged float array with Y major organization, assigns the values to the grid.
            </summary>
            <param name="Vals">An Array of floats like Vals[ NumRows ][ NumCols ]</param>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.Save">
            <summary>
            Saves the grid using all the current settings, using the extension to determine file type.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.Save(System.String,MapWindow.Interfaces.Raster.GridFileType)">
            <summary>
            Saves the grid using the specified parameters
            </summary>
            <param name="Filename">The name of the file to save this raster to</param>
            <param name="newFileFormat">The file format to use when saving the grid</param>
            <returns>bool - always true - (throws exceptions)</returns>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.SetInvalidValuesToNodata(System.Double,System.Double)">
            <summary>
            Not Implemented
            </summary>
            <param name="MinThresholdValue"></param>
            <param name="MaxThresholdValue"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.Dispose(System.Boolean)">
            <summary>
            Releases com objects
            </summary>
            <param name="disposeManagedResources"></param>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.Finalize">
            <summary>
            Deconstructor (Same as calling Dispose)
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Raster.ToGrid">
            <summary>
            Returns the actual grid being used by this Raster class
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.Raster.Item(System.Int32,System.Int32)">
            <summary>
            The default indexing of a raster specifies the column and row
            values for accessing a particular value.
            </summary>
            <param name="Column"></param>
            <param name="Row"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.Raster.BandCount">
            <summary>
            Not Implemented
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.Raster.CanCreate">
            <summary>
            Not Implemented
            </summary>
            <returns>Throws NotImplementedException</returns>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.Raster.DataType">
            <summary>
            Returns the m_Grid.DataType, converted into a new 
            MapWindow.Interfaces.Types.GridDataType
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.Raster.DialogFilter">
            <summary>
            Returns the MapWinGIS.CdlgFilter
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.Raster.Dx">
            <summary>
            Gets or sets the Grid.Header.Dx
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.Raster.Dy">
            <summary>
            Gets or sets the Grid.Header.Dx
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.Raster.Envelope">
            <summary>
            Gets an Envelope 
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.Raster.Filename">
            <summary>
            Gets the filename currently associated with the MapWinGIS.Grid if any.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.Raster.HasTransparency">
            <summary>
            Not Implemented
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.Raster.Height">
            <summary>
            I am not sure if this is supposed to be the NumRows... but that is what I am returning here
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.Raster.ICallBack">
            <summary>
            Gets or Sets a MapWinGIS.ICallback to be used for future function calls that take an ICallback parameter.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.Raster.IsInRam">
            <summary>
            Gets a Boolean that is true if the grid is being stored in ram.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.Raster.LastError">
            <summary>
            Gets the string of the last error message that occured within the grid
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.Raster.Maximum">
            <summary>
            Returns the maximum value from the grid.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.Raster.Minimum">
            <summary>
            Returns the minimum value from the grid
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.Raster.NoDataValue">
            <summary>
            Gets or Sets the value that the grid should use to store no-data
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.Raster.OpenedBand">
            <summary>
            Not Implemented (MapWindow 5.0 Capability)
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.Raster.Projection">
            <summary>
            Gets or Sets the Proj-4 string to use with this grid.
            I think the grid still has to have Save() called to actually write the file.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.Raster.Width">
            <summary>
            Not Implemented
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.Raster.XllCenter">
            <summary>
            Gets or Sets the double value representing the X-coordinate, or longitude, 
            for the center of the cell in the lower left corner of the grid.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Compatibility.Raster.YllCenter">
            <summary>
            Gets or Sets the double value representing the Y-coordinate, or latitude, 
            for the center of the cell in the lower left corner of the grid.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Rasterization.LineEdge">
            <summary>
            LineEdge represents a polyline edge to be rasterized using
            Bresenham's line algorithm. 
            The edge is a straight line joining two points.
            after initialization, you can repeatedly call NextPixel()
            and get the pixels on the line.
            LineEdge uses the Bresenham line algorithm.
            
            ASSUMPTIONS OF THIS CLASS:
            (1) the starting and ending point x, y coordinates
                have already been converted to grid coordinates 
                for example, using ProjToPixel() MW function
                and rounded to integers
                the GRID COORDINATES are defined:
                (a) both axis start in the centre of the cell in 
                    top left corner of the grid
                (b) values on the (x) axis increase in downward direction
                (c) values on the (y) axis increase from left to right
            (2) the grid pixel size is 1 * 1 grid coordinate system 
                units.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Rasterization.LineEdge.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new LineEdge instance joining the points
            [xStart,yStart] and [xEnd, yEnd]
            </summary>
            <param name="xStart">x coordinate of starting point</param>
            <param name="yStart">y coordinate of starting point</param>
            <param name="xEnd">x coordinate of ending point</param>
            <param name="yEnd">y coordinate of ending point</param>
        </member>
        <member name="M:MapWinGeoProc.Rasterization.LineEdge.NextPixel">
            <summary>
            implementation of the main Bresenham line algorithm loop
            always make one step in fast direction
            if necessary, also take a step in slow direction
            </summary>
            <returns>false if the loop had been previously finished,
            otherwise true</returns>
        </member>
        <member name="P:MapWinGeoProc.Rasterization.LineEdge.NumPixels">
            <summary>
            returns the total number of pixels on
            the rasterized line edge
            </summary>
        </member>
        <member name="T:MapWinGeoProc.ClipGridWithPoly">
            <summary>
            Clips a grid so that it contains only data that falls within the polygon.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.ClipGridWithPoly.ClipGridWithPolygon(System.String@,MapWinGIS.Shape@,System.String@,System.Boolean)">
            <summary>
            Creates a new grid containing data from the input grid that
            falls within the polygon boundary.
            </summary>
            <param name="inputGF">Full path to the input grid file.</param>
            <param name="poly">The 2D polygon used for clipping the input grid.</param>
            <param name="resultGF">Full path to where the resulting grid will be saved.</param>
            <param name="clipToExtents">True if clipping to polygon extents rather than actual polygon shape.</param>
            <returns>True if clipping was successful, false if an error occurs.</returns>
        </member>
        <member name="M:MapWinGeoProc.ClipGridWithPoly.FillGrid(System.String@,System.String@,MapWinGIS.Shape@,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Fills the result grid with values from the input grid.
            </summary>
            <param name="inputGF">The path to the input grid.</param>
            <param name="resultGF">The path to the result grid.</param>
            <param name="poly">The polygon used in clipping.</param>
            <param name="newNumRows">The number of rows in the result grid.</param>
            <param name="newNumCols">The number of cols in the result grid.</param>
            <param name="rowClearCount">The number of rows that should be filled before
            the unmanaged resources are disposed of.</param>
            <param name="firstCol">The first column of the original grid that corresponds to the first column of the result grid.</param>
            <param name="firstRow">The first row of the original grid that corresponds to the first row of the result grid.</param>
            <param name="firstXPt">The X value (minX) of the first point in the result grid.</param>
            <param name="firstYPt">The Y value (maxY) of the first point in the result grid.(</param>
            <param name="clipToExtents">True if clipping to extents rather than polygon shape.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.ClipGridWithPoly.FillRow(MapWinGeoProc.GridWrapper,MapWinGeoProc.GridWrapper,MapWinGeoProc.Globals.Vertex[][]@,System.Int32,System.Double,System.Double,System.Int32,System.Int32,System.Double,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Fills a single row in the result grid with values from the input grid
            that fall within the polygon shape (or extents, if clipToExtents == true).
            </summary>
            <param name="inputGW">The wrapper object for the input grid.</param>
            <param name="resultGW">The wrapper object for the result grid.</param>
            <param name="polyVertArray">Array[numParts][numPointsPerPart] containing the polygon vertices.</param>
            <param name="row">The row to be filled.</param>
            <param name="firstXPt">The starting x position of the initial row.</param>
            <param name="yPt">The starting y position of the row.</param>
            <param name="firstCol">The first column of the input grid that will be used for filling.</param>
            <param name="firstRow">The row of the input grid that corresponds to the current row of the result grid.</param>
            <param name="cellWidth">dX value of the result grid.</param>
            <param name="newNumCols">The number of columns in the result grid.</param>
            <param name="oldNumCols">The number of columns in the input grid.</param>
            <param name="clipToExtents">True if clipping to polygon extents rather than actual polygon shape.</param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.clsHydrology.CrossSection">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.clsHydrology.CrossSection.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.clsHydrology.CrossSection.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Enumerations">
            <summary>
            Contains enumerated types used in the MapWinX library.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Enumerations.Buffer_CapStyle">
            <summary>
            Specify if the buffer shape should have rounded or pointed caps.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Enumerations.Buffer_CapStyle.Pointed">
            <summary>
            Connecting segments are joined by a single point.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Enumerations.Buffer_CapStyle.Rounded">
            <summary>
            Connecting segments are joined by a partial circle.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Enumerations.Buffer_LineSide">
            <summary>
            Specify how much of the line should be buffered.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Enumerations.Buffer_LineSide.Both">
            <summary>
            The buffer will occur on both sides of the line.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Enumerations.Buffer_LineSide.Left">
            <summary>
            The buffer will occur on the left side of the line.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Enumerations.Buffer_LineSide.Right">
            <summary>
            The buffer will occur on the right side of the line.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Enumerations.Buffer_HoleTreatment">
            <summary>
            Specify how holes in multiPart polygons should be treated.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Enumerations.Buffer_HoleTreatment.Ignore">
            <summary>
            Holes will not be considered or included in the resulting buffer.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Enumerations.Buffer_HoleTreatment.Opposite">
            <summary>
            Holes will shrink with positive distance and grow with negative distance.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Enumerations.Buffer_HoleTreatment.Same">
            <summary>
            Holes will grow with positive distance and shrik with negative distance.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Enumerations.Buffer_HoleTreatment.Original">
            <summary>
            The hole will be included in the result but will not be buffered.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Topology.Polygon">
            <summary>
            A structure representing a single closed polygon.  This would represent a single part
            of a polygon shape.  
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology.Polygon.#ctor">
            <summary>
            Creates a new blank instance of the Polygon Class
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology.Polygon.#ctor(MapWinGIS.Shape)">
            <summary>
            Creates a new instance of the Polygon class
            The shape is closed, but the first and last point will be the same.
            This way, algorithms don't have to loop back to the 0 point in order to evaluate
            the final segment.
            </summary>
            <param name="mwShape">A MapWinGIS.Shape to derive the Polygon from</param>
            <remarks>Assumes shape is one part.  To Split Multipart shapes, use Split.</remarks>
        </member>
        <member name="M:MapWinGeoProc.Topology.Polygon.Invalidate">
            <summary>
            Many properties are derived from the points.  Generally, these are calculated
            once and cached.  Most changes that can be made externally will automatically
            cause an invalidation to occur, so adding points, for instance, will force
            the perimeter to be recalculated.  This forces such an invalidation so that the
            next time derived properties are queried, they will be recalculated.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology.Polygon.Add_Point(MapWinGeoProc.Topology.Point)">
            <summary>
            Adds a point to the list of points and adjusts the extents
            Invalidates derived properties so that they will be recalculated when
            queried.
            </summary>
            <param name="newPoint">A Point to add to the Polygon</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.Polygon.Add_Point(MapWinGIS.Point)">
            <summary>
            Adds a MapWinGIS.Point to the list of points and adjusts the extents
            Invalidates derived properties so that they will be recalculated when
            queried.
            </summary>
            <param name="mwPoint">A MapWinGIS.Point to append to the list</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.Polygon.Insert_Point(System.Int32,MapWinGeoProc.Topology.Point)">
            <summary>
            Inserts a point in the list.  Remember that this list does not need to
            end with the first point.  Invalidates derived properties so that they
            will be recalculated when queried.
            </summary>
            <param name="Index">The index specifying where to insert the point</param>
            <param name="newPoint">The Point you want to insert into this polyline</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.Polygon.Insert_Point(System.Int32,MapWinGIS.Point)">
            <summary>
            Inserts a point in the list.  Remember that this list does not need to
            end with the first point.  Invalidates derived properties so that they
            will be recalculated when queried.
            </summary>
            <param name="Index">The index specifying where to insert the point</param>
            <param name="mwPoint">The MapWinGIS.Point you want to insert into this Polygon</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.Polygon.Add_LineSegment(MapWinGeoProc.Topology.LineSegment)">
            <summary>
            Appends the the givin line segment to the end of the polyline.
            We assume that if the first point in the segment is the same as the
            endpoint of the polygon, we don't need to add the first point.
            </summary>
            <param name="newLineSegment">LineSegment, the line segment to append</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.Polygon.Insert_LineSegment(System.Int32,MapWinGeoProc.Topology.LineSegment)">
            <summary>
            Inserts a segment into a polyline.
            This will check the points of the segment and only add the points if they are 
            not identical to what will become the adjacent points.
            </summary>
            <param name="Index">the position to add the segment in the list of points</param>
            <param name="newLineSegment">The LineSegment to insert</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.Polygon.Intersects(MapWinGeoProc.Topology.Point)">
            <summary>
            Only returns true if the point is in the same plane as the polygon
            and the polygon encloses the point.  Touching a node is considered intersecting.
            </summary>
            <param name="Point"></param>
            <returns>Boolean, true if the sum of all the angles = 360</returns>
            <remarks>The code for cross-type intersect is in the larger structure</remarks>
        </member>
        <member name="M:MapWinGeoProc.Topology.Polygon.ToLineSegments">
            <summary>
            Will create a list of segment objects for the entire polygon
            </summary>
            <returns>A List of LineSegments representing the entire polygon</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Polygon.LineSegmentsWithin(MapWinGeoProc.Topology.Envelope)">
            <summary>
            Returns a list of segments from the Polygon that are within the
            submitted extents.
            </summary>
            <param name="Ext">Envelope to check for an intersection with.</param>
            <returns>Returns a list of possible Envelope within range.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Polygon.mwShape_To_Polygon(MapWinGIS.Shape)">
            <summary>
            If a Shape has multiple parts, this will create a separate polyline for each part.
            </summary>
            <param name="mwShape">A MapWinGIS.Shape that should be a LineString shape type</param>
            <returns>A List of Polylines derived from the various shapes</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Polygon.Polygon_To_mwShape(System.Collections.Generic.List{MapWinGeoProc.Topology.LineString})">
            <summary>
            Converts a list of polylines into a single multi-part shape
            </summary>
            <param name="Polygons"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.Topology.Polygon.Area">
            <summary>
            Returns the area enclosed by the polygon with respect to the X-Y plane
            http://local.wasp.uwa.edu.au/~pbourke/geometry/polyarea/
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology.Polygon.Center">
            <summary>
            Returns a Point representing the midpoint between all the extents.
            This is not the same as the centroid, which is wieghted by the
            enclosed area.  Setting this will translate your entire polyline,
            so be careful.  The center will automatically correct itself if points are added.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology.Polygon.Envelope">
            <summary>
            The extents that form a bounding box around the polyline.
            If you added a series of points, this will be calculated and then cached.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology.Polygon.MaxRadius">
            <summary>
            Gets a double specifying the maximum distance any segment gets from the center
            where the center is defined as the middle of the extents.  Since it is not
            possible for the segments to be further away than the endpoints, the max radius
            must be defined by one of the vertecies.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology.Polygon.Perimeter">
            <summary>
            Gets a double specifying the length along the polyline
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology.Polygon.Points">
            <summary>
            A list of points within this polygon.  The last point is NOT the same
            as the first, so when adding points just add the last one.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Utilities.Stopwatch">
            <summary>
            Implements a timer function which can compute
            elapsed time as well as split times.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.Stopwatch.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.Stopwatch.Start">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Utilities.Stopwatch.Time">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Utilities.Stopwatch.TimeAsString">
            <summary>
            
            </summary>
        </member>
        <member name="T:Iesi.Collections.Generic.SetWrapper`1">
            <summary>
            A wrapper that can wrap a ISet as a generic ISet&lt;T&gt; 
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>
            In most operations, there is no copying of collections. The wrapper just delegate the function to the wrapped.
            The following functions' implementation may involve collection copying:
            Union, Intersect, Minus, ExclusiveOr, ContainsAll, AddAll, RemoveAll, RetainAll
            </remarks>
            <exception cref="T:System.InvalidCastException">
            If the wrapped has any item that is not of Type T, InvalidCastException could be thrown at any time
            </exception>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.#ctor(Iesi.Collections.ISet)">
            <summary>
            SetWrapper based on an ISet
            </summary>
            <param name="toWrap"></param>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.Union(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Joines two sets
            </summary>
            <param name="a">an ISet to merge with</param>
            <returns>the union of this set and the ISet specified</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.Intersect(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            THe intersection of this set and the specified ISet
            </summary>
            <param name="a">An Iset</param>
            <returns>The collection of items that are in both sets</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.Minus(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            removes the items from the specified ISet from this set
            </summary>
            <param name="a">An ISet to subtract</param>
            <returns>the items that are in this set but not in the specified ISet</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.ExclusiveOr(Iesi.Collections.Generic.ISet{`0})">
            <summary>
            Returns the items that exist in one set or the other, but not both
            </summary>
            <param name="a">The set to compare against</param>
            <returns>An ISet with the items in this set or the specified set but not both</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.Contains(`0)">
            <summary>
            Tests if the specified item is in this set
            </summary>
            <param name="o">An item to test</param>
            <returns>Boolean, true if the item is in the set</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.ContainsAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Tests if every member of an ICollection, and returns true if they are all in this set
            </summary>
            <param name="c">The collection of items to test</param>
            <returns>Boolean, true if every member of the specified collection is in this set</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.Add(`0)">
            <summary>
            Adds a member to the set
            </summary>
            <param name="o">an item to add</param>
            <returns>true if the add was successful</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.AddAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Adds every member of a collection to the set
            </summary>
            <param name="c">The collection with members to add</param>
            <returns>True if the add was successful</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.Remove(`0)">
            <summary>
            Removes a specified item from the set
            </summary>
            <param name="o">the item to remove</param>
            <returns>Boolean, true if the removal was successful</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.RemoveAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            Removes a collection from the set
            </summary>
            <param name="c">The collection to remove</param>
            <returns>true if the removal was successful</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.RetainAll(System.Collections.Generic.ICollection{`0})">
            <summary>
            
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.Clear">
            <summary>
            Clears the members from this collection
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.Clone">
            <summary>
            Creates a duplicate of this set
            </summary>
            <returns>An ISet duplicate of this set</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.CopyTo(`0[],System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Iesi.Collections.Generic.SetWrapper`1.GetEnumerator">
            <summary>
            Returns an enumerator that can be used to iterate through the members of this set
            </summary>
            <returns> Returns an IEnumerator that can be used to iterate through the members of this set</returns>
        </member>
        <member name="P:Iesi.Collections.Generic.SetWrapper`1.IsEmpty">
            <summary>
            Boolean, true if this set has no items
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.SetWrapper`1.Count">
            <summary>
            The number of elements in this set
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.SetWrapper`1.IsReadOnly">
            <summary>
            Tests if this set is read only... this is always false
            </summary>
        </member>
        <member name="T:Iesi.Collections.Generic.HashedSet`1">
            <summary>
            Implements a <c>Set</c> based on a hash table.  This will give the best lookup, add, and remove
            performance for very large data-sets, but iteration will occur in no particular order.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.HashedSet`1.#ctor">
            <summary>
            Creates a new set instance based on a hash table.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.HashedSet`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Creates a new set instance based on a hash table and
            initializes it based on a collection of elements.
            </summary>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineSegment">
            <summary>
            A LineSegment which is tagged with its location in a <c>Geometry</c>.
            Used to index the segments in a point and recover the segment locations
            from the index.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.LineSegment">
            <summary> 
            Represents a line segment defined by two <c>Coordinate</c>s.
            Provides methods to compute various geometric properties
            and relationships of line segments.
            This class is designed to be easily mutable (to the extent of
            having its contained points public).
            This supports a common pattern of reusing a single LineSegment
            object as a way of computing segment properties on the
            segments defined by arrays or lists of <c>Coordinate</c>s.
            </summary>    
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.#ctor(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Creates an instance of LineSegment from two coordiantes
            </summary>
            <param name="p0">The first point of the segment</param>
            <param name="p1">The second point of the segment</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.#ctor(MapWindow.Interfaces.Geometries.ILineSegmentBase)">
            <summary>
            Creates a new instance of a LineSegment which implements
            ILineSegment and ILineSegmentBase from an ILineSegmentBase
            </summary>
            <param name="ls"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.#ctor">
            <summary>
            Creates a new instance of a LineSegment which implements
            ILineSegment and ILineSegmentBase
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.GetCoordinate(System.Int32)">
            <summary>
            Retrieves the i'th coordiante.  Since there are only two,
            i can be either 0 or 1.
            </summary>
            <param name="i">Integer, specifies the coordiante</param>
            <returns>A topologically complete ICoordinate</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.SetCoordinates(MapWindow.Interfaces.Geometries.ILineSegmentBase)">
            <summary>
            Defines a new LineSegment based on the previous line segment
            </summary>
            <param name="ls">The ILineSegmentBase</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.SetCoordinates(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Sets the new coordinates using the ICoordinate interfaces specified
            </summary>
            <param name="p0">The first endpoint</param>
            <param name="p1">The second endpoint</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.OrientationIndex(MapWindow.Interfaces.Geometries.ILineSegmentBase)">
            <summary> 
            Determines the orientation of a LineSegment relative to this segment.
            The concept of orientation is specified as follows:
            Given two line segments A and L,
            A is to the left of a segment L if A lies wholly in the
            closed half-plane lying to the left of L
            A is to the right of a segment L if A lies wholly in the
            closed half-plane lying to the right of L
            otherwise, A has indeterminate orientation relative to L. This
            happens if A is collinear with L or if A crosses the line determined by L.
            </summary>
            <param name="seg">The <c>LineSegment</c> to compare.</param>
            <returns>
            1 if <c>seg</c> is to the left of this segment,        
            -1 if <c>seg</c> is to the right of this segment,
            0 if <c>seg</c> has indeterminate orientation relative to this segment.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.Reverse">
            <summary> 
            Reverses the direction of the line segment.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.Normalize">
            <summary> 
            Puts the line segment into a normalized form.
            This is useful for using line segments in maps and indexes when
            topological equality rather than exact equality is desired.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.Distance(MapWindow.Interfaces.Geometries.ILineSegmentBase)">
            <summary> 
            Computes the distance between this line segment and another one.
            </summary>
            <param name="ls"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.Distance(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary> 
            Computes the distance between this line segment and a point.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.DistancePerpendicular(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary> 
            Computes the perpendicular distance between the (infinite) line defined
            by this line segment and a point.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.ProjectionFactor(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Compute the projection factor for the projection of the point p
            onto this <c>LineSegment</c>. The projection factor is the constant k
            by which the vector for this segment must be multiplied to
            equal the vector for the projection of p.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.Project(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary> 
            Compute the projection of a point onto the line determined
            by this line segment.
            Note that the projected point
            may lie outside the line segment.  If this is the case,
            the projection factor will lie outside the range [0.0, 1.0].
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.Project(MapWindow.Interfaces.Geometries.ILineSegmentBase)">
            <summary> 
            Project a line segment onto this line segment and return the resulting
            line segment.  The returned line segment will be a subset of
            the target line line segment.  This subset may be null, if
            the segments are oriented in such a way that there is no projection.
            Note that the returned line may have zero length (i.e. the same endpoints).
            This can happen for instance if the lines are perpendicular to one another.
            </summary>
            <param name="seg">The line segment to project.</param>
            <returns>The projected line segment, or <c>null</c> if there is no overlap.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.ClosestPoint(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary> 
            Computes the closest point on this line segment to another point.
            </summary>
            <param name="p">The point to find the closest point to.</param>
            <returns>
            A Coordinate which is the closest point on the line segment to the point p.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.ClosestPoints(MapWindow.Interfaces.Geometries.ILineSegmentBase)">
            <summary>
            Computes the closest points on a line segment.
            </summary>
            <param name="line"></param>
            <returns>
            A pair of Coordinates which are the closest points on the line segments.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.Intersection(MapWindow.Interfaces.Geometries.ILineSegmentBase)">
            <summary>
            Computes an intersection point between two segments, if there is one.
            There may be 0, 1 or many intersection points between two segments.
            If there are 0, null is returned. If there is 1 or more, a single one
            is returned (chosen at the discretion of the algorithm).  If
            more information is required about the details of the intersection,
            the {RobustLineIntersector} class should be used.
            </summary>
            <param name="line"></param>
            <returns> An intersection point, or <c>null</c> if there is none.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.Equals(System.Object)">
            <summary>  
            Returns <c>true</c> if <c>o</c> has the same values for its points.
            </summary>
            <param name="o">A <c>LineSegment</c> with which to do the comparison.</param>
            <returns>
            <c>true</c> if <c>o</c> is a <c>LineSegment</c>
            with the same values for the x and y ordinates.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.op_Equality(MapWinGeoProc.NTS.Topology.Geometries.LineSegment,MapWindow.Interfaces.Geometries.ILineSegmentBase)">
            <summary>
            
            </summary>
            <param name="obj1"></param>
            <param name="obj2"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.op_Inequality(MapWinGeoProc.NTS.Topology.Geometries.LineSegment,MapWindow.Interfaces.Geometries.ILineSegmentBase)">
            <summary>
            
            </summary>
            <param name="obj1"></param>
            <param name="obj2"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.CompareTo(System.Object)">
            <summary>
            Compares this object with the specified object for order.
            Uses the standard lexicographic ordering for the points in the LineSegment.
            </summary>
            <param name="o">
            The <c>LineSegment</c> with which this <c>LineSegment</c>
            is being compared.
            </param>
            <returns>
            A negative integer, zero, or a positive integer as this <c>LineSegment</c>
            is less than, equal to, or greater than the specified <c>LineSegment</c>.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.EqualsTopologically(MapWindow.Interfaces.Geometries.ILineSegmentBase)">
            <summary>
            Returns <c>true</c> if <c>other</c> is
            topologically equal to this LineSegment (e.g. irrespective
            of orientation).
            </summary>
            <param name="other">
            A <c>LineSegment</c> with which to do the comparison.
            </param>
            <returns>
            <c>true</c> if <c>other</c> is a <c>LineSegment</c>
            with the same values for the x and y ordinates.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.GetHashCode">
            <summary>
            Return HashCode.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.P1">
            <summary>
            returns the one of the ICoordinate that defines this linesegment
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.cP1">
            <summary>
            returns the Coordinate representing the first ICoordinate 
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.P0">
            <summary>
            returns the ICoordianteBase defining the second endpoint of the segment
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.cP0">
            <summary>
            returns a Coordinate representing the second endpoint of the segment
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.Length">
            <summary>
            Computes the length of the line segment.
            </summary>
            <returns>The length of the line segment.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.IsHorizontal">
            <summary> 
            Tests whether the segment is horizontal.
            </summary>
            <returns><c>true</c> if the segment is horizontal.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.IsVertical">
            <summary>
            Tests whether the segment is vertical.
            </summary>
            <returns><c>true</c> if the segment is vertical.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineSegment.Angle">
            <returns> 
            The angle this segment makes with the x-axis (in radians).
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineSegment.#ctor(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.IGeometry,System.Int32)">
            <summary>
            
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <param name="parent"></param>
            <param name="index"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineSegment.#ctor(MapWinGeoProc.NTS.Topology.Geometries.Coordinate,MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineSegment.Parent">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineSegment.Index">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Valid.SimpleNestedRingTester">
            <summary>
            Tests whether any of a set of <c>LinearRing</c>s are
            nested inside another ring in the set, using a simple O(n^2)
            comparison.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.SimpleNestedRingTester.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            
            </summary>
            <param name="graph"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.SimpleNestedRingTester.Add(MapWinGeoProc.NTS.Topology.Geometries.LinearRing)">
            <summary>
            
            </summary>
            <param name="ring"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.SimpleNestedRingTester.IsNonNested">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Valid.SimpleNestedRingTester.NestedPoint">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.ShapefileWriter">
            <summary>
            This class writes ESRI Shapefiles.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileWriter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MapWinGeoProc.NTS.Topology.IO.ShapefileWriter"/> class 
            using <see cref="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.Default"/> with a <see cref="F:MapWindow.Interfaces.Geometries.PrecisionModels.Floating"/> precision.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileWriter.#ctor(MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:MapWinGeoProc.NTS.Topology.IO.ShapefileWriter"/> class
            with the given <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory"/>.
            </summary>
            <param name="geometryFactory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileWriter.Write(System.String,MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection)">
            <summary>
            Writes a shapefile to disk.
            </summary>
            <remarks>
            Assumes the type given for the first geometry is the same for all subsequent geometries.
            For example, is, if the first Geometry is a Multi-polygon/ Polygon, the subsequent geometies are
            Muli-polygon/ polygon and not lines or points.
            The dbase file for the corresponding shapefile contains one column called row. It contains 
            the row number.
            </remarks>
            <param name="filename">The filename to write to (minus the .shp extension).</param>
            <param name="geometryCollection">The GeometryCollection to write.</param>		
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileWriter.WriteDummyDbf(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="filename"></param>
            <param name="recordCount"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.ShapefileHeader">
            <summary>
            Class that represents a shape file header record.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileHeader.#ctor(MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryReader)">
            <summary>
            Initializes a new instance of the ShapefileHeader class with values read in from the stream.
            </summary>
            <remarks>Reads the header information from the stream.</remarks>
            <param name="shpBinaryReader">BigEndianBinaryReader stream to the shapefile.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileHeader.#ctor">
            <summary>
            Initializes a new instance of the ShapefileHeader class.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileHeader.Write(MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryWriter)">
            <summary>
            Writes a shapefile header to the given stream;
            </summary>
            <param name="file">The binary writer to use.</param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ShapefileHeader.Bounds">
            <summary>
            Gets and sets the bounds of the shape file.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ShapefileHeader.ShapeType">
            <summary>
            Gets and sets the shape file type i.e. polygon, point etc...
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ShapefileHeader.Version">
            <summary>
            Gets and sets the shapefile version.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ShapefileHeader.FileLength">
            <summary>
            Gets and sets the length of the shape file in words.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryReader">
            <summary>
            Extends the <see cref="T:System.IO.BinaryReader"/> class to allow reading of integers and doubles 
            in the Big Endian format.
            </summary>
            <remarks>
            The BinaryReader uses Little Endian format when reading binary streams.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryReader.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the BigEndianBinaryReader class 
            based on the supplied stream and using UTF8Encoding.
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryReader.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Initializes a new instance of the BigEndianBinaryReader class 
            based on the supplied stream and a specific character encoding.
            </summary>
            <param name="input"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryReader.ReadInt32BE">
            <summary>
            Reads a 4-byte signed integer using the big-endian layout 
            from the current stream and advances the current position of the stream by four bytes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryReader.ReadDoubleBE">
            <summary>
            Reads a 8-byte signed double using the big-endian layout 
            from the current stream and advances the current position of the stream by eight bytes.
            </summary>
            <returns></returns>        
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollectionEnumerator">
            <summary>
            Iterates over all <c>Geometry</c>'s in a <c>GeometryCollection</c>. 
            Implements a pre-order depth-first traversal of the <c>GeometryCollection</c>
            (which may be nested). The original <c>GeometryCollection</c> is
            returned as well (as the first object), as are all sub-collections. It is
            simple to ignore the <c>GeometryCollection</c> objects if they are not
            needed.
            </summary>    
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollectionEnumerator.parent">
            <summary>
            The <c>GeometryCollection</c> being iterated over.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollectionEnumerator.atStart">
            <summary>
            Indicates whether or not the first element (the <c>GeometryCollection</c>
            ) has been returned.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollectionEnumerator.max">
            <summary>
            The number of <c>Geometry</c>s in the the <c>GeometryCollection</c>.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollectionEnumerator.index">
            <summary>
            The index of the <c>Geometry</c> that will be returned when <c>next</c>
            is called.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollectionEnumerator.subcollectionEnumerator">
            <summary>
            The iterator over a nested <c>GeometryCollection</c>, or <c>null</c>
            if this <c>GeometryCollectionIterator</c> is not currently iterating
            over a nested <c>GeometryCollection</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollectionEnumerator.#ctor(MapWindow.Interfaces.Geometries.IGeometryCollection)">
            <summary>
            Constructs an iterator over the given <c>GeometryCollection</c>.
            </summary>
            <param name="parent">
            The collection over which to iterate; also, the first
            element returned by the iterator.
            </param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollectionEnumerator.MoveNext">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollectionEnumerator.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryCollectionEnumerator.Current">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.Dimension">
            <summary>
            Class containing static methods for conversions
            between Dimension values and characters.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Dimension.ToDimensionSymbol(MapWindow.Interfaces.Geometries.Dimensions)">
            <summary>
            Converts the dimension value to a dimension symbol,
            for example, <c>True => 'T'</c>
            </summary>
            <param name="dimensionValue">Number that can be stored in the <c>IntersectionMatrix</c>.
            Possible values are <c>True, False, Dontcare, 0, 1, 2</c>.</param>
            <returns>Character for use in the string representation of an <c>IntersectionMatrix</c>.
            Possible values are <c>T, F, * , 0, 1, 2</c>.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Dimension.ToDimensionValue(System.Char)">
            <summary>
            Converts the dimension symbol to a dimension value,
            for example, <c>'*' => Dontcare</c>
            </summary>
            <param name="dimensionSymbol">Character for use in the string representation of an <c>IntersectionMatrix</c>.
            Possible values are <c>T, F, * , 0, 1, 2</c>.</param>
            <returns>Number that can be stored in the <c>IntersectionMatrix</c>.
            Possible values are <c>True, False, Dontcare, 0, 1, 2</c>.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequenceFactory">
            <summary>
            Creates CoordinateSequences internally represented
            as an array of x's and an array of y's.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequenceFactory.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequenceFactory.Create(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Returns a DefaultCoordinateSequence based on the given array
            (the array is not copied).
            </summary>
            <param name="coordinates">Coordinates array, which may not be null
            nor contain null elements</param>
            <returns>Singleton instance of DefaultCoordinateSequenceFactory.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.DefaultCoordinateSequenceFactory.Instance">
            <summary>
            Returns the singleton instance of DefaultCoordinateSequenceFactory.
            </summary>
            <returns>Singleton instance of DefaultCoordinateSequenceFactory.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.QuadrantOp">
            <summary> 
            Utility functions for working with quadrants, which are numbered as follows:
            <para>
            1 | 0
            --+--
            2 | 3
            </para>
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.QuadrantOp.#ctor">
            <summary>
            Only static methods!
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.QuadrantOp.Quadrant(System.Double,System.Double)">
            <summary> 
            Returns the quadrant of a directed line segment (specified as x and y
            displacements, which cannot both be 0).
            </summary>
            <param name="dx"></param>
            <param name="dy"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.QuadrantOp.Quadrant(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary> 
            Returns the quadrant of a directed line segment from p0 to p1.
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.QuadrantOp.IsOpposite(System.Int32,System.Int32)">
            <summary>
            Returns true if the quadrants are 1 and 3, or 2 and 4.
            </summary>
            <param name="quad1"></param>
            <param name="quad2"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.QuadrantOp.CommonHalfPlane(System.Int32,System.Int32)">
            <summary>
            Returns the right-hand quadrant of the halfplane defined by the two quadrants,
            or -1 if the quadrants are opposite, or the quadrant if they are identical.
            </summary>
            <param name="quad1"></param>
            <param name="quad2"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.QuadrantOp.IsInHalfPlane(System.Int32,System.Int32)">
            <summary> 
            Returns whether the given quadrant lies within the given halfplane (specified
            by its right-hand quadrant).
            </summary>
            <param name="quad"></param>
            <param name="halfPlane"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.QuadrantOp.IsNorthern(System.Int32)">
            <summary> 
            Returns true if the given quadrant is 0 or 1.
            </summary>
            <param name="quad"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ILocalDatum">
            <summary>
            Local datum. If two local datum objects have the same datum type and name, 
            then they can be considered equal. This means that coordinates can be
            transformed between two different local coordinate systems, as long as
            they are based on the same local datum.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo">
            <summary>
            Details of axis. This is used to label axes, and indicate the orientation.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo.#ctor(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisOrientationEnum)">
            <summary>
            Initializes a new instance of an AxisInfo.
            </summary>
            <param name="name">Name of axis</param>
            <param name="orientation">Axis orientation</param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo.Name">
            <summary>
            Human readable name for axis. Possible values are X, Y, Long, Lat or any other short string.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo.Orientation">
            <summary>
            Gets enumerated value for orientation.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo.WKT">
            <summary>
            Returns the Well-known text for this object
            as defined in the simple features specification.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo.XML">
            <summary>
            Gets an XML representation of this object
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Erase">
            <summary>
            The erase functions remove portions of the input shapefile that fall within the erase polygon(s).
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Erase.ErasePointSFWithPoly(MapWinGIS.Shapefile@,MapWinGIS.Shape@,MapWinGIS.Shapefile@,System.Boolean)">
            <summary>
            Removes points from the point shapefile that lie within the polygon.
            </summary>
            <param name="pointSF">The point shapefile.</param>
            <param name="polygon">The erase polygon.</param>
            <param name="resultSF">The resulting file with points removed.</param>
            <param name="CopyAttributes">Indicates whether to copy attributes</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Erase.ErasePointSFWithPolySF(MapWinGIS.Shapefile@,MapWinGIS.Shapefile@,MapWinGIS.Shapefile@)">
            <summary>
            Removes points from the point shapefile that lie within any shapes in the polygon shapefile.
            </summary>
            <param name="pointSF">The point shapefile.</param>
            <param name="polygonSF">The shapefile containing the erase polygons.</param>
            <param name="resultSF">The resulting file with points removed.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Erase.ErasePolySFWithPoly(MapWinGIS.Shapefile@,MapWinGIS.Shape@,MapWinGIS.Shapefile@,System.Boolean)">
            <summary>
            Erases the portions of the polygon shapefile that are within the polygon shape.
            </summary>
            <param name="polySF">The polygon shapefile.</param>
            <param name="polygon">The erase polygon.</param>
            <param name="resultSF">The resulting shapefile, with portions removed.</param>
            <param name="CopyAttributes">Indicates whether to copy attributes or not.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Erase.ErasePolySFWithPolySF(MapWinGIS.Shapefile@,MapWinGIS.Shapefile@,MapWinGIS.Shapefile@)">
            <summary>
            Removes portions of the input polygon shapefile that are within the erase polygons.
            </summary>
            <param name="inputSF">The input polygon shapefile.</param>
            <param name="eraseSF">The erase polygon shapefile.</param>
            <param name="resultSF">The resulting shapefile, with portions removed.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Erase.EraseLineSFWithPoly(MapWinGIS.Shapefile@,MapWinGIS.Shape@,MapWinGIS.Shapefile@,System.Boolean)">
            <summary>
            Removes portions of the lineSF that fall within the erase polygon
            </summary>
            <param name="lineSF">The shapefile of lines to be erased.</param>
            <param name="erasePoly">The polygon to be used for erasing portion of the line shapefile.</param>
            <param name="resultSF">The resulting line shapefile with portions removed.</param>
            <param name="CopyAttributes">Indicates whether to copy attributes</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Erase.EraseLineSFWithPolySF(MapWinGIS.Shapefile@,MapWinGIS.Shapefile@,MapWinGIS.Shapefile@)">
            <summary>
            Removes portions of the input line shapefile that fall within the polygons of the erase polygon shapefile.
            </summary>
            <param name="inputSF">The line shapefile to erase.</param>
            <param name="eraseSF">The polygon shapefile that will be used to erase portions of the line shapefile.</param>
            <param name="resultSF">The result shapefile.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="T:KDTreeDLL.HPoint">
            <summary>
            Hyper-Point class supporting KDTree class
            </summary>
        </member>
        <member name="T:Iesi.Collections.Generic.CollectionWrapper`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Iesi.Collections.Generic.CollectionWrapper`1.#ctor(System.Collections.ICollection)">
            <summary>
            Wraps an ICollection
            </summary>
            <param name="toWrap"></param>
        </member>
        <member name="M:Iesi.Collections.Generic.CollectionWrapper`1.Add(`0)">
            <summary>
            Throws a NotSupportedException because the collection is readonly
            </summary>
            <param name="item">the item to add</param>
        </member>
        <member name="M:Iesi.Collections.Generic.CollectionWrapper`1.Clear">
            <summary>
            Throws a NotSupportedException because the collection is readonly
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.CollectionWrapper`1.Contains(`0)">
            <summary>
            Tests if an item is contained within the set
            </summary>
            <param name="item">the item to test</param>
            <returns>Boolean if the item exists in the set</returns>
        </member>
        <member name="M:Iesi.Collections.Generic.CollectionWrapper`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies an array of items to the collection
            </summary>
            <param name="array">an array to copy to the set</param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Iesi.Collections.Generic.CollectionWrapper`1.Remove(`0)">
             <summary>
            Throws a NotSupportedException because the collection is readonly
             </summary>
             <param name="item"></param>
             <returns></returns>
        </member>
        <member name="M:Iesi.Collections.Generic.CollectionWrapper`1.ThrowReadOnlyException">
            <summary>
            Throws a NotSupportedException because the collection is readonly
            </summary>
            <returns></returns>
        </member>
        <member name="P:Iesi.Collections.Generic.CollectionWrapper`1.Count">
            <summary>
            The number of items in the collection
            </summary>
        </member>
        <member name="P:Iesi.Collections.Generic.CollectionWrapper`1.IsReadOnly">
            <summary>
            Tests if this is read only, and it is always true.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Precision.SimpleGeometryPrecisionReducer">
            <summary>
            Reduces the precision of a <c>Geometry</c>
            according to the supplied {PrecisionModel}, without
            attempting to preserve valid topology.
            The topology of the resulting point may be invalid if
            topological collapse occurs due to coordinates being shifted.
            It is up to the client to check this and handle it if necessary.
            Collapses may not matter for some uses. An example
            is simplifying the input to the buffer algorithm.
            The buffer algorithm does not depend on the validity of the input point.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.SimpleGeometryPrecisionReducer.#ctor(MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel)">
            <summary>
            
            </summary>
            <param name="pm"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.SimpleGeometryPrecisionReducer.Reduce(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Precision.SimpleGeometryPrecisionReducer.RemoveCollapsedComponents">
            <summary>
            Sets whether the reduction will result in collapsed components
            being removed completely, or simply being collapsed to an (invalid)
            Geometry of the same type.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Precision.SimpleGeometryPrecisionReducer.ChangePrecisionModel">
            <summary>
            Gets/Sets whether the PrecisionModel of the new reduced Geometry
            will be changed to be the PrecisionModel supplied to
            specify the reduction.  
            The default is to not change the precision model.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Precision.SimpleGeometryPrecisionReducer.PrecisionReducerCoordinateOperation">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryEditor.CoordinateOperation">
            <summary>
            A GeometryEditorOperation which modifies the coordinate list of a <c>Geometry</c>.
            Operates on Geometry subclasses which contains a single coordinate list.
            </summary>      
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryEditor.GeometryEditorOperation">
            <summary> 
            A interface which specifies an edit operation for Geometries.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryEditor">
            <summary> 
            Supports creating a new <c>Geometry</c> which is a modification of an existing one.
            Geometry objects are intended to be treated as immutable.
            This class allows you to "modify" a Geometry
            by traversing it and creating a new Geometry with the same overall structure but
            possibly modified components.
            The following kinds of modifications can be made:
            <para>
            The values of the coordinates may be changed.
            Changing coordinate values may make the result Geometry invalid;
            this is not checked by the GeometryEditor.
            </para>
            <para>The coordinate lists may be changed
            (e.g. by adding or deleting coordinates).
            The modifed coordinate lists must be consistent with their original parent component
            (e.g. a LinearRing must always have at least 4 coordinates, and the first and last
            coordinate must be equal).
            </para>
            <para>Components of the original point may be deleted
            (e.g. holes may be removed from a Polygon, or LineStrings removed from a MultiLineString).
            Deletions will be propagated up the component tree appropriately.
            </para>
            Note that all changes must be consistent with the original Geometry's structure
            (e.g. a Polygon cannot be collapsed into a LineString).
            The resulting Geometry is not checked for validity.
            If validity needs to be enforced, the new Geometry's IsValid should be checked.
            </summary>    
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryEditor.factory">
            <summary> 
            The factory used to create the modified Geometry.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryEditor.#ctor">
            <summary> 
            Creates a new GeometryEditor object which will create
            an edited <c>Geometry</c> with the same {GeometryFactory} as the input Geometry.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryEditor.#ctor(MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory)">
            <summary> 
            Creates a new GeometryEditor object which will create
            the edited Geometry with the given GeometryFactory.
            </summary>
            <param name="factory">The GeometryFactory to create the edited Geometry with.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryEditor.Edit(MapWindow.Interfaces.Geometries.IGeometry,MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryEditor.GeometryEditorOperation)">
            <summary> 
            Edit the input <c>Geometry</c> with the given edit operation.
            Clients will create subclasses of GeometryEditorOperation or
            CoordinateOperation to perform required modifications.
            </summary>
            <param name="geometry">The Geometry to edit.</param>
            <param name="operation">The edit operation to carry out.</param>
            <returns>A new <c>Geometry</c> which is the result of the editing.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryEditor.EditPolygon(MapWinGeoProc.NTS.Topology.Geometries.Polygon,MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryEditor.GeometryEditorOperation)">
            <summary>
            
            </summary>
            <param name="polygon"></param>
            <param name="operation"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryEditor.EditGeometryCollection(MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection,MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryEditor.GeometryEditorOperation)">
            <summary>
            
            </summary>
            <param name="collection"></param>
            <param name="operation"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryEditor.GeometryEditorOperation">
            <summary> 
            A interface which specifies an edit operation for Geometries.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryEditor.GeometryEditorOperation.Edit(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            Edits a Geometry by returning a new Geometry with a modification.
            The returned Geometry might be the same as the Geometry passed in.
            </summary>
            <param name="geometry">The Geometry to modify.</param>
            <param name="factory">
            The factory with which to construct the modified Geometry
            (may be different to the factory of the input point).
            </param>
            <returns>A new Geometry which is a modification of the input Geometry.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryEditor.CoordinateOperation">
            <summary>
            A GeometryEditorOperation which modifies the coordinate list of a <c>Geometry</c>.
            Operates on Geometry subclasses which contains a single coordinate list.
            </summary>      
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryEditor.CoordinateOperation.Edit(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            
            </summary>
            <param name="geometry"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.GeometryEditor.CoordinateOperation.Edit(MapWindow.Interfaces.Geometries.ICoordinate[],MapWindow.Interfaces.Geometries.IGeometry)">
            <summary> 
            Edits the array of <c>Coordinate</c>s from a <c>Geometry</c>.
            </summary>
            <param name="coordinates">The coordinate array to operate on.</param>
            <param name="geometry">The point containing the coordinate list.</param>
            <returns>An edited coordinate array (which may be the same as the input).</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.SimpleGeometryPrecisionReducer.PrecisionReducerCoordinateOperation.#ctor(MapWinGeoProc.NTS.Topology.Precision.SimpleGeometryPrecisionReducer)">
            <summary>
            
            </summary>
            <param name="container"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.SimpleGeometryPrecisionReducer.PrecisionReducerCoordinateOperation.Edit(MapWindow.Interfaces.Geometries.ICoordinate[],MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="coordinates"></param>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Precision.EnhancedPrecisionOp">
            <summary>
            Provides versions of Geometry spatial functions which use
            enhanced precision techniques to reduce the likelihood of robustness problems.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.EnhancedPrecisionOp.#ctor">
            <summary>
            Only static methods!
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.EnhancedPrecisionOp.Intersection(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Computes the set-theoretic intersection of two <c>Geometry</c>s, using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry.</param>
            <returns>The Geometry representing the set-theoretic intersection of the input Geometries.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.EnhancedPrecisionOp.Union(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Computes the set-theoretic union of two <c>Geometry</c>s, using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry.</param>
            <returns>The Geometry representing the set-theoretic union of the input Geometries.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.EnhancedPrecisionOp.Difference(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Computes the set-theoretic difference of two <c>Geometry</c>s, using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry.</param>
            <returns>The Geometry representing the set-theoretic difference of the input Geometries.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.EnhancedPrecisionOp.SymDifference(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Computes the set-theoretic symmetric difference of two <c>Geometry</c>s, using enhanced precision.
            </summary>
            <param name="geom0">The first Geometry.</param>
            <param name="geom1">The second Geometry.</param>
            <returns>The Geometry representing the set-theoretic symmetric difference of the input Geometries.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.EnhancedPrecisionOp.Buffer(MapWinGeoProc.NTS.Topology.Geometries.Geometry,System.Double)">
            <summary>
            Computes the buffer of a <c>Geometry</c>, using enhanced precision.
            This method should no longer be necessary, since the buffer algorithm
            now is highly robust.
            </summary>
            <param name="geom">The first Geometry.</param>
            <param name="distance">The buffer distance.</param>
            <returns>The Geometry representing the buffer of the input Geometry.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Planargraph.Node">
            <summary>
            A node in a <c>PlanarGraph</c> is a location where 0 or more <c>Edge</c>s
            meet. A node is connected to each of its incident Edges via an outgoing
            DirectedEdge. Some clients using a <c>PlanarGraph</c> may want to
            subclass <c>Node</c> to add their own application-specific
            data and methods.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Node.getEdgesBetween(MapWinGeoProc.NTS.Topology.Planargraph.Node,MapWinGeoProc.NTS.Topology.Planargraph.Node)">
            <summary>
            Returns all Edges that connect the two nodes (which are assumed to be different).
            </summary>
            <param name="node0"></param>
            <param name="node1"></param>
            <returns></returns>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Planargraph.Node.pt">
            <summary>
            The location of this Node.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Planargraph.Node.deStar">
            <summary>
            The collection of DirectedEdges that leave this Node.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Node.#ctor(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Constructs a Node with the given location.
            </summary>
            <param name="pt"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Node.#ctor(MapWindow.Interfaces.Geometries.ICoordinate,MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdgeStar)">
            <summary>
            Constructs a Node with the given location and collection of outgoing DirectedEdges.
            </summary>
            <param name="pt"></param>
            <param name="deStar"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Node.AddOutEdge(MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge)">
            <summary>
            Adds an outgoing DirectedEdge to this Node.
            </summary>
            <param name="de"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Node.GetIndex(MapWinGeoProc.NTS.Topology.Planargraph.Edge)">
            <summary>
            Returns the zero-based index of the given Edge, after sorting in ascending order
            by angle with the positive x-axis.
            </summary>
            <param name="edge"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Node.Remove">
            <summary>
            Removes this node from its containing graph.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Node.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.Node.Coordinate">
            <summary>
            Returns the location of this Node.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.Node.OutEdges">
            <summary>
            Returns the collection of DirectedEdges that leave this Node.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.Node.Degree">
            <summary>
            Returns the number of edges around this Node.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.Node.IsRemoved">
            <summary>
            Tests whether this component has been removed from its containing graph.
            </summary>
            <value></value>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateNodeFactory">
            <summary>
            Used by the <c>NodeMap</c> in a <c>RelateNodeGraph</c> to create <c>RelateNode</c>s.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.NodeFactory">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.NodeFactory.CreateNode(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary> 
            The basic node constructor does not allow for incident edges.
            </summary>
            <param name="coord"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateNodeFactory.CreateNode(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="coord"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMerger">
            <summary>
            Sews together a set of fully noded LineStrings. Sewing stops at nodes of degree 1
            or 3 or more -- the exception is an isolated loop, which only has degree-2 nodes,
            in which case a node is simply chosen as a starting point. The direction of each
            merged LineString will be that of the majority of the LineStrings from which it
            was derived.
            Any dimension of Geometry is handled -- the constituent linework is extracted to 
            form the edges. The edges must be correctly noded; that is, they must only meet
            at their endpoints.  The LineMerger will still run on incorrectly noded input
            but will not form polygons from incorrected noded edges.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMerger.Add(System.Collections.IList)">
            <summary>
            Adds a collection of Geometries to be processed. May be called multiple times.
            Any dimension of Geometry may be added; the constituent linework will be
            extracted.
            </summary>
            <param name="geometries"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMerger.Add(MapWinGeoProc.NTS.Topology.Geometries.Geometry)">
            <summary>
            Adds a Geometry to be processed. May be called multiple times.
            Any dimension of Geometry may be added; the constituent linework will be
            extracted.
            </summary>
            <param name="geometry"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMerger.Add(MapWinGeoProc.NTS.Topology.Geometries.LineString)">
            <summary>
            
            </summary>
            <param name="lineString"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMerger.Merge">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMerger.BuildEdgeStringsForObviousStartNodes">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMerger.BuildEdgeStringsForIsolatedLoops">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMerger.BuildEdgeStringsForUnprocessedNodes">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMerger.BuildEdgeStringsForNonDegree2Nodes">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMerger.BuildEdgeStringsStartingAt(MapWinGeoProc.NTS.Topology.Planargraph.Node)">
            <summary>
            
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMerger.BuildEdgeStringStartingWith(MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMergeDirectedEdge)">
            <summary>
            
            </summary>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMerger.MergedLineStrings">
            <summary>
            Returns the LineStrings built by the merging process.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMerger.AnonymousGeometryComponentFilterImpl">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMerger.AnonymousGeometryComponentFilterImpl.#ctor(MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMerger)">
            <summary>
            
            </summary>
            <param name="container"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMerger.AnonymousGeometryComponentFilterImpl.Filter(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="component"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString">
            <summary>
            Represents a list of contiguous line segments, and supports noding the segments.
            The line segments are represented by an array of <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/>s.
            Intended to optimize the noding of contiguous segments by
            reducing the number of allocated objects.
            <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s can carry a context object, which is useful
            for preserving topological or parentage information.
            All noded substrings are initialized with the same context object.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentString.GetNodedSubstrings(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="segStrings"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentString.GetNodedSubstrings(System.Collections.IList,System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="segStrings"></param>
            <param name="resultEdgelist"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentString.#ctor(MapWindow.Interfaces.Geometries.ICoordinate[],System.Object)">
            <summary>
            Creates a new segment string from a list of vertices.
            </summary>
            <param name="pts">The vertices of the segment string.</param>
            <param name="data">The user-defined data of this segment string (may be null).</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentString.GetCoordinate(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentString.GetSegmentOctant(System.Int32)">
            <summary>
             Gets the octant of the segment starting at vertex <c>index</c>.
            </summary>
            <param name="index">
            The index of the vertex starting the segment.  
            Must not be the last index in the vertex list
            </param>
            <returns>The octant of the segment at the vertex</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentString.AddIntersections(MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector,System.Int32,System.Int32)">
            <summary>
            Adds EdgeIntersections for one or both
            intersections found for a segment of an edge to the edge intersection list.   
            </summary>
            <param name="li"></param>
            <param name="segmentIndex"></param>
            <param name="geomIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentString.AddIntersection(MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector,System.Int32,System.Int32,System.Int32)">
            <summary>
            Add an <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentNode"/> for intersection intIndex.
            An intersection that falls exactly on a vertex
            of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/> is normalized
            to use the higher of the two possible segmentIndexes.
            </summary>
            <param name="li"></param>
            <param name="segmentIndex"></param>
            <param name="geomIndex"></param>
            <param name="intIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentString.AddIntersection(MapWindow.Interfaces.Geometries.ICoordinate,System.Int32)">
            <summary>
            
            </summary>
            <param name="intPt"></param>
            <param name="segmentIndex"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.SegmentString.Data">
            <summary>
            Gets/Sets the user-defined data for this segment string.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.SegmentString.NodeList">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.SegmentString.Count">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.SegmentString.Coordinates">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.SegmentString.IsClosed">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexedLine">
            <summary>
            Supports linear referencing along a linear <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>
            using the length along the line as the index.
            Negative length values are taken as measured in the reverse direction
            from the end of the geometry.
            Out-of-range index values are handled by clamping
            them to the valid range of values.
            Non-simple lines (i.e. which loop back to cross or touch
            themselves) are supported.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexedLine.#ctor(MapWinGeoProc.NTS.Topology.Geometries.Geometry)">
            <summary>
            Constructs an object which allows a linear <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>
            to be linearly referenced using length as an index.
            </summary>
            <param name="linearGeom">The linear geometry to reference along.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexedLine.ExtractPoint(System.Double)">
            <summary>
            Computes the <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> for the point
            on the line at the given index.
            If the index is out of range the first or last point on the
            line will be returned.
            </summary>
            <param name="index">The index of the desired point.</param>
            <returns>The <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> at the given index.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexedLine.ExtractLine(System.Double,System.Double)">
            <summary>
            Computes the <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.LineString"/> for the interval
            on the line between the given indices.
            If the <paramref name="endIndex"/> lies before the <paramref name="startIndex"/>,
            the computed geometry is reversed.
            </summary>
            <param name="startIndex"></param>
            <param name="endIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexedLine.LocationOf(System.Double)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexedLine.IndexOf(MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            Computes the minimum index for a point on the line.
            If the line is not simple (i.e. loops back on itself)
            a single point may have more than one possible index.
            In this case, the smallest index is returned.
            The supplied point does not necessarily have to lie precisely
            on the line, but if it is far from the line the accuracy and
            performance of this function is not guaranteed.
            Use <see cref="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexedLine.Project(MapWinGeoProc.NTS.Topology.Geometries.Coordinate)"/> to compute a guaranteed result for points
            which may be far from the line.
            </summary>
            <param name="pt">A point on the line.</param>
            <returns>The minimum index of the point.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexedLine.IndexOfAfter(MapWinGeoProc.NTS.Topology.Geometries.Coordinate,System.Double)">
            <summary>
            Finds the index for a point on the line
            which is greater than the given index.
            If no such index exists, returns <paramref name="minIndex"/>.
            This method can be used to determine all indexes for
            a point which occurs more than once on a non-simple line.
            It can also be used to disambiguate cases where the given point lies
            slightly off the line and is equidistant from two different
            points on the line.
            The supplied point does not necessarily have to lie precisely
            on the line, but if it is far from the line the accuracy and
            performance of this function is not guaranteed.
            Use <see cref="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexedLine.Project(MapWinGeoProc.NTS.Topology.Geometries.Coordinate)"/> to compute a guaranteed result for points
            which may be far from the line.
            </summary>
            <param name="pt">A point on the line.</param>
            <param name="minIndex">The value the returned index must be greater than.</param>
            <returns>The index of the point greater than the given minimum index.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexedLine.IndicesOf(MapWinGeoProc.NTS.Topology.Geometries.Geometry)">
            <summary>
            Computes the indices for a subline of the line.
            (The subline must conform to the line; that is,
            all vertices in the subline (except possibly the first and last)
            must be vertices of the line and occcur in the same order).
            </summary>
            <param name="subLine">A subLine of the line.</param>
            <returns>A pair of indices for the start and end of the subline..</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexedLine.Project(MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            Computes the index for the closest point on the line to the given point.
            If more than one point has the closest distance the first one along the line is returned.
            (The point does not necessarily have to lie precisely on the line.)
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexedLine.IsValidIndex(System.Double)">
            <summary>
            Tests whether an index is in the valid index range for the line.
            </summary>
            <param name="index">The index to test.</param>
            <returns><c>true</c> if the index is in the valid range.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexedLine.ClampIndex(System.Double)">
            <summary>
            Computes a valid index for this line
            by clamping the given index to the valid range of index values
            </summary>
            <param name="index"></param>
            <returns>A valid index value.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexedLine.StartIndex">
            <summary>
            Returns the index of the start of the line.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexedLine.EndIndex">
            <summary>
            Returns the index of the end of the line.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryWriter">
            <summary>
            Extends the <see cref="T:System.IO.BinaryWriter"/> class to allow the writing of integers 
            and double values in the Big Endian format.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryWriter.#ctor">
            <summary>
            Initializes a new instance of the BigEndianBinaryWriter class.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryWriter.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the BigEndianBinaryWriter class 
            based on the supplied stream and using UTF-8 as the encoding for strings.
            </summary>
            <param name="output">The supplied stream.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryWriter.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Initializes a new instance of the BigEndianBinaryWriter class 
            based on the supplied stream and a specific character encoding.
            </summary>
            <param name="output">The supplied stream.</param>
            <param name="encoding">The character encoding.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryWriter.WriteIntBE(System.Int32)">
            <summary>
            Reads a 4-byte signed integer using the big-endian layout from the current stream 
            and advances the current position of the stream by two bytes.
            </summary>
            <param name="value">The four-byte signed integer to write.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryWriter.WriteDoubleBE(System.Double)">
            <summary>
            Reads a 8-byte signed integer using the big-endian layout from the current stream 
            and advances the current position of the stream by two bytes.
            </summary>
            <param name="value">The four-byte signed integer to write.</param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineInterval">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineInterval.#ctor(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="min"></param>
            <param name="max"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineInterval.#ctor(System.Double,System.Double,System.Object)">
            <summary>
            
            </summary>
            <param name="min"></param>
            <param name="max"></param>
            <param name="item"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineInterval.Min">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineInterval.Max">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineInterval.Item">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree">
            <summary>  
            A query-only R-tree created using the Sort-Tile-Recursive (STR) algorithm.
            For two-dimensional spatial data. 
            The STR packed R-tree is simple to implement and maximizes space
            utilization; that is, as many leaves as possible are filled to capacity.
            Overlap between nodes is far less than in a basic R-tree. However, once the
            tree has been built (explicitly or on the first call to #query), items may
            not be added or removed. 
            Described in: P. Rigaux, Michel Scholl and Agnes Voisard. Spatial Databases With
            Application To GIS. Morgan Kaufmann, San Francisco, 2002.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.ISpatialIndex">
            <summary> 
            The basic insertion and query operations supported by classes
            implementing spatial index algorithms.
            A spatial index typically provides a primary filter for range rectangle queries. A
            secondary filter is required to test for exact intersection. Of course, this
            secondary filter may consist of other tests besides intersection, such as
            testing other kinds of spatial relationships.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.ISpatialIndex.Insert(MapWindow.Interfaces.Geometries.IEnvelope,System.Object)">
            <summary>
            Adds a spatial item with an extent specified by the given <c>Envelope</c> to the index.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.ISpatialIndex.Query(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary> 
            Queries the index for all items whose extents intersect the given search <c>Envelope</c> 
            Note that some kinds of indexes may also return objects which do not in fact
            intersect the query envelope.
            </summary>
            <param name="searchEnv">The envelope to query for.</param>
            <returns>A list of the items found by the query.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.ISpatialIndex.Query(MapWindow.Interfaces.Geometries.IEnvelope,MapWinGeoProc.NTS.Topology.Index.IItemVisitor)">
            <summary>
            Queries the index for all items whose extents intersect the given search <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Envelope"/>,
            and applies an <see cref="T:MapWinGeoProc.NTS.Topology.Index.IItemVisitor"/> to them.
            Note that some kinds of indexes may also return objects which do not in fact
            intersect the query envelope.
            </summary>
            <param name="searchEnv">The envelope to query for.</param>
            <param name="visitor">A visitor object to apply to the items found.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.ISpatialIndex.Remove(MapWindow.Interfaces.Geometries.IEnvelope,System.Object)">
            <summary> 
            Removes a single item from the tree.
            </summary>
            <param name="itemEnv">The Envelope of the item to remove.</param>
            <param name="item">The item to remove.</param>
            <returns> <c>true</c> if the item was found.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.#ctor">
            <summary> 
            Constructs an STRtree with the default (10) node capacity.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.#ctor(System.Int32)">
            <summary> 
            Constructs an STRtree with the given maximum number of child nodes that
            a node may have.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.Avg(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.CentreX(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.CentreY(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.CreateParentBoundables(System.Collections.IList,System.Int32)">
            <summary>
            Creates the parent level for the given child level. First, orders the items
            by the x-values of the midpoints, and groups them into vertical slices.
            For each slice, orders the items by the y-values of the midpoints, and
            group them into runs of size M (the node capacity). For each run, creates
            a new (parent) node.
            </summary>
            <param name="childBoundables"></param>
            <param name="newLevel"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.CreateParentBoundablesFromVerticalSlices(System.Collections.IList[],System.Int32)">
            <summary>
            
            </summary>
            <param name="verticalSlices"></param>
            <param name="newLevel"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.CreateParentBoundablesFromVerticalSlice(System.Collections.IList,System.Int32)">
            <summary>
            
            </summary>
            <param name="childBoundables"></param>
            <param name="newLevel"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.VerticalSlices(System.Collections.IList,System.Int32)">
            <summary>
            
            </summary>
            <param name="childBoundables">Must be sorted by the x-value of the envelope midpoints.</param>
            <param name="sliceCount"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.CreateNode(System.Int32)">
            <summary>
            
            </summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.Insert(MapWindow.Interfaces.Geometries.IEnvelope,System.Object)">
            <summary>
            Inserts an item having the given bounds into the tree.
            </summary>
            <param name="itemEnv"></param>
            <param name="item"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.Query(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            Returns items whose bounds intersect the given envelope.
            </summary>
            <param name="searchEnv"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.Query(MapWindow.Interfaces.Geometries.IEnvelope,MapWinGeoProc.NTS.Topology.Index.IItemVisitor)">
            <summary>
            Returns items whose bounds intersect the given envelope.
            </summary>
            <param name="searchEnv"></param>
            <param name="visitor"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.Remove(MapWindow.Interfaces.Geometries.IEnvelope,System.Object)">
            <summary> 
            Removes a single item from the tree.
            </summary>
            <param name="itemEnv">The Envelope of the item to remove.</param>
            <param name="item">The item to remove.</param>
            <returns><c>true</c> if the item was found.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.GetComparer">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.IntersectsOp">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.Count">
            <summary> 
            Returns the number of items in the tree.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.Depth">
            <summary>
            Returns the number of items in the tree.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.AnonymousXComparerImpl">
            <summary>
            
            </summary>        
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.AnonymousXComparerImpl.#ctor(MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree)">
            <summary>
            
            </summary>
            <param name="container"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.AnonymousXComparerImpl.Compare(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.AnonymousYComparerImpl">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.AnonymousYComparerImpl.#ctor(MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree)">
            <summary>
            
            </summary>
            <param name="container"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.AnonymousYComparerImpl.Compare(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.AnonymousAbstractNodeImpl">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.AnonymousAbstractNodeImpl.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="nodeCapacity"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.AnonymousAbstractNodeImpl.ComputeBounds">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.AnonymousIntersectsOpImpl">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.AnonymousIntersectsOpImpl.#ctor(MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree)">
            <summary>
            
            </summary>
            <param name="container"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.STRtree.AnonymousIntersectsOpImpl.Intersects(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="aBounds"></param>
            <param name="bBounds"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Quadtree.Key">
            <summary> 
            A Key is a unique identifier for a node in a quadtree.
            It contains a lower-left point and a level number. The level number
            is the power of two for the size of the node envelope.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Key.ComputeQuadLevel(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            
            </summary>
            <param name="env"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Key.#ctor(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            
            </summary>
            <param name="itemEnv"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Key.ComputeKey(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            Return a square envelope containing the argument envelope,
            whose extent is a power of two and which is based at a power of 2.
            </summary>
            <param name="itemEnv"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Key.ComputeKey(System.Int32,MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            
            </summary>
            <param name="level"></param>
            <param name="itemEnv"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Quadtree.Key.Point">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Quadtree.Key.Level">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Quadtree.Key.Envelope">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Quadtree.Key.Centre">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.Location">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Location.ToLocationSymbol(MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            Converts the location value to a location symbol, for example, <c>EXTERIOR => 'e'</c>.
            </summary>
            <param name="locationValue"></param>
            <returns>Either 'e', 'b', 'i' or '-'.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory">
            <summary>
            Supplies a set of utility methods for building Geometry objects from lists
            of Coordinates.
            </summary>            
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.m_Default">
            <summary>
            A predefined <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory"/> with <see cref="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.PrecisionModel"/> <c> == </c> <see cref="F:MapWindow.Interfaces.Geometries.PrecisionModels.Floating"/>.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.m_Floating">
            <summary>
            A predefined GeometryFactory with PrecisionModel 
            PrecisionModels.Floating
            </summary>
            <remarks>A shortcut for GeometryFactory.Default</remarks>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.m_FloatingSingle">
            <summary>
            A predefined <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory"/> with <see cref="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.PrecisionModel"/> 
            <c> == </c> <see cref="F:MapWindow.Interfaces.Geometries.PrecisionModels.FloatingSingle"/>.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.m_Fixed">
            <summary>
            A predefined <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory"/> with <see cref="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.PrecisionModel"/> 
            <c> == </c> <see cref="F:MapWindow.Interfaces.Geometries.PrecisionModels.Fixed"/>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.CreatePointFromInternalCoord(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="coord"></param>
            <param name="exemplar"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.#ctor(MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel,System.Int32,MapWindow.Interfaces.Geometries.ICoordinateSequenceFactory)">
            <summary>
            Constructs a GeometryFactory that generates Geometries having the given
            PrecisionModel, spatial-reference ID, and CoordinateSequence implementation.
            </summary>        
            <param name="precisionModel"></param>
            <param name="SRID"></param>
            <param name="coordinateSequenceFactory"></param>       
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.#ctor(MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            Constructs a GeometryFactory object from any valid IGeometryFactory interface
            </summary>
            <param name="gf"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.#ctor(MapWindow.Interfaces.Geometries.IGeometryFactory,MapWindow.Interfaces.Geometries.ICoordinateSequenceFactory)">
            <summary>
            Constructs a GeometryFactory pertaining to a specific coordinateSequenceFactory
            using any valid IGeometryFactory and ICoordinateSequenceFactory interface
            </summary>
            <param name="gf">An IGeometryFactory Interface</param>
            <param name="coordinateSequenceFactory">An ICoordianteSequenceFactory interface</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.#ctor(MapWindow.Interfaces.Geometries.ICoordinateSequenceFactory)">
            <summary>
            Constructs a GeometryFactory that generates Geometries having the given
            CoordinateSequence implementation, a double-precision floating PrecisionModel and a
            spatial-reference ID of 0.
            </summary>
            <param name="coordinateSequenceFactory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.#ctor(MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel)">
            <summary>
            Constructs a GeometryFactory that generates Geometries having the given
            {PrecisionModel} and the default CoordinateSequence
            implementation.
            </summary>
            <param name="precisionModel">The PrecisionModel to use.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.#ctor(MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel,System.Int32)">
            <summary>
            Constructs a GeometryFactory that generates Geometries having the given
            <c>PrecisionModel</c> and spatial-reference ID, and the default CoordinateSequence
            implementation.
            </summary>
            <param name="precisionModel">The PrecisionModel to use.</param>
            <param name="SRID">The SRID to use.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.#ctor">
            <summary>
            Constructs a GeometryFactory that generates Geometries having a floating
            PrecisionModel and a spatial-reference ID of 0.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.ToPointArray(System.Collections.IList)">
            <summary>
            Converts the <c>List</c> to an array.
            </summary>
            <param name="points">The <c>List</c> of Points to convert.</param>
            <returns>The <c>List</c> in array format.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.ToGeometryArray(System.Collections.IList)">
            <summary>
            Converts the <c>List</c> to an array.
            </summary>
            <param name="geometries">The list of <c>Geometry's</c> to convert.</param>
            <returns>The <c>List</c> in array format.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.ToLinearRingArray(System.Collections.IList)">
            <summary>
            Converts the <c>List</c> to an array.
            </summary>
            <param name="linearRings">The <c>List</c> of LinearRings to convert.</param>
            <returns>The <c>List</c> in array format.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.ToLineStringArray(System.Collections.IList)">
            <summary>
            Converts the <c>List</c> to an array.
            </summary>
            <param name="lineStrings">The <c>List</c> of LineStrings to convert.</param>
            <returns>The <c>List</c> in array format.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.ToPolygonArray(System.Collections.IList)">
            <summary>
            Converts the <c>List</c> to an array.
            </summary>
            <param name="polygons">The <c>List</c> of Polygons to convert.</param>
            <returns>The <c>List</c> in array format.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.ToMultiPolygonArray(System.Collections.IList)">
            <summary>
            Converts the <c>List</c> to an array.
            </summary>
            <param name="multiPolygons">The <c>List</c> of MultiPolygons to convert.</param>
            <returns>The <c>List</c> in array format.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.ToMultiLineStringArray(System.Collections.IList)">
            <summary>
            Converts the <c>List</c> to an array.
            </summary>
            <param name="multiLineStrings">The <c>List</c> of MultiLineStrings to convert.</param>
            <returns>The <c>List</c> in array format.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.ToMultiPointArray(System.Collections.IList)">
            <summary>
            Converts the <c>List</c> to an array.
            </summary>
            <param name="multiPoints">The <c>List</c> of MultiPoints to convert.</param>
            <returns>The <c>List</c> in array format.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.ToGeometry(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            If the <c>Envelope</c> is a null <c>Envelope</c>, returns an
            empty <c>Point</c>. If the <c>Envelope</c> is a point, returns
            a non-empty <c>Point</c>. If the <c>Envelope</c> is a
            rectangle, returns a <c>Polygon</c> whose points are (minx, miny),
            (maxx, miny), (maxx, maxy), (minx, maxy), (minx, miny).
            </summary>
            <param name="envelope">The <c>Envelope</c> to convert to a <c>Geometry</c>.</param>       
            <returns>
            An empty <c>Point</c> (for null <c>Envelope</c>
            s), a <c>Point</c> (when min x = max x and min y = max y) or a
            <c>Polygon</c> (in all other cases)
            throws a <c>TopologyException</c> if <c>coordinates</c>
            is not a closed linestring, that is, if the first and last coordinates
            are not equal.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.CreatePoint(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Creates a Point using the given Coordinate; a null Coordinate will create
            an empty Geometry.
            </summary>
            <param name="coordinate"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.CreatePoint(MapWindow.Interfaces.Geometries.ICoordinateSequence)">
            <summary>
            Creates a <c>Point</c> using the given <c>CoordinateSequence</c>; a null or empty
            CoordinateSequence will create an empty Point.
            </summary>
            <param name="coordinates"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.CreateMultiLineString(MapWindow.Interfaces.Geometries.ILineStringBase[])">
            <summary>
            Creates a <c>MultiLineString</c> using the given <c>LineStrings</c>; a null or empty
            array will create an empty MultiLineString.
            </summary>
            <param name="lineStrings">LineStrings, each of which may be empty but not null-</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.CreateGeometryCollection(MapWindow.Interfaces.Geometries.IGeometry[])">
            <summary>
            Creates a <c>GeometryCollection</c> using the given <c>Geometries</c>; a null or empty
            array will create an empty GeometryCollection.
            </summary>
            <param name="geometries">Geometries, each of which may be empty but not null.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.CreateMultiPolygon(MapWindow.Interfaces.Geometries.IPolygon[])">
            <summary>
            Creates a <c>MultiPolygon</c> using the given <c>Polygons</c>; a null or empty array
            will create an empty Polygon. The polygons must conform to the
            assertions specified in the <see href="http://www.opengis.org/techno/specs.htm"/> OpenGIS Simple Features
            Specification for SQL.
            </summary>
            <param name="polygons">Polygons, each of which may be empty but not null.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.CreateLinearRing(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Creates a <c>LinearRing</c> using the given <c>Coordinates</c>; a null or empty array will
            create an empty LinearRing. The points must form a closed and simple
            linestring. Consecutive points must not be equal.
            </summary>
            <param name="coordinates">An array without null elements, or an empty array, or null.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.CreateLinearRing(MapWindow.Interfaces.Geometries.ICoordinateSequence)">
            <summary> 
            Creates a <c>LinearRing</c> using the given <c>CoordinateSequence</c>; a null or empty CoordinateSequence will
            create an empty LinearRing. The points must form a closed and simple
            linestring. Consecutive points must not be equal.
            </summary>
            <param name="coordinates">A CoordinateSequence possibly empty, or null.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.CreateMultiPoint(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary> 
            Creates a MultiPoint using the given Coordinates; a null or empty array will create an empty MultiPoint.
            </summary>
            <param name="coordinates">An array without null elements, or an empty array, or null.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.CreateMultiPoint(MapWindow.Interfaces.Geometries.ICoordinateSequence)">
            <summary> 
            Creates a MultiPoint using the given CoordinateSequence; a null or empty CoordinateSequence will
            create an empty MultiPoint.
            </summary>
            <param name="coordinates">A CoordinateSequence possibly empty, or null.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.CreatePolygon(MapWindow.Interfaces.Geometries.ILinearRing,MapWindow.Interfaces.Geometries.ILinearRing[])">
            <summary> 
            Constructs a <c>Polygon</c> with the given exterior boundary and
            interior boundaries.
            </summary>
            <param name="shell">
            The outer boundary of the new <c>Polygon</c>, or
            <c>null</c> or an empty <c>LinearRing</c> if
            the empty point is to be created.
            </param>
            <param name="holes">
            The inner boundaries of the new <c>Polygon</c>, or
            <c>null</c> or empty <c>LinearRing</c> s if
            the empty point is to be created.        
            </param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.BuildGeometry(System.Collections.IList)">
            <summary>  
            Build an appropriate <c>Geometry</c>, <c>MultiGeometry</c>, or
            <c>GeometryCollection</c> to contain the <c>Geometry</c>s in
            it.
            <example>
             If <c>geomList</c> contains a single <c>Polygon</c>,
            the <c>Polygon</c> is returned.
             If <c>geomList</c> contains several <c>Polygon</c>s, a
            <c>MultiPolygon</c> is returned.
             If <c>geomList</c> contains some <c>Polygon</c>s and
            some <c>LineString</c>s, a <c>GeometryCollection</c> is
            returned.
             If <c>geomList</c> is empty, an empty <c>GeometryCollection</c>
            is returned.
            Note that this method does not "flatten" Geometries in the input, and hence if
            any MultiGeometries are contained in the input a GeometryCollection containing
            them will be returned.
            </example>
            </summary>
            <param name="geomList">The <c>Geometry</c>s to combine.</param>
            <returns>A <c>Geometry</c> of the "smallest", "most type-specific" class that can contain the elements of <c>geomList</c>.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.CreateLineString(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary> 
            Creates a LineString using the given Coordinates; a null or empty array will
            create an empty LineString. Consecutive points must not be equal.
            </summary>
            <param name="coordinates">An array without null elements, or an empty array, or null.</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.CreateLineString(MapWindow.Interfaces.Geometries.ICoordinateSequence)">
            <summary>
            Creates a LineString using the given CoordinateSequence; a null or empty CoordinateSequence will
            create an empty LineString. Consecutive points must not be equal.
            </summary>
            <param name="coordinates">A CoordinateSequence possibly empty, or null.</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.CreateGeometry(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="g"></param>
            <returns>
            A clone of g based on a CoordinateSequence created by this
            GeometryFactory's CoordinateSequenceFactory.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.GetDefaultCoordinateSequenceFactory">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.Default">
            <summary>
            Default IGeometryFactory
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.Floating">
            <summary>
            An IGeometryFactory that can change
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.FloatingSingle">
            <summary>
            A dynamic geometry factory set up for the single datatype
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.Fixed">
            <summary>
            An IGeometryFactory
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.PrecisionModel">
            <summary>
            Returns the PrecisionModel that Geometries created by this factory
            will be associated with.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.CoordinateSequenceFactory">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory.SRID">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector.IsAdjacentSegments(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="i1"></param>
            <param name="i2"></param>
            <returns></returns>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector.numTests">
            <summary>
            Testing only.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector.#ctor(MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="li"></param>
            <param name="includeProper"></param>
            <param name="recordIsolated"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector.SetBoundaryNodes(System.Collections.ICollection,System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="bdyNodes0"></param>
            <param name="bdyNodes1"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector.IsTrivialIntersection(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge,System.Int32,MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge,System.Int32)">
            <summary>
            A trivial intersection is an apparent self-intersection which in fact
            is simply the point shared by adjacent line segments.
            Note that closed edges require a special check for the point shared by the beginning
            and end segments.
            </summary>
            <param name="e0"></param>
            <param name="segIndex0"></param>
            <param name="e1"></param>
            <param name="segIndex1"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector.AddIntersections(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge,System.Int32,MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge,System.Int32)">
            <summary> 
            This method is called by clients of the EdgeIntersector class to test for and add
            intersections for two segments of the edges being intersected.
            Note that clients (such as MonotoneChainEdges) may choose not to intersect
            certain pairs of segments for efficiency reasons.
            </summary>
            <param name="e0"></param>
            <param name="segIndex0"></param>
            <param name="e1"></param>
            <param name="segIndex1"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector.IsBoundaryPoint(MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector,System.Collections.ICollection[])">
            <summary>
            
            </summary>
            <param name="li"></param>
            <param name="bdyNodes"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector.IsBoundaryPoint(MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector,System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="li"></param>
            <param name="bdyNodes"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector.ProperIntersectionPoint">
            <returns> 
            The proper intersection point, or <c>null</c> if none was found.
            </returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector.HasIntersection">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector.HasProperIntersection">
            <summary>
            A proper intersection is an intersection which is interior to at least two
            line segments.  Note that a proper intersection is not necessarily
            in the interior of the entire Geometry, since another edge may have
            an endpoint equal to the intersection, which according to SFS semantics
            can result in the point being on the Boundary of the Geometry.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector.HasProperInteriorIntersection">
            <summary> 
            A proper interior intersection is a proper intersection which is not
            contained in the set of boundary nodes set for this SegmentIntersector.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType">
            <summary>
            A vertical datum of geoid model derived heights, also called GPS-derived heights.
            These heights are approximations of orthometric heights (H), constructed from the
            ellipsoidal heights (h) by the use of the given geoid undulation model (N) through
            the equation: H=h-N.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType.HD_Min">
            <summary>
            Lowest possible value for horizontal datum types
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType.HD_Other">
            <summary>
            Unspecified horizontal datum type. Horizontal datums with this type should never
            supply a conversion to WGS84 using Bursa Wolf parameters.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType.HD_Classic">
            <summary>
            These datums, such as ED50, NAD27 and NAD83, have been designed to support
            horizontal positions on the ellipsoid as opposed to positions in 3-D space. These datums were designed mainly to support a horizontal component of a position in a domain of limited extent, such as a country, a region or a continent.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType.HD_Geocentric">
            <summary>
            A geocentric datum is a "satellite age" modern geodetic datum mainly of global
            extent, such as WGS84 (used in GPS), PZ90 (used in GLONASS) and ITRF. These
            datums were designed to support both a horizontal component of position and 
            a vertical component of position (through ellipsoidal heights). The regional
            realizations of ITRF, such as ETRF, are also included in this category.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType.HD_Max">
            <summary>
            Highest possible value for horizontal datum types.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType.VD_Min">
            <summary>
            Lowest possible value for vertical datum types.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType.VD_Other">
            <summary>
            Unspecified vertical datum type.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType.VD_Orthometric">
            <summary>
            A vertical datum for orthometric heights that are measured along the plumb line.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType.VD_Ellipsoidal">
            <summary>
            A vertical datum for ellipsoidal heights that are measured along the normal to
            the ellipsoid used in the definition of horizontal datum.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType.VD_AltitudeBarometric">
            <summary>
            The vertical datum of altitudes or heights in the atmosphere. These are
            approximations of orthometric heights obtained with the help of a barometer or
            a barometric altimeter. These values are usually expressed in one of the
            following units: meters, feet, millibars (used to measure pressure levels), or
            theta value (units used to measure geopotential height).
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType.VD_Normal">
            <summary>
            A normal height system.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType.VD_GeoidModelDerived">
            <summary>
            A vertical datum of geoid model derived heights, also called GPS-derived heights.
            These heights are approximations of orthometric heights (H), constructed from the
            ellipsoidal heights (h) by the use of the given geoid undulation model (N) 
            through the equation: H=h-N.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType.VD_Depth">
            <summary>
            This attribute is used to support the set of datums generated for hydrographic
            engineering projects where depth measurements below sea level are needed. It is
            often called a hydrographic or a marine datum. Depths are measured in the 
            direction perpendicular (approximately) to the actual equipotential surfaces of
            the earth's gravity field, using such procedures as echo-sounding.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType.VD_Max">
            <summary>
            Highest possible value for vertical datum types.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType.LD_Min">
            <summary>
            Lowest possible value for local datum types.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType.LD_Max">
            <summary>
            Highest possible value for local datum types.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory">
            <summary>
            Builds up complex objects from simpler objects or values.
            </summary>
            <remarks>
            <para>ICoordinateSystemFactory allows applications to make coordinate systems that 
            cannot be created by a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemAuthorityFactory"/>. This factory is very 
            flexible, whereas the authority factory is easier to use.</para>
            <para>So <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystemAuthorityFactory"/>can be used to make 'standard' coordinate 
            systems, and <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory"/> can be used to make 'special' 
            coordinate systems.</para>
            <para>For example, the EPSG authority has codes for USA state plane coordinate systems 
            using the NAD83 datum, but these coordinate systems always use meters. EPSG does not 
            have codes for NAD83 state plane coordinate systems that use feet units. This factory
            lets an application create such a hybrid coordinate system.</para>
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory.CreateFromXml(System.String)">
            <summary>
            Creates a coordinate system object from an XML string.
            </summary>
            <param name="xml">XML representation for the spatial reference</param>
            <returns>The resulting spatial reference object</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory.CreateFromWkt(System.String)">
            <summary>
            Creates a spatial reference object given its Well-known text representation.
            The output object may be either a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeographicCoordinateSystem"/> or
            a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IProjectedCoordinateSystem"/>.
            </summary>
            <param name="WKT">The Well-known text representation for the spatial reference</param>
            <returns>The resulting spatial reference object</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory.CreateCompoundCoordinateSystem(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystem,MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystem)">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICompoundCoordinateSystem"/> [NOT IMPLEMENTED].
            </summary>
            <param name="name">Name of compound coordinate system.</param>
            <param name="head">Head coordinate system</param>
            <param name="tail">Tail coordinate system</param>
            <returns>Compound coordinate system</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory.CreateFittedCoordinateSystem(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystem,System.String,System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo})">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IFittedCoordinateSystem"/>.
            </summary>
            <remarks>The units of the axes in the fitted coordinate system will be 
            inferred from the units of the base coordinate system. If the affine map
            performs a rotation, then any mixed axes must have identical units. For
            example, a (lat_deg,lon_deg,height_feet) system can be rotated in the 
            (lat,lon) plane, since both affected axes are in degrees. But you 
            should not rotate this coordinate system in any other plane.</remarks>
            <param name="name">Name of coordinate system</param>
            <param name="baseCoordinateSystem">Base coordinate system</param>
            <param name="toBaseWkt"></param>
            <param name="arAxes"></param>
            <returns>Fitted coordinate system</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory.CreateLocalCoordinateSystem(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.ILocalDatum,MapWinGeoProc.NTS.Topology.CoordinateSystems.IUnit,System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo})">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ILocalCoordinateSystem">local coordinate system</see>.
            </summary>
            <remarks>
             The dimension of the local coordinate system is determined by the size of 
            the axis array. All the axes will have the same units. If you want to make 
            a coordinate system with mixed units, then you can make a compound 
            coordinate system from different local coordinate systems.
            </remarks>
            <param name="name">Name of local coordinate system</param>
            <param name="datum">Local datum</param>
            <param name="unit">Units</param>
            <param name="axes">Axis info</param>
            <returns>Local coordinate system</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory.CreateEllipsoid(System.String,System.Double,System.Double,MapWinGeoProc.NTS.Topology.CoordinateSystems.ILinearUnit)">
            <summary>
            Creates an <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Ellipsoid"/> from radius values.
            </summary>
            <seealso cref="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory.CreateFlattenedSphere(System.String,System.Double,System.Double,MapWinGeoProc.NTS.Topology.CoordinateSystems.ILinearUnit)"/>
            <param name="name">Name of ellipsoid</param>
            <param name="semiMajorAxis"></param>
            <param name="semiMinorAxis"></param>
            <param name="linearUnit"></param>
            <returns>Ellipsoid</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory.CreateFlattenedSphere(System.String,System.Double,System.Double,MapWinGeoProc.NTS.Topology.CoordinateSystems.ILinearUnit)">
            <summary>
            Creates an <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Ellipsoid"/> from an major radius, and inverse flattening.
            </summary>
            <seealso cref="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory.CreateEllipsoid(System.String,System.Double,System.Double,MapWinGeoProc.NTS.Topology.CoordinateSystems.ILinearUnit)"/>
            <param name="name">Name of ellipsoid</param>
            <param name="semiMajorAxis">Semi major-axis</param>
            <param name="inverseFlattening">Inverse flattening</param>
            <param name="linearUnit">Linear unit</param>
            <returns>Ellipsoid</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory.CreateProjectedCoordinateSystem(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeographicCoordinateSystem,MapWinGeoProc.NTS.Topology.CoordinateSystems.IProjection,MapWinGeoProc.NTS.Topology.CoordinateSystems.ILinearUnit,MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo,MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo)">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectedCoordinateSystem"/> using a projection object.
            </summary>
            <param name="name">Name of projected coordinate system</param>
            <param name="gcs">Geographic coordinate system</param>
            <param name="projection">Projection</param>
            <param name="linearUnit">Linear unit</param>
            <param name="axis0">Primary axis</param>
            <param name="axis1">Secondary axis</param>
            <returns>Projected coordinate system</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory.CreateProjection(System.String,System.String,System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.CoordinateSystems.ProjectionParameter})">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projection"/>.
            </summary>
            <param name="name">Name of projection</param>
            <param name="wktProjectionClass">Projection class</param>
            <param name="parameters">Projection parameters</param>
            <returns>Projection</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory.CreateHorizontalDatum(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType,MapWinGeoProc.NTS.Topology.CoordinateSystems.IEllipsoid,MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo)">
            <summary>
            Creates <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.HorizontalDatum"/> from ellipsoid and Bursa-World parameters.
            </summary>
            <remarks>
            Since this method contains a set of Bursa-Wolf parameters, the created 
            datum will always have a relationship to WGS84. If you wish to create a
            horizontal datum that has no relationship with WGS84, then you can 
            either specify a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType">horizontalDatumType</see> of <see cref="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType.HD_Other"/>, or create it via WKT.
            </remarks>
            <param name="name">Name of ellipsoid</param>
            <param name="datumType">Type of datum</param>
            <param name="ellipsoid">Ellipsoid</param>
            <param name="toWgs84">Wgs84 conversion parameters</param>
            <returns>Horizontal datum</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory.CreatePrimeMeridian(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.IAngularUnit,System.Double)">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.PrimeMeridian"/>, relative to Greenwich.
            </summary>
            <param name="name">Name of prime meridian</param>
            <param name="angularUnit">Angular unit</param>
            <param name="longitude">Longitude</param>
            <returns>Prime meridian</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory.CreateGeographicCoordinateSystem(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.IAngularUnit,MapWinGeoProc.NTS.Topology.CoordinateSystems.IHorizontalDatum,MapWinGeoProc.NTS.Topology.CoordinateSystems.IPrimeMeridian,MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo,MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo)">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeographicCoordinateSystem"/>, which could be Lat/Lon or Lon/Lat.
            </summary>
            <param name="name">Name of geographical coordinate system</param>
            <param name="angularUnit">Angular units</param>
            <param name="datum">Horizontal datum</param>
            <param name="primeMeridian">Prime meridian</param>
            <param name="axis0">First axis</param>
            <param name="axis1">Second axis</param>
            <returns>Geographic coordinate system</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory.CreateLocalDatum(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType)">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ILocalDatum"/>.
            </summary>
            <param name="name">Name of datum</param>
            <param name="datumType">Datum type</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory.CreateVerticalDatum(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.DatumType)">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IVerticalDatum"/> from an enumerated type value.
            </summary>
            <param name="name">Name of datum</param>
            <param name="datumType">Type of datum</param>
            <returns>Vertical datum</returns>	
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory.CreateVerticalCoordinateSystem(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.IVerticalDatum,MapWinGeoProc.NTS.Topology.CoordinateSystems.ILinearUnit,MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo)">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IVerticalCoordinateSystem"/> from a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IVerticalDatum">datum</see> and <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.LinearUnit">linear units</see>.
            </summary>
            <param name="name">Name of vertical coordinate system</param>
            <param name="datum">Vertical datum</param>
            <param name="verticalUnit">Unit</param>
            <param name="axis">Axis info</param>
            <returns>Vertical coordinate system</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory.CreateGeocentricCoordinateSystem(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.IHorizontalDatum,MapWinGeoProc.NTS.Topology.CoordinateSystems.ILinearUnit,MapWinGeoProc.NTS.Topology.CoordinateSystems.IPrimeMeridian)">
            <summary>
            Creates a <see cref="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.CoordinateSystemFactory.CreateGeocentricCoordinateSystem(System.String,MapWinGeoProc.NTS.Topology.CoordinateSystems.IHorizontalDatum,MapWinGeoProc.NTS.Topology.CoordinateSystems.ILinearUnit,MapWinGeoProc.NTS.Topology.CoordinateSystems.IPrimeMeridian)"/> from a <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IHorizontalDatum">datum</see>, 
            <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ILinearUnit">linear unit</see> and <see cref="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IPrimeMeridian"/>.
            </summary>
            <param name="name">Name of geocentric coordinate system</param>
            <param name="datum">Horizontal datum</param>
            <param name="linearUnit">Linear unit</param>
            <param name="primeMeridian">Prime meridian</param>
            <returns>Geocentric Coordinate System</returns>
        </member>
        <member name="T:MapWinGeoProc.Utils">
             <summary>
             Utils provides a collection of methods ranging from file conversion to finding a point on a shape.
             </summary>
            
        </member>
        <member name="M:MapWinGeoProc.Utils.deg2rad(System.Double)">
            <summary>
            Converts degrees to radians.
            </summary>
            <param name="deg"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Utils.PointOnLine(MapWinGIS.Point@,MapWinGIS.Shape@,System.Int32@)">
            <summary>
            Finds if a point lies on a line or not.
            </summary>
            <param name="point">The test point.</param>
            <param name="line">The line shape.</param>
            <param name="ptLocation">The index to where the point would be located
            on the line if it were to be added to the line.</param>
            <returns>False if the point is not on the line or an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Utils.AddPointToShape(MapWinGIS.Point@,MapWinGIS.Shape@,System.Int32)">
            <summary>
            Not Implemented
            Adds a given point to the line or polygon at the specified location.
            </summary>
            <param name="point">The point to be added.</param>
            <param name="shape">The line or polygon shape that will gain a new point.</param>
            <param name="ptLocation">The location in the polygon or line where the point should be added.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Utils.RemovePointFromShape(System.Int32,MapWinGIS.Shape@)">
            <summary>
            Not Implemented
            Removes a point at ptLocation from the line or polygon shape.
            </summary>
            <param name="ptLocation">The location of the point on the line or polygon.</param>
            <param name="shape">The line or polygon shape that will lose a point.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Utils.FindNearestPointAndLoc(MapWinGIS.Point@,MapWinGIS.Shape@,MapWinGIS.Point@,System.Int32@,System.Double@)">
            <summary>
            Finds where the test point is closest to on a line or polygon shape and 
            returns the corresonding point and location and distance.
            </summary>
            <param name="testPoint">The point to be checked for.</param>
            <param name="shape">The shape to find the nearest point on.</param>
            <param name="resultPoint">The resulting point that lies on the shape.</param>
            <param name="ptLocation">The location of where the result point should be on the shape.</param>
            <param name="ptDistance">The distance from the test point to the closest point.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Utils.FindNearestPointAndLocOld(MapWinGIS.Point@,MapWinGIS.Shape@,MapWinGIS.Point@,System.Int32@,System.Double@)">
            <summary>
            Finds where the test point is closest to on a line or polygon shape and 
            returns the corresonding point and location and distance.
            </summary>
            <param name="testPoint">The point to be checked for.</param>
            <param name="shape">The shape to find the nearest point on.</param>
            <param name="resultPoint">The resulting point that lies on the shape.</param>
            <param name="ptLocation">The location of where the result point should be on the shape.</param>
            <param name="ptDistance">The distance from the test point to the closest point.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Utils.SnapPointsToLines(System.String,System.String,System.Double,System.Double,System.String,System.Boolean,MapWinGIS.ICallback)">
            <summary>
            A function which snaps all points in a given shapefile path within a given threshold to lines in a polyline shapefile, tossing out any points which don't fall within the threshold
            </summary>
            <param name="PointsPath">Point shapefile path</param>
            <param name="LinesPath">Line shapefile path</param>
            <param name="SnapThreshold">Threshold to snap to</param>
            <param name="ExclusionThreshold">Threshold of minimum distance between two points in the snap results grid. Suggested value of half cell size if used in delineation to avoid two outlets in the same grid cell.</param>
            <param name="SnapResultPath">Resulting point shapefile of points that were within thresh and were snapped</param>
            <param name="Callback">ICallback object for status and progress</param>
            <param name="CopyAttributes">True if copying attributes over</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Utils.SnapPointsToLines(System.String,System.String,System.Double,System.String,System.Boolean,MapWinGIS.ICallback)">
            <summary>
            A function which snaps all points in a given shapefile path within a given threshold to lines in a polyline shapefile, tossing out any points which don't fall within the threshold
            </summary>
            <param name="PointsPath">Point shapefile path</param>
            <param name="LinesPath">Line shapefile path</param>
            <param name="SnapThreshold">Threshold to snap to</param>
            <param name="SnapResultPath">Resulting point shapefile of points that were within thresh and were snapped</param>
            <param name="Callback">ICallback object for status and progress</param>
            <param name="CopyAttributes">True if copying attributes over</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Utils.ExtractSelectedPoints(System.String,System.String,System.Collections.ArrayList,MapWinGIS.ICallback)">
            <summary>
            Function to extract the points from a given shapefile as found in an arraylist of point indexes
            </summary>
            <param name="PointShapePath"></param>
            <param name="ExtactedPointShapeResultPath"></param>
            <param name="SelectedIndexesList"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Utils.GridToShapefile(System.String@,System.String@)">
            <summary>
            Not Implemented, use MapWinGIS::Utils::GridToShapefile
            Converts a grid to a shapefile.
            </summary>
            <param name="gridPath">Full path to the grid.</param>
            <param name="resultSFPath">Full path to where the resulting shapefile will be saved.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Utils.PolylineToPoints(System.String,System.String)">
            <summary>
            Function to convert a polyline shapefile into a points shapefile by putting all the vertices as points in the output file
            </summary>
            <param name="PolylinePath">The polyline shapefile</param>
            <param name="PointsPath">The result point shapefile</param>
        </member>
        <member name="M:MapWinGeoProc.Utils.ShapefileToGrid(System.String,System.String,MapWinGIS.GridFileType,MapWinGIS.GridDataType,System.String,System.Double,MapWinGIS.ICallback)">
            <summary>
            Convert a shapefile to grid. The resulting grid has the same extents as the shapefile.
            The number of resulting grid columns and rows is calculated from the shapefile extents
            and the specified cell size.
            </summary>
            <param name="sfPath">The full path to the shapefile</param>
            <param name="gridPath">The full path to the result grid file</param>
            <param name="grFileType">Grid file type (can be Ascii, Binary or GeoTiff)</param>
            <param name="grDataType">Grid data type (Short, Long, Float or Double) .
            Please note that only 'Float' data type can be used if the file type is 'Binary'.</param>
            <param name="sfValueField">the name of the field in shapefile attribute
            table that contains data</param>
            <param name="gridCellSize">Cell (pixel) size of the resulting grid in shapefile projection
            map units</param>
            <param name="cback">(optional) reports progress and error messages. Set this
            parameter to NULL if not needed</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Utils.ShapefileToGrid(System.String,System.String,MapWinGIS.GridFileType,MapWinGIS.GridDataType,System.String,System.Double,MapWinGIS.Extents,MapWinGIS.ICallback)">
            <summary>
            Convert a shapefile to grid. The number of grid rows and columns
            is calculated from the specified Cellsize and gridExtents parameters.
            </summary>
            <param name="sfPath">The full path to the shapefile</param>
            <param name="resultGridPath">The full path to the result grid file</param>
            <param name="gridFileType">Grid file type (can be Ascii, Binary or GeoTiff)</param>
            <param name="gridDataType">Grid data type (Short, Long, Float or Double)</param>
            <param name="sfValueField">the name of the shapefile field that contains data</param>
            <param name="gridCellSize">Cell size of the grid (in shapefile map units)</param>
            <param name="gridExtents">Extents (min. and max. x and y) of the new grid</param>
            <param name="cback">(optional) reports progress and error messages. Set this
            parameter to NULL if not needed</param> 
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Utils.ShapefileToGrid(System.String,System.String,MapWinGIS.GridFileType,MapWinGIS.GridDataType,System.String,MapWinGIS.GridHeader,MapWinGIS.ICallback)">
            <summary>Converts a shapefile to grid. The resulting grid extents and
            cell size are specified by the GridHeader object.
            </summary>
            <param name="SfPath">the name of the shapefile</param>
            <param name="GridPath">the name of the new grid. The full path
            should be specified. The file extension should be .asc, .bgd or .tiff</param>
            <param name="GrdFileType">file type of the new grid (should be set to 
            Ascii, Binary or GeoTiff)</param>
            <param name="GrdDataType">data format of the new grid</param>
            <param name="Fldname">the name of the field that contains data</param>
            <param name="GrdHd">contains information about dimension 
            (cell size and extents) of the new grid</param>
            <param name="cback">(optional) reports progress and error messages. Set this
            parameter to NULL if not needed</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Utils.PointInPolygon(MapWinGIS.Shape@,MapWinGIS.Point@)">
            <summary>
            Determines if a point lies within a polygon.
            </summary>
            <param name="polygon">The polygon shape.</param>
            <param name="testPoint">The point to be tested.</param>
            <returns>True if the point is inside, false otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Utils.IsLeft(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Tests if a point is left|on|right of an infinite line.
             See: the January 2001 Algorithm "Area of 2D and 3D Triangles and Polygons"
             at http://softsurfer.com/Archive/algorithm_0101/algorithm_0101.htm
            </summary>
            <param name="x0">X value for point 0 of the line.</param>
            <param name="y0">Y value for point 0 of the line.</param>
            <param name="x1">X value for point 1 of the line.</param>
            <param name="y1">Y value for point 1 of the line.</param>
            <param name="x2">X value of the point being tested.</param>
            <param name="y2">Y value of the point being tested.</param>
            <returns>A value > 0 if the point is left of the line.
            		 A value = 0 if the point is on the line.
            		 A value less than 0 if the point right of the line.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.Utils.wn_PnPoly(MapWinGeoProc.Globals.Vertex[]@,System.Double,System.Double)">
            <summary>
            Winding number test for point in polygon
            </summary>
            <param name="V">Array of vertices in the polygon.</param>
            <param name="x">X value of point being tested.</param>
            <param name="y">Y value of point being tested.</param>
            <returns>The winding number (=0 only if pt is outside poly)</returns>
        </member>
        <member name="M:MapWinGeoProc.Utils.Centroid(MapWinGIS.Shape@)">
            Centroid()
            <summary>
            This function returns a MapWinGIS.Point that represents the
            mathematical "center of mass" for the MapWinGIS.Shape polygon.
            Currently, shapes with multiple parts are supported, but treated
            as island chains, not as shapes with holes.  Shapes with holes
            or shapes with self-intersecting parts will still return a value,
            but it is not likely to be the correct value.
            </summary>
            <param name="polygon">[In] The MapWinGIS.Shape 
            POLYGON/POLYGONZ/POLYGONM to find the centroid of.</param>
            <returns>The centroid: a point representing the center of mass of the polygon.</returns>
            <remarks>this version of the function has been heavilly redone
            from Angela's orginal code in order to allow for the centroid to be calculated
            for many more situations.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.Utils.CentroidOfPart(MapWinGIS.Shape,System.Int32)">
            CentroidOfPart()
            <summary>
            This function will calculate the centroid for a specific part of a
            Mapwinshape.  If the shape has only one part, the integer value
            PartIndex will be ignored, and the centroid for the entire shape
            will be calculated.
            </summary>
            <param name="polygon">MapWinGIS.Shape of type 
            POLYGON/POLYGONZ/POLYGONM to obtain the centroid of or containing
            the specific part to obtain the centroid of.</param>
            <param name="PartIndex">The integer index value of the part in 
            polygon to find the centroid of.  This value will be ignored if
            there is only one part in the polygon, and teh centroid for the
            entire shape will be returned.</param>
            <returns>A MapWinGIS.Point representing the position of the 
            two dimensional centroid of the part of polygon specified by
            PartIndex</returns>
            <remarks>
            Initially authored by Ted Dunsford on 6/23/2006
            Derived from Angela's algorithm, but heavily modified
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.Utils.Area(MapWinGIS.Shape@)">
            Area()
            <summary>
            Computes the area of a polygon. For multi-part polygons, assume holes are counter-clockwise.
            This function will only give correct results for shapes in equal-area projection. Don't use
            this function for shapes in decimal degrees (lat/long)
            </summary>
            <param name="shape">The polygon shape.</param>
            <returns>The area in square units, or 0.0 if it could not be found.</returns>
            <remarks>Revised by Ted Dunsford 6/23/2006 to loop through AreaOfPart</remarks>
        </member>
        <member name="M:MapWinGeoProc.Utils.Area(MapWinGIS.Shape@,MapWindow.Interfaces.UnitOfMeasure)">
            Area (Overloaded version)
            <summary>
            Overloaded version, computes the area of a polygon. For multi-part polygons, assume holes are 
            counter-clockwise. This function also works for shapes in lat/long (decimal degrees) coordinates.
            If the shape is in decimal degrees, resulting area will be returned in square kilometres.
            For other units, make sure the shape is in equal-area projection.
            </summary>
            <param name="shape">The polygon shape.</param>
            <param name="shapeUnits">Distance units from the shape's projection</param>
            <returns>The area in square kilometres (for decimal degree coordinates) or in the squared
            shape distance units (for metres, feet and other units)</returns>
        </member>
        <member name="M:MapWinGeoProc.Utils.AreaOfPart(MapWinGIS.Shape,System.Int32)">
             AreaOfPart()
             <summary>
             Calculates the area of a part, without taking into consideration any other aspects of the polygon.
             </summary>
             <param name="polygon">A MapWinGIS.Shape POLYGON, POLYGONZ, or POLYGONM</param>
             <param name="PartIndex">The integer index of the part to obtain the area of.
             This value will be ignored if the shape only has one part, and the function
             will calculate the area of the entire shape.</param>
             <returns>A double value that is equal to the area of the part.</returns>
             <remarks>Coded by Ted Dunsford 6/23/2006, derived from Angela's Area algorithm
             Code reference http://astronomy.swin.edu.au/~pbourke/geometry/polyarea/
             Cached in MapWinGeoProc\clsUtils\Documentation\
             I don't think that we ever want to return a negative area from this function,
             even if the part is a hole, because it is being calculated outside of the 
             context of any other parts.  Only the collective Area function should worry about 
             ascribing a sign value to the individual part areas.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.Utils.PartIsSelfIntersecting(MapWinGIS.Shape,System.Int32)">
            bool IsSelfIntersecting()
            <summary>
            Tests a specific part to ascertain if any two segements in the part intersect each other.
            </summary>
            <param name="shape">A MapWinGIS Shapefile object.</param>
            <param name="PartIndex">An integer from 0 to Shape.numParts - 1 specifying the part to test.</param>
            <returns>A True if lines intersect, false if not.</returns>
            <remarks>
            Author: Ted Dunsford 6/21/2006
            Algorithm derived from: http://astronomy.swin.edu.au/~pbourke/geometry/lineline2d/
            Cached in MapWinGeoProc\Documentation\IntersectionPointOfTwoLines.htm
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.Utils.GetPartBounds(MapWinGIS.Shape,System.Int32)">
            GetPartBounds()
            <summary>
            This function verifies that PartIndex references a valid part in 'polygon'
            and returns a structure containing the integer part index, beginning point
            index for and ending point index for the part specified by PartIndex.  It also
            tests polygon to make sure that it is not null and is a polygon shapetype.
            </summary>
            <param name="polygon">A MapWinGIS.Shape of POLYGON/POLYGONZ/POLYGONM type.</param>
            <param name="PartIndex">The integer part index to determine the first and
            last point index of.</param>
            <returns>A PartBounds structure defined in this class that contains the part
            index, the beginning point index and end point index included in the part.</returns>
        </member>
        <member name="M:MapWinGeoProc.Utils.CheckPolygon(MapWinGIS.Shape)">
            CheckPolygon()
            <summary>
            Checks a shape object to ensure that it is a valid polygon.
            Errors will throw exceptions.
            </summary>
            <param name="polygon">MapWinGIS Shape to test.</param>
        </member>
        <member name="M:MapWinGeoProc.Utils.CreateCompareGrid(System.String,System.String,System.String)">
            <summary>
            A simple function that takes two grid paths and an output grid path and does a simple comparison by subtracting the cell values of the second grid from the cells of the first grid and outputs the result to the output grid with 0's being no-data values so only differences will show up.
            </summary>
            <param name="grid1path"></param>
            <param name="grid2path"></param>
            <param name="outgridpath"></param>
        </member>
        <member name="T:MapWinGeoProc.Utils.PartBounds">
            <summary>
            A short structure with an integer of a part index and the first and last point in a shape.
            The values are inclusive, so both begPoint and endPoint are in the part.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Utils.PartBounds.PartIndex">
            <summary>
            The integer index value indicating the part in a multi-part polygon.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Utils.PartBounds.begPoint">
            <summary>
            The first point in the polygon that is inside the part
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Utils.PartBounds.endPoint">
            <summary>
            The last point in the polygon that is inside the part
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Statistics">
            <summary>
            Statistics includes operations for finding things such as distance, area and length.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Statistics.Centroid(MapWinGIS.Shape@)">
            <summary>
            Finds the point that represents the "center of mass" for a polygon shape.
            </summary>
            <param name="polygon">The polygon shape.</param>
            <returns>The centroid: a point representing the center of mass of the polygon.</returns>
        </member>
        <member name="M:MapWinGeoProc.Statistics.Area(MapWinGIS.Shape@)">
            <summary>
            Computes the area of a polygon. For multi-part polygons, assume holes are counter-clockwise.
            To calculate the area correctly, the shape must have an equal-area projection. For shapes
            in Lat/Long coordinates use the LLArea() function.
            </summary>
            <param name="shape">The polygon shape.</param>
            <returns>The area in square units, or 0.0 if it could not be found.</returns>
        </member>
        <member name="M:MapWinGeoProc.Statistics.LLArea(MapWinGIS.Shape@)">
            <summary>
            Calculate area of shapes in lat/long coordinates.
            The shape coordinates must be in decimal degrees. It is assumed that the WGS-84
            ellipsoid is used - this can result in small errors if the coordinate system of the
            shape is based on a different ellipsoid.
            Added by Jiri Kadlec based on the UpdateMeasurements plugin code by Paul Meems.
            </summary>
            <param name="shp">The polygon shape (must have coordinates in decimal degrees)</param>
            <returns>Area of shape in square kilometres</returns>
        </member>
        <member name="M:MapWinGeoProc.Statistics.SphericPolygonArea(MapWinGIS.Shape@)">
            <summary>
            calculate the area of large shapes in lat/long coordinates.
            The coordinates must be in decimal degrees
            the return value is in square kilometres
            </summary>
            <param name="shape">Polygon shape (decimal degree coordinates)</param>
            <returns>Area of the shape in square kilometres</returns>
        </member>
        <member name="M:MapWinGeoProc.Statistics.ComputeAreas(MapWinGIS.Shapefile)">
            <summary>
            Not Implemented
            This function will calculate the area of every polygon shape in the shapefile and write the results to the corresponding .dbf table.
            </summary>
            <param name="polySF">The shapefile of polygons whose areas are to be computed.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Statistics.ComputeLengths(MapWinGIS.Shapefile,System.Int32,System.String)">
            <summary>
            Not Implemented
            This function will calculate the length of every line shape in the shapefile and save the results to the corresponding .dbf table.
            </summary>
            <param name="sf">The shapefile of lines whose lengths are to be computed.</param>
            <param name="fieldIndex">The field index of the field to update with values.</param>
            <param name="Units">The units of the dataset (e.g., Meters, Lat/Long).</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Statistics.LLDistance(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Computes distance from two latitude and longitude points.
            This is somewhat error prone, as latitude and longitude require many
            admustments to make them true representations without loss of area.
            This function is a very good spheroid approximation.
            </summary>
            <param name="p1lat"></param>
            <param name="p1lon"></param>
            <param name="p2lat"></param>
            <param name="p2lon"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Statistics.DistancePointToPoint(System.Double,System.Double,System.Double,System.Double,System.String)">
            <summary>
            Computes the Euclidean distance between two points.
            </summary>
            <param name="x1">The first point.</param>
            <param name="x2">The second point.</param>
            <param name="y1">The first point.</param>
            <param name="y2">The second point.</param>
            <param name="Units">The units of the data (e.g., "Meters", "Lat/Long")</param>
            <returns>The distance between the first and second point, else 0 if an error was encountered.</returns>
        </member>
        <member name="M:MapWinGeoProc.Statistics.DistancePointToPoint(System.Double,System.Double,System.Double,System.Double,MapWindow.Interfaces.UnitOfMeasure)">
            <summary>
            Overloaded version - Computes the Euclidean distance between two points.
            </summary>
            <param name="x1">The first point.</param>
            <param name="x2">The second point.</param>
            <param name="y1">The first point.</param>
            <param name="y2">The second point.</param>
            <param name="Units">The units of the data (e.g., "Meters", "Lat/Long")</param>
            <returns>The distance between the first and second point, else 0 if an error was encountered.</returns>
        </member>
        <member name="M:MapWinGeoProc.Statistics.DistancePointToLine(MapWinGIS.Point,MapWinGIS.Shape,System.Int32)">
            <summary>
            Not Implemented
            Computes the distance between a point and a line.
            </summary>
            <param name="pt">The point to be considered.</param>
            <param name="line">The line to be considered.</param>
            <param name="distType">Indicates whether the distance should be from the nearest, farthest, or centroid of the line.</param>
            <returns>The distance from the line, else 0 if an error was encountered.</returns>
        </member>
        <member name="M:MapWinGeoProc.Statistics.DistancePointToPolygon(MapWinGIS.Point,MapWinGIS.Shape,System.Int32)">
            <summary>
            Not implemented
            Computes the distance between a point and a polygon.
            </summary>
            <param name="pt">The point to be considered.</param>
            <param name="polygon">The line to be considered.</param>
            <param name="distType">Indicates whether the distance should be from the nearest, farthest, or centroid of the polygon.</param>
            <returns></returns>
        </member>
        <member name="T:KDTreeDLL.PriorityQueue">
            <summary>
            This class implements a PriorityQueue. This class
            is implemented in such a way that objects are added using an
            add function. The add function takes
            two parameters an object and a long.
            
            The object represents an item in the queue, the long indicates
            its priority in the queue. The remove function in this class
            returns the object first in the queue and that object is removed
            from the queue permanently.
            
            @author Simon Levy
            Translation by Marco A. Alvarez
            </summary>
        </member>
        <member name="F:KDTreeDLL.PriorityQueue.maxPriority">
            The maximum priority possible in this priority queue.
        </member>
        <member name="F:KDTreeDLL.PriorityQueue.data">
            This contains the list of objects in the queue.
        </member>
        <member name="F:KDTreeDLL.PriorityQueue.value">
            This contains the list of prioritys in the queue.
        </member>
        <member name="F:KDTreeDLL.PriorityQueue.count">
            Holds the number of elements currently in the queue.
        </member>
        <member name="F:KDTreeDLL.PriorityQueue.capacity">
            This holds the number elements this queue can have.
        </member>
        <member name="M:KDTreeDLL.PriorityQueue.#ctor">
            Creates a new <code>PriorityQueue</code> object. The
            <code>PriorityQueue</code> object allows objects to be
            entered into the queue and to leave in the order of
            priority i.e the highest priority get's to leave first.
        </member>
        <member name="M:KDTreeDLL.PriorityQueue.#ctor(System.Int32)">
             Creates a new <code>PriorityQueue</code> object. The
             <code>PriorityQueue</code> object allows objects to
             be entered into the queue an to leave in the order of
             priority i.e the highest priority get's to leave first.
            
             @param capacity the initial capacity of the queue before
             a resize
        </member>
        <member name="M:KDTreeDLL.PriorityQueue.#ctor(System.Int32,System.Double)">
             Creates a new <code>PriorityQueue</code> object. The
             <code>PriorityQueue</code> object allows objects to
             be entered into the queue an to leave in the order of
             priority i.e the highest priority get's to leave first.
            
             @param capacity the initial capacity of the queue before
             a resize
             @param maxPriority is the maximum possible priority for
             an object
        </member>
        <member name="M:KDTreeDLL.PriorityQueue.init(System.Int32)">
             This is an initializer for the object. It basically initializes
             an array of long called value to represent the prioritys of
             the objects, it also creates an array of objects to be used
             in parallel with the array of longs, to represent the objects
             entered, these can be used to sequence the data.
            
             @param size the initial capacity of the queue, it can be
             resized
        </member>
        <member name="M:KDTreeDLL.PriorityQueue.add(System.Object,System.Double)">
             This function adds the given object into the <code>PriorityQueue</code>,
             its priority is the long priority. The way in which priority can be
             associated with the elements of the queue is by keeping the priority
             and the elements array entrys parallel.
            
             @param element is the object that is to be entered into this
             <code>PriorityQueue</code>
             @param priority this is the priority that the object holds in the
             <code>PriorityQueue</code>
        </member>
        <member name="M:KDTreeDLL.PriorityQueue.remove">
             Remove is a function to remove the element in the queue with the
             maximum priority. Once the element is removed then it can never be
             recovered from the queue with further calls. The lowest priority
             object will leave last.
            
             @return the object with the highest priority or if it's empty
             null
        </member>
        <member name="M:KDTreeDLL.PriorityQueue.bubbleDown(System.Int32)">
             Bubble down is used to put the element at subscript 'pos' into
             it's rightful place in the heap (i.e heap is another name
             for <code>PriorityQueue</code>). If the priority of an element
             at subscript 'pos' is less than it's children then it must
             be put under one of these children, i.e the ones with the
             maximum priority must come first.
            
             @param pos is the position within the arrays of the element
             and priority
        </member>
        <member name="M:KDTreeDLL.PriorityQueue.bubbleUp(System.Int32)">
             Bubble up is used to place an element relatively low in the
             queue to it's rightful place higher in the queue, but only
             if it's priority allows it to do so, similar to bubbleDown
             only in the other direction this swaps out its parents.
            
             @param pos the position in the arrays of the object
             to be bubbled up
        </member>
        <member name="M:KDTreeDLL.PriorityQueue.expandCapacity">
            This ensures that there is enough space to keep adding elements
            to the priority queue. It is however advised to make the capacity
            of the queue large enough so that this will not be used as it is
            an expensive method. This will copy across from 0 as 'off' equals
            0 is contains some important data.
        </member>
        <member name="M:KDTreeDLL.PriorityQueue.clear">
            This method will empty the queue. This also helps garbage
            collection by releasing any reference it has to the elements
            in the queue. This starts from offset 1 as off equals 0
            for the elements array.
        </member>
        <member name="M:KDTreeDLL.PriorityQueue.length">
             The number of elements in the queue. The length
             indicates the number of elements that are currently
             in the queue.
            
             @return the number of elements in the queue
        </member>
        <member name="T:MapWinGeoProc.CrossSection">
            <summary>
            This class stores the functions dealing with cross sections of elevation grids.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.CrossSection.GetCrossSection">
            <summary>
            This overload of GetCrossSection launches a dialog to obtain the required parameters from the user.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.CrossSection.GetCrossSection(System.String,System.String,System.String,MapWinGeoProc.CrossSection.CrossSectionTypes)">
            <summary>
            This creates a new shapefile that has Z values and follows along the same line segments.
            The boundaries for grid cells are marked with vertices and the segment is given a Z value
            that corresponds to the grid elevation it intersects.
            </summary>
            <param name="ElevGrid">A string filename for the grid that contains the elevations.</param>
            <param name="PolyLine">A string filename for a polyline shapefile that shows the pathways of the cross sections in the X-Y direction.</param>
            <param name="OutFileName">A string containing the full path of the desired output shapefile.  The extension should be *.shp</param>
            <param name="CrossSectionType">Clarifies the type of output</param>
            <remarks>This function throws Argument or Application exceptions on errors, so it's recommended that coders enclose it in a try catch block.</remarks>
        </member>
        <member name="M:MapWinGeoProc.CrossSection.GetCrossSection(System.String,System.String,System.String,MapWinGeoProc.CrossSection.CrossSectionTypes,MapWinGIS.ICallback)">
            <summary>
            This creates a new shapefile that has Z values and follows along the same line segments.
            The boundaries for grid cells are marked with vertices and the segment is given a Z value
            that corresponds to the grid elevation it intersects.
            </summary>
            <param name="ElevGrid">A string filename for the grid that contains the elevations.</param>
            <param name="PolyLine">A string filename for a polyline shapefile that shows the pathways of the cross sections in the X-Y direction.</param>
            <param name="OutFileName">A string containing the full path of the desired output shapefile.  The extension should be *.shp</param>
            <param name="CrossSectionType">Clarifies the type of output</param>
            <param name="ICallBack">A MapWinGIS.ICallback for progress messages. [Optional]</param>
            <remarks>This function throws Argument or Application exceptions on errors, so it's recommended that coders enclose it in a try catch block.</remarks>
        </member>
        <member name="M:MapWinGeoProc.CrossSection.GetCrossSection(MapWinGIS.Grid,MapWinGIS.Shapefile,System.String,MapWinGeoProc.CrossSection.CrossSectionTypes)">
            <summary>
            This creates a new shapefile that has Z values and follows along the same line segments.
            The boundaries for grid cells are marked with vertices and the segment is given a Z value
            that corresponds to the grid elevation it intersects.
            </summary>
            <param name="mwElevGrid">A MapWinGIS Grid that contains the elevations.</param>
            <param name="mwPolyLine">A MapWinGIS Shapefile that shows the pathways of the cross sections in the X-Y direction.</param>
            <param name="OutFileName">A string containing the full path of the desired output shapefile.  The extension should be *.shp</param>
            <param name="CrossSectionType">Clarifies the type of output</param>
            <remarks>This function throws Argument or Application exceptions on errors, so it's recommended that coders enclose it in a try catch block.</remarks>
        </member>
        <member name="M:MapWinGeoProc.CrossSection.GetCrossSection(MapWinGIS.Grid,MapWinGIS.Shapefile,System.String,MapWinGeoProc.CrossSection.CrossSectionTypes,MapWinGIS.ICallback)">
            <summary>
            This creates a new shapefile that has Z values and follows along the same line segments.
            The boundaries for grid cells are marked with vertices and the segment is given a Z value
            that corresponds to the grid elevation it intersects.
            </summary>
            <param name="mwElevGrid">A MapWinGIS Grid that contains the elevations.</param>
            <param name="mwPolyLine">A MapWinGIS Shapefile that shows the pathways of the cross sections in the X-Y direction.</param>
            <param name="OutFileName">A string containing the full path of the desired output shapefile.  The extension should be *.shp</param>
            <param name="CrossSectionType">Clarifies the type of output.  default = PolyLineWithZ</param>
            <param name="ICallBack">A MapWinGIS.ICallback for progress messages. [Optional]</param>
            <remarks>This function throws Argument or Application exceptions on errors, so it's recommended that coders enclose it in a try catch block.</remarks>
        </member>
        <member name="T:MapWinGeoProc.CrossSection.CrossSectionTypes">
            <summary>
            Contains options for the CrossSection function
            </summary>
        </member>
        <member name="F:MapWinGeoProc.CrossSection.CrossSectionTypes.PolyLineWithZ">
            <summary>
            Specifies the output should be a polyline with z values for each vertex
            </summary>
        </member>
        <member name="F:MapWinGeoProc.CrossSection.CrossSectionTypes.PointsWithZAndElevField">
            <summary>
            Specifies the output should be a series of points with both Z valued elevation and an additional elevation field.
            </summary>
        </member>
        <member name="T:RTools.Util.VerbosityLevel">
            <summary>
            This enumerates verbosity levels.
            </summary>
        </member>
        <member name="F:RTools.Util.VerbosityLevel.Error">
            <summary>For error messages.</summary>
        </member>
        <member name="F:RTools.Util.VerbosityLevel.Warn">
            <summary>For warn messages.</summary>
        </member>
        <member name="F:RTools.Util.VerbosityLevel.Info">
            <summary>For info messages.</summary>
        </member>
        <member name="F:RTools.Util.VerbosityLevel.Debug">
            <summary>For debug messages.</summary>
        </member>
        <member name="T:RTools.Util.CharBuffer">
            <summary>
            Buffer for characters.  This approximates StringBuilder
            but is designed to be faster for specific operations.
            This is about 30% faster for the operations I'm interested in
            (Append, Clear, Length, ToString).
            This trades off memory for speed.
            </summary>
            <remarks>
            <para>To make Remove from the head fast, this is implemented
            as a ring buffer.</para>
            <para>This uses head and tail indices into a fixed-size 
            array. This will grow the array as necessary.</para>
            </remarks>
        </member>
        <member name="M:RTools.Util.CharBuffer.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:RTools.Util.CharBuffer.#ctor(System.Int32)">
            <summary>
            Construct with a specific capacity.
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:RTools.Util.CharBuffer.Grow(System.Int32)">
            <summary>
            Reallocate the buffer to be larger. For the new size, this
            uses the max of the requested length and double the current
            capacity.
            This does not shift, meaning it does not change the head or
            tail indices.
            </summary>
            <param name="requestedLen">The new requested length.</param>
        </member>
        <member name="M:RTools.Util.CharBuffer.CheckCapacity(System.Int32)">
            <summary>
            Ensure that we're set for the requested length by 
            potentially growing or shifting contents.
            </summary>
            <param name="requestedLength"></param>
        </member>
        <member name="M:RTools.Util.CharBuffer.ShiftToZero">
            <summary>
            Move the buffer contents such that headIndex becomes 0.
            </summary>
        </member>
        <member name="M:RTools.Util.CharBuffer.SetBuffer(System.Char[],System.Int32)">
            <summary>
            Overwrite this object's underlying buffer with the specified
            buffer.
            </summary>
            <param name="b">The character array.</param>
            <param name="len">The number of characters to consider filled
            in the input buffer.</param>
        </member>
        <member name="M:RTools.Util.CharBuffer.Append(System.Char)">
            <summary>
            Append a character to this buffer.
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:RTools.Util.CharBuffer.Append(System.String)">
            <summary>
            Append a string to this buffer.
            </summary>
            <param name="s">The string to append.</param>
        </member>
        <member name="M:RTools.Util.CharBuffer.Append(RTools.Util.CharBuffer)">
            <summary>
            Append a string to this buffer.
            </summary>
            <param name="s">The string to append.</param>
        </member>
        <member name="M:RTools.Util.CharBuffer.Remove(System.Int32)">
            <summary>
            Remove a character at the specified index.
            </summary>
            <param name="i">The index of the character to remove.</param>
            <returns></returns>
        </member>
        <member name="M:RTools.Util.CharBuffer.Remove(System.Int32,System.Int32)">
            <summary>
            Remove a specified number of characters at the specified index.
            </summary>
            <param name="i">The index of the characters to remove.</param>
            <param name="n">The number of characters to remove.</param>
        </member>
        <member name="M:RTools.Util.CharBuffer.IndexOf(System.Char)">
            <summary>
            Find the first instance of a character in the buffer, and
            return its index.  This returns -1 if the character is
            not found.
            </summary>
            <param name="c">The character to find.</param>
            <returns>The index of the specified character, or -1
            for not found.</returns>
        </member>
        <member name="M:RTools.Util.CharBuffer.Clear">
            <summary>
            Empty the buffer.
            </summary>
        </member>
        <member name="M:RTools.Util.CharBuffer.ToString">
            <summary>
            Return the current contents as a string.
            </summary>
            <returns>The new string.</returns>
        </member>
        <member name="P:RTools.Util.CharBuffer.Length">
            <summary>
            Gets/Sets the number of characters in the character buffer.
            Increasing the length this way provides indeterminate results.
            </summary>
        </member>
        <member name="P:RTools.Util.CharBuffer.Capacity">
            <summary>
            Returns the capacity of this character buffer.
            </summary>
        </member>
        <member name="P:RTools.Util.CharBuffer.Item(System.Int32)">
            <summary>
            Indexer.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Utilities.CollectionUtil">
            <summary>
            Executes a transformation function on each element of a collection
            and returns the results in a new List.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.CollectionUtil.Transform(System.Collections.ICollection,MapWinGeoProc.NTS.Topology.Utilities.CollectionUtil.FunctionDelegate{System.Object})">
            <summary>
            Executes a function on each item in a <see cref="T:System.Collections.ICollection"/>
            and returns the results in a new <see cref="T:System.Collections.IList"/>.
            </summary>
            <param name="coll"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.CollectionUtil.Apply(System.Collections.ICollection,MapWinGeoProc.NTS.Topology.Utilities.CollectionUtil.FunctionDelegate{System.Object})">
            <summary>
            Executes a function on each item in a <see cref="T:System.Collections.ICollection"/> 
            but does not accumulate the result.
            </summary>
            <param name="coll"></param>
            <param name="func"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.CollectionUtil.Select(System.Collections.ICollection,MapWinGeoProc.NTS.Topology.Utilities.CollectionUtil.FunctionDelegate{System.Object})">
            <summary>
            Executes a function on each item in a <see cref="T:System.Collections.ICollection"/>
            and collects all the entries for which the result
            of the function is equal to <c>true</c>.
            </summary>
            <param name="coll"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Utilities.CollectionUtil.FunctionDelegate`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Utilities.BitConverter">
            <summary>
            A supoort class: the purpose is to integrate System.BitConverter methods not presents in .NET Compact Framework.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.BitConverter.DoubleToInt64Bits(System.Double)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.BitConverter.Int64BitsToDouble(System.Int64)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Planargraph.Subgraph">
            <summary>
            A subgraph of a <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph"/>.
            A subgraph may contain any subset of <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.Edge"/>s
            from the parent graph.
            It will also automatically contain all <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge"/>s
            and <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.Node"/>s associated with those edges.
            No new objects are created when edges are added -
            all associated components must already exist in the parent graph.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Planargraph.Subgraph.parentGraph">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Planargraph.Subgraph.edges">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Planargraph.Subgraph.dirEdges">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Planargraph.Subgraph.nodeMap">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Subgraph.#ctor(MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph)">
            <summary>
            Creates a new subgraph of the given <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph"/>.
            </summary>
            <param name="parentGraph"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Subgraph.GetParent">
            <summary>
             Gets the <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.PlanarGraph"/> which this subgraph is part of.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Subgraph.Add(MapWinGeoProc.NTS.Topology.Planargraph.Edge)">
            <summary>
            Adds an <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.Edge"/> to the subgraph.
            The associated <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge"/>s and <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.Node"/>s are also added.
            </summary>
            <param name="e">The <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.Edge"/> to add.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Subgraph.GetDirEdgeEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IEnumerator"/> over the <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge"/>s in this graph,
            in the order in which they were added.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Subgraph.GetEdgeEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IEnumerator"/> over the <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.Edge"/>s in this graph,
            in the order in which they were added.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Subgraph.GetNodeEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IEnumerator"/> over the <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.Node"/>s in this graph.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.Subgraph.Contains(MapWinGeoProc.NTS.Topology.Planargraph.Edge)">
            <summary>
            Tests whether an <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.Edge"/> is contained in this subgraph.
            </summary>
            <param name="e">The <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.Edge"/> to test.</param>
            <returns><c>true</c> if the <see cref="T:MapWinGeoProc.NTS.Topology.Planargraph.Edge"/> is contained in this subgraph.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Relate.EdgeEndBuilder">
            <summary> 
            An EdgeEndBuilder creates EdgeEnds for all the "split edges"
            created by the intersections determined for an Edge.
            Computes the <c>EdgeEnd</c>s which arise from a noded <c>Edge</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.EdgeEndBuilder.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.EdgeEndBuilder.ComputeEdgeEnds(System.Collections.IEnumerator)">
            <summary>
            
            </summary>
            <param name="edges"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.EdgeEndBuilder.ComputeEdgeEnds(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge,System.Collections.IList)">
            <summary>
            Creates stub edges for all the intersections in this
            Edge (if any) and inserts them into the graph.
            </summary>
            <param name="edge"></param>
            <param name="l"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.EdgeEndBuilder.CreateEdgeEndForPrev(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge,System.Collections.IList,MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersection,MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersection)">
            <summary>
            Create a EdgeStub for the edge before the intersection eiCurr.
            The previous intersection is provided
            in case it is the endpoint for the stub edge.
            Otherwise, the previous point from the parent edge will be the endpoint.
            eiCurr will always be an EdgeIntersection, but eiPrev may be null.
            </summary>
            <param name="edge"></param>
            <param name="l"></param>
            <param name="eiCurr"></param>
            <param name="eiPrev"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.EdgeEndBuilder.CreateEdgeEndForNext(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge,System.Collections.IList,MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersection,MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeIntersection)">
            <summary>
            Create a StubEdge for the edge after the intersection eiCurr.
            The next intersection is provided
            in case it is the endpoint for the stub edge.
            Otherwise, the next point from the parent edge will be the endpoint.
            eiCurr will always be an EdgeIntersection, but eiNext may be null.
            </summary>
            <param name="edge"></param>
            <param name="l"></param>
            <param name="eiCurr"></param>
            <param name="eiNext"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Predicate.RectangleIntersects">
            <summary>
            Optimized implementation of spatial predicate "intersects"
            for cases where the first {@link Geometry} is a rectangle.    
            As a further optimization,
            this class can be used directly to test many geometries against a single
            rectangle.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Operation.Predicate.RectangleIntersects.MaximumScanSegmentCount">
            <summary>     
            Crossover size at which brute-force intersection scanning
            is slower than indexed intersection detection.
            Must be determined empirically.  Should err on the
            safe side by making value smaller rather than larger.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.RectangleIntersects.Intersects(MapWinGeoProc.NTS.Topology.Geometries.Polygon,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="rectangle"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.RectangleIntersects.#ctor(MapWindow.Interfaces.Geometries.IPolygon)">
            <summary>
            Create a new intersects computer for a rectangle.
            </summary>
            <param name="rectangle">A rectangular geometry.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.RectangleIntersects.Intersects(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Predicate.EnvelopeIntersectsVisitor">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.Utilities.ShortCircuitedGeometryVisitor">
            <summary>
            A visitor to Geometry elements which can
            be short-circuited by a given condition.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.ShortCircuitedGeometryVisitor.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.ShortCircuitedGeometryVisitor.ApplyTo(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.ShortCircuitedGeometryVisitor.Visit(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Utilities.ShortCircuitedGeometryVisitor.IsDone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.EnvelopeIntersectsVisitor.#ctor(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            
            </summary>
            <param name="rectEnv"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.EnvelopeIntersectsVisitor.Intersects">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.EnvelopeIntersectsVisitor.Visit(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.EnvelopeIntersectsVisitor.IsDone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Predicate.ContainsPointVisitor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.ContainsPointVisitor.#ctor(MapWindow.Interfaces.Geometries.IPolygon)">
            <summary>
            
            </summary>
            <param name="rectangle"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.ContainsPointVisitor.ContainsPoint">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.ContainsPointVisitor.Visit(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.ContainsPointVisitor.IsDone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Predicate.LineIntersectsVisitor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.LineIntersectsVisitor.#ctor(MapWindow.Interfaces.Geometries.IPolygon)">
            <summary>
            
            </summary>
            <param name="rectangle"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.LineIntersectsVisitor.Intersects">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.LineIntersectsVisitor.Visit(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.LineIntersectsVisitor.ComputeSegmentIntersection(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Predicate.LineIntersectsVisitor.IsDone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Overlay.LineBuilder">
            <summary>
            Forms NTS LineStrings out of a the graph of <c>DirectedEdge</c>s
            created by an <c>OverlayOp</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.LineBuilder.#ctor(MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayOp,MapWindow.Interfaces.Geometries.IGeometryFactory,MapWinGeoProc.NTS.Topology.Algorithm.PointLocator)">
            <summary>
            
            </summary>
            <param name="op"></param>
            <param name="geometryFactory"></param>
            <param name="ptLocator"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.LineBuilder.Build(MapWinGeoProc.NTS.Topology.Operation.Overlay.SpatialFunctions)">
            <summary>
            
            </summary>
            <param name="opCode"></param>
            <returns>
            A list of the LineStrings in the result of the specified overlay operation.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.LineBuilder.FindCoveredLineEdges">
            <summary>
            Find and mark L edges which are "covered" by the result area (if any).
            L edges at nodes which also have A edges can be checked by checking
            their depth at that node.
            L edges at nodes which do not have A edges can be checked by doing a
            point-in-polygon test with the previously computed result areas.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.LineBuilder.CollectLines(MapWinGeoProc.NTS.Topology.Operation.Overlay.SpatialFunctions)">
            <summary>
            
            </summary>
            <param name="opCode"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.LineBuilder.CollectLineEdge(MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge,MapWinGeoProc.NTS.Topology.Operation.Overlay.SpatialFunctions,System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="de"></param>
            <param name="opCode"></param>
            <param name="edges"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.LineBuilder.CollectBoundaryTouchEdge(MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge,MapWinGeoProc.NTS.Topology.Operation.Overlay.SpatialFunctions,System.Collections.IList)">
            <summary>
            Collect edges from Area inputs which should be in the result but
            which have not been included in a result area.
            This happens ONLY:
            during an intersection when the boundaries of two
            areas touch in a line segment
            OR as a result of a dimensional collapse.
            </summary>
            <param name="de"></param>
            <param name="opCode"></param>
            <param name="edges"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.LineBuilder.BuildLines(MapWinGeoProc.NTS.Topology.Operation.Overlay.SpatialFunctions)">
            <summary>
            
            </summary>
            <param name="opCode"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.LineBuilder.LabelIsolatedLines(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="edgesList"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.LineBuilder.LabelIsolatedLine(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge,System.Int32)">
            <summary>
            Label an isolated node with its relationship to the target point.
            </summary>
            <param name="e"></param>
            <param name="targetIndex"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveSetBuilder">
            <summary>
            Creates all the raw offset curves for a buffer of a <c>Geometry</c>.
            Raw curves need to be noded together and polygonized to form the final buffer area.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveSetBuilder.#ctor(MapWindow.Interfaces.Geometries.IGeometry,System.Double,MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveBuilder)">
            <summary>
            
            </summary>
            <param name="inputGeom"></param>
            <param name="distance"></param>
            <param name="curveBuilder"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveSetBuilder.GetCurves">
            <summary>
            Computes the set of raw offset curves for the buffer.
            Each offset curve has an attached {Label} indicating
            its left and right location.
            </summary>
            <returns>A Collection of SegmentStrings representing the raw buffer curves.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveSetBuilder.AddCurves(System.Collections.IList,MapWindow.Interfaces.Geometries.Locations,MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            
            </summary>
            <param name="lineList"></param>
            <param name="leftLoc"></param>
            <param name="rightLoc"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveSetBuilder.AddCurve(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[],MapWindow.Interfaces.Geometries.Locations,MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            Creates a {SegmentString} for a coordinate list which is a raw offset curve,
            and adds it to the list of buffer curves.
            The SegmentString is tagged with a Label giving the topology of the curve.
            The curve may be oriented in either direction.
            If the curve is oriented CW, the locations will be:
            Left: Location.Exterior.
            Right: Location.Interior.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveSetBuilder.Add(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveSetBuilder.AddCollection(MapWindow.Interfaces.Geometries.IGeometryCollection)">
            <summary>
            
            </summary>
            <param name="gc"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveSetBuilder.AddPoint(MapWindow.Interfaces.Geometries.IPoint)">
            <summary>
            Add a Point to the graph.
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveSetBuilder.AddLineString(MapWindow.Interfaces.Geometries.ILineString)">
            <summary>
            
            </summary>
            <param name="line"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveSetBuilder.AddPolygon(MapWindow.Interfaces.Geometries.IPolygon)">
            <summary>
            
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveSetBuilder.AddPolygonRing(MapWindow.Interfaces.Geometries.ICoordinate[],System.Double,MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions,MapWindow.Interfaces.Geometries.Locations,MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            Add an offset curve for a ring.
            The side and left and right topological location arguments
            assume that the ring is oriented CW.
            If the ring is in the opposite orientation,
            the left and right locations must be interchanged and the side flipped.
            </summary>
            <param name="coord">The coordinates of the ring (must not contain repeated points).</param>
            <param name="offsetDistance">The distance at which to create the buffer.</param>
            <param name="side">The side of the ring on which to construct the buffer line.</param>
            <param name="cwLeftLoc">The location on the L side of the ring (if it is CW).</param>
            <param name="cwRightLoc">The location on the R side of the ring (if it is CW).</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveSetBuilder.IsErodedCompletely(MapWindow.Interfaces.Geometries.ICoordinate[],System.Double)">
            <summary>
            The ringCoord is assumed to contain no repeated points.
            It may be degenerate (i.e. contain only 1, 2, or 3 points).
            In this case it has no area, and hence has a minimum diameter of 0.
            </summary>
            <param name="ringCoord"></param>
            <param name="bufferDistance"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.OffsetCurveSetBuilder.IsTriangleErodedCompletely(MapWindow.Interfaces.Geometries.ICoordinate[],System.Double)">
            <summary>
            Tests whether a triangular ring would be eroded completely by the given
            buffer distance.
            This is a precise test.  It uses the fact that the inner buffer of a
            triangle converges on the inCentre of the triangle (the point
            equidistant from all sides).  If the buffer distance is greater than the
            distance of the inCentre from a side, the triangle will be eroded completely.
            This test is important, since it removes a problematic case where
            the buffer distance is slightly larger than the inCentre distance.
            In this case the triangle buffer curve "inverts" with incorrect topology,
            producing an incorrect hole in the buffer.       
            </summary>
            <param name="triangleCoord"></param>
            <param name="bufferDistance"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.IteratedNoder">
            <summary>
            Nodes a set of <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s completely.
            The set of <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s is fully noded;
            i.e. noding is repeated until no further intersections are detected.
            <para>
            Iterated noding using a PrecisionModels.Floating precision model is not guaranteed to converge,
            due to roundoff error. This problem is detected and an exception is thrown.
            Clients can choose to rerun the noding using a lower precision model.
            </para>
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Noding.IteratedNoder.MaxIterations">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.IteratedNoder.#ctor(MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel)">
            <summary>
            Initializes a new instance of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.IteratedNoder"/> class.
            </summary>
            <param name="pm"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.IteratedNoder.GetNodedSubstrings">
            <summary>
            Returns a <see cref="T:System.Collections.IList"/> of fully noded <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s.
            The <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s have the same context as their parent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.IteratedNoder.ComputeNodes(System.Collections.IList)">
            <summary>
            Fully nodes a list of <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s, i.e. peforms noding iteratively
            until no intersections are found between segments.
            Maintains labelling of edges correctly through the noding.
            </summary>
            <param name="segStrings">A collection of SegmentStrings to be noded.</param>
            <exception cref="T:MapWinGeoProc.NTS.Topology.Geometries.TopologyException">If the iterated noding fails to converge.</exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.IteratedNoder.Node(System.Collections.IList,System.Int32[])">
            <summary>
            Node the input segment strings once
            and create the split edges between the nodes.
            </summary>
            <param name="segStrings"></param>
            <param name="numInteriorIntersections"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.IteratedNoder.MaximumIterations">
            <summary>
            Gets/Sets the maximum number of noding iterations performed before
            the noding is aborted. Experience suggests that this should rarely need to be changed
            from the default. The default is <see cref="F:MapWinGeoProc.NTS.Topology.Noding.IteratedNoder.MaxIterations"/>.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.PolygonHandler">
            <summary>
            Converts a Shapefile point to a OGIS Polygon.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.PolygonHandler.#ctor">
            <summary>
            Initializes a new instance of the PolygonHandler class.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.PolygonHandler.Read(MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryReader,MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            Reads a stream and converts the shapefile record to an equilivent geometry object.
            </summary>
            <param name="file">The stream to read.</param>
            <param name="geometryFactory">The geometry factory to use when making the object.</param>
            <returns>The Geometry object that represents the shape file record.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.PolygonHandler.Write(MapWindow.Interfaces.Geometries.IGeometry,System.IO.BinaryWriter,MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            Writes a Geometry to the given binary wirter.
            </summary>
            <param name="geometry">The geometry to write.</param>
            <param name="file">The file stream to write to.</param>
            <param name="geometryFactory">The geometry factory to use.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.PolygonHandler.WriteCoords(MapWinGeoProc.NTS.Topology.Geometries.CoordinateList,System.IO.BinaryWriter,MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            
            </summary>
            <param name="points"></param>
            <param name="file"></param>
            <param name="geometryFactory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.PolygonHandler.GetLength(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Gets the length of the shapefile record using the geometry passed in.
            </summary>
            <param name="geometry">The geometry to get the length for.</param>
            <returns>The length in bytes this geometry is going to use when written out as a shapefile record.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.PolygonHandler.GetNumParts(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.PolygonHandler.PointInList(MapWindow.Interfaces.Geometries.ICoordinate,MapWinGeoProc.NTS.Topology.Geometries.CoordinateList)">
            <summary>
            Test if a point is in a list of coordinates.
            </summary>
            <param name="testPoint">TestPoint the point to test for.</param>
            <param name="pointList">PointList the list of points to look through.</param>
            <returns>true if testPoint is a point in the pointList list.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.PolygonHandler.ShapeType">
            <summary>
            The ShapeType this handler handles.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineIndex">
            <summary>
            A sweepline implements a sorted index on a set of intervals.
            It is used to compute all overlaps between the interval in the index.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineIndex.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineIndex.Add(MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineInterval)">
            <summary>
            
            </summary>
            <param name="sweepInt"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineIndex.BuildIndex">
            <summary>
            Because Delete Events have a link to their corresponding Insert event,
            it is possible to compute exactly the range of events which must be
            compared to a given Insert event object.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineIndex.ComputeOverlaps(MapWinGeoProc.NTS.Topology.Index.Sweepline.ISweepLineOverlapAction)">
            <summary>
            
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineIndex.ProcessOverlaps(System.Int32,System.Int32,MapWinGeoProc.NTS.Topology.Index.Sweepline.SweepLineInterval,MapWinGeoProc.NTS.Topology.Index.Sweepline.ISweepLineOverlapAction)">
            <summary>
            
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <param name="s0"></param>
            <param name="action"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Strtree.Interval">
            <summary> 
            A contiguous portion of 1D-space. Used internally by SIRtree.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.Interval.#ctor(MapWinGeoProc.NTS.Topology.Index.Strtree.Interval)">
            <summary>
            
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.Interval.#ctor(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="min"></param>
            <param name="max"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.Interval.ExpandToInclude(MapWinGeoProc.NTS.Topology.Index.Strtree.Interval)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns><c>this</c></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.Interval.Intersects(MapWinGeoProc.NTS.Topology.Index.Strtree.Interval)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.Interval.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.Interval.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Strtree.Interval.Centre">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Quadtree.DoubleBits">
            <summary>
            DoubleBits manipulates Double numbers
            by using bit manipulation and bit-field extraction.
            For some operations (such as determining the exponent)
            this is more accurate than using mathematical operations
            (which suffer from round-off error).
            The algorithms and constants in this class
            apply only to IEEE-754 double-precision floating point format.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Index.Quadtree.DoubleBits.ExponentBias">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.DoubleBits.PowerOf2(System.Int32)">
            <summary>
            
            </summary>
            <param name="exp"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.DoubleBits.GetExponent(System.Double)">
            <summary>
            
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.DoubleBits.TruncateToPowerOfTwo(System.Double)">
            <summary>
            
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.DoubleBits.ToBinaryString(System.Double)">
            <summary>
            
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.DoubleBits.MaximumCommonMantissa(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.DoubleBits.#ctor(System.Double)">
            <summary>
            
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.DoubleBits.ZeroLowerBits(System.Int32)">
            <summary>
            
            </summary>
            <param name="nBits"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.DoubleBits.GetBit(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.DoubleBits.NumCommonMantissaBits(MapWinGeoProc.NTS.Topology.Index.Quadtree.DoubleBits)">
            <summary> 
            This computes the number of common most-significant bits in the mantissa.
            It does not count the hidden bit, which is always 1.
            It does not determine whether the numbers have the same exponent - if they do
            not, the value computed by this function is meaningless.
            </summary>
            <param name="db"></param>
            <returns> The number of common most-significant mantissa bits.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.DoubleBits.ToString">
            <summary>
            A representation of the Double bits formatted for easy readability.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Quadtree.DoubleBits.Double">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Quadtree.DoubleBits.BiasedExponent">
            <summary>
            Determines the exponent for the number.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Quadtree.DoubleBits.Exponent">
            <summary>
            Determines the exponent for the number.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Bintree.NodeBase">
            <summary> 
            The base class for nodes in a <c>Bintree</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.NodeBase.GetSubnodeIndex(MapWinGeoProc.NTS.Topology.Index.Bintree.Interval,System.Double)">
            <summary> 
            Returns the index of the subnode that wholely contains the given interval.
            If none does, returns -1.
            </summary>
            <param name="interval"></param>
            <param name="centre"></param>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Index.Bintree.NodeBase.items">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Index.Bintree.NodeBase.subnode">
            <summary>
            Subnodes are numbered as follows:
            0 | 1        
            .
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.NodeBase.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.NodeBase.Add(System.Object)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.NodeBase.AddAllItems(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.NodeBase.IsSearchMatch(MapWinGeoProc.NTS.Topology.Index.Bintree.Interval)">
            <summary>
            
            </summary>
            <param name="interval"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.NodeBase.AddAllItemsFromOverlapping(MapWinGeoProc.NTS.Topology.Index.Bintree.Interval,System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="interval"></param>
            <param name="resultItems"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Bintree.NodeBase.Items">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Bintree.NodeBase.Depth">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Bintree.NodeBase.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Bintree.NodeBase.NodeCount">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Bintree.Interval">
            <summary> 
            Represents an (1-dimensional) closed interval on the Real number line.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Interval.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Interval.#ctor(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="min"></param>
            <param name="max"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Interval.#ctor(MapWinGeoProc.NTS.Topology.Index.Bintree.Interval)">
            <summary>
            
            </summary>
            <param name="interval"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Interval.Init(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="min"></param>
            <param name="max"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Interval.ExpandToInclude(MapWinGeoProc.NTS.Topology.Index.Bintree.Interval)">
            <summary>
            
            </summary>
            <param name="interval"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Interval.Overlaps(MapWinGeoProc.NTS.Topology.Index.Bintree.Interval)">
            <summary>
            
            </summary>
            <param name="interval"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Interval.Overlaps(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Interval.Contains(MapWinGeoProc.NTS.Topology.Index.Bintree.Interval)">
            <summary>
            
            </summary>
            <param name="interval"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Interval.Contains(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Interval.Contains(System.Double)">
            <summary>
            
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Bintree.Interval.Min">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Bintree.Interval.Max">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Bintree.Interval.Width">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.Depth">
            <summary>
            A Depth object records the topological depth of the sides
            of an Edge for up to two Geometries.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.Depth.Null">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Depth.DepthAtLocation(MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            
            </summary>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Depth.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Depth.GetDepth(System.Int32,MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <param name="posIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Depth.SetDepth(System.Int32,MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions,System.Int32)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <param name="posIndex"></param>
            <param name="depthValue"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Depth.GetLocation(System.Int32,MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <param name="posIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Depth.Add(System.Int32,MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions,MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <param name="posIndex"></param>
            <param name="location"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Depth.IsNull">
            <summary>
            A Depth object is null (has never been initialized) if all depths are null.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Depth.IsNull(System.Int32)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Depth.IsNull(System.Int32,MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <param name="posIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Depth.Add(MapWinGeoProc.NTS.Topology.GeometriesGraph.Label)">
            <summary>
            
            </summary>
            <param name="lbl"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Depth.GetDelta(System.Int32)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Depth.Normalize">
            <summary>
            Normalize the depths for each point, if they are non-null.
            A normalized depth
            has depth values in the set { 0, 1 }.
            Normalizing the depths
            involves reducing the depths by the same amount so that at least
            one of them is 0.  If the remaining value is > 0, it is set to 1.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Depth.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Depth.Item(System.Int32,MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions)">
            <summary>
            Calls GetDepth and SetDepth.
            </summary>
            <param name="geomIndex"></param>
            <param name="posIndex"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeographicTransform">
            <summary>
            The GeographicTransform class is implemented on geographic transformation objects and
            implements datum transformations between geographic coordinate systems.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeographicTransform.Inverse">
            <summary>
            Creates the inverse transform of this object.
            </summary>
            <remarks>This method may fail if the transform is not one to one. However, all cartographic projections should succeed.</remarks>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeographicTransform.Transform(MapWinGeoProc.NTS.Topology.Geometries.Point)">
            <summary>
            Transforms a coordinate point. The passed parameter point should not be modified.
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeographicTransform.TransformList(System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.Geometries.Point})">
            <summary>
            Transforms a list of coordinate point ordinal values.
            </summary>
            <remarks>
            This method is provided for efficiently transforming many points. The supplied array 
            of ordinal values will contain packed ordinal values. For example, if the source 
            dimension is 3, then the ordinals will be packed in this order (x0,y0,z0,x1,y1,z1 ...).
            The size of the passed array must be an integer multiple of DimSource. The returned 
            ordinal values are packed in a similar way. In some DCPs. the ordinals may be 
            transformed in-place, and the returned array may be the same as the passed array.
            So any client code should not attempt to reuse the passed ordinal values (although
            they can certainly reuse the passed array). If there is any problem then the server
            implementation will throw an exception. If this happens then the client should not
            make any assumptions about the state of the ordinal values.
            </remarks>
            <param name="points"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeographicTransform.Invert">
            <summary>
            Reverses the transformation
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeographicTransform.SourceGCS">
            <summary>
            Gets or sets the source geographic coordinate system for the transformation.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeographicTransform.TargetGCS">
            <summary>
            Gets or sets the target geographic coordinate system for the transformation.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeographicTransform.WKT">
            <summary>
            Returns the Well-known text for this object
            as defined in the simple features specification. [NOT IMPLEMENTED].
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.GeographicTransform.XML">
            <summary>
            Gets an XML representation of this object [NOT IMPLEMENTED].
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IVerticalCoordinateSystem">
            <summary>
            A one-dimensional coordinate system suitable for vertical measurements.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IVerticalCoordinateSystem.VerticalDatum">
            <summary>
            Gets the vertical datum, which indicates the measurement method
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IVerticalCoordinateSystem.VerticalUnit">
            <summary>
            Gets the units used along the vertical axis.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ILocalCoordinateSystem">
            <summary>
            A local coordinate system, with uncertain relationship to the world.
            </summary>
            <remarks>In general, a local coordinate system cannot be related to other coordinate 
            systems. However, if two objects supporting this interface have the same dimension, 
            axes, units and datum then client code is permitted to assume that the two coordinate
            systems are identical. This allows several datasets from a common source (e.g. a CAD
            system) to be overlaid. In addition, some implementations of the Coordinate 
            Transformation (CT) package may have a mechanism for correlating local datums. (E.g. 
            from a database of transformations, which is created and maintained from real-world 
            measurements.)
            </remarks>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.ILocalCoordinateSystem.LocalDatum">
            <summary>
            Gets or sets the local datum
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeographicCoordinateSystem">
            <summary>
            The IGeographicCoordinateSystem interface is a subclass of IGeodeticSpatialReference and
            defines the standard information stored with geographic coordinate system objects.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeographicCoordinateSystem.GetWgs84ConversionInfo(System.Int32)">
            <summary>
            Gets details on a conversion to WGS84.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeographicCoordinateSystem.AngularUnit">
            <summary>
            Gets or sets the angular units of the geographic coordinate system.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeographicCoordinateSystem.PrimeMeridian">
            <summary>
            Gets or sets the prime meridian of the geographic coordinate system.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeographicCoordinateSystem.NumConversionToWGS84">
            <summary>
            Gets the number of available conversions to WGS84 coordinates.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Ellipsoid">
            <summary>
            The IEllipsoid interface defines the standard information stored with ellipsoid objects.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Ellipsoid.#ctor(System.Double,System.Double,System.Double,System.Boolean,MapWinGeoProc.NTS.Topology.CoordinateSystems.ILinearUnit,System.String,System.String,System.Int64,System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of an Ellipsoid
            </summary>
            <param name="semiMajorAxis">Semi major axis</param>
            <param name="semiMinorAxis">Semi minor axis</param>
            <param name="inverseFlattening">Inverse flattening</param>
            <param name="isIvfDefinitive">Inverse Flattening is definitive for this ellipsoid (Semi-minor axis will be overridden)</param>
            <param name="axisUnit">Axis unit</param>
            <param name="name">Name</param>
            <param name="authority">Authority name</param>
            <param name="code">Authority-specific identification code.</param>
            <param name="alias">Alias</param>
            <param name="abbreviation">Abbreviation</param>
            <param name="remarks">Provider-supplied remarks</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Ellipsoid.EqualParams(System.Object)">
            <summary>
            Checks whether the values of this instance is equal to the values of another instance.
            Only parameters used for coordinate system are used for comparison.
            Name, abbreviation, authority, alias and remarks are ignored in the comparison.
            </summary>
            <param name="obj"></param>
            <returns>True if equal</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Ellipsoid.WGS84">
            <summary>
            WGS 84 ellipsoid
            </summary>
            <remarks>
            Inverse flattening derived from four defining parameters 
            (semi-major axis;
            C20 = -484.16685*10e-6;
            earth's angular velocity w = 7292115e11 rad/sec;
            gravitational constant GM = 3986005e8 m*m*m/s/s).
            </remarks>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Ellipsoid.WGS72">
            <summary>
            WGS 72 Ellipsoid
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Ellipsoid.GRS80">
            <summary>
            GRS 1980 / International 1979 ellipsoid
            </summary>
            <remarks>
            Adopted by IUGG 1979 Canberra.
            Inverse flattening is derived from
            geocentric gravitational constant GM = 3986005e8 m*m*m/s/s;
            dynamic form factor J2 = 108263e8 and Earth's angular velocity = 7292115e-11 rad/s.")
            </remarks>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Ellipsoid.International1924">
            <summary>
            International 1924 / Hayford 1909 ellipsoid
            </summary>
            <remarks>
            Described as a=6378388 m. and b=6356909m. from which 1/f derived to be 296.95926. 
            The figure was adopted as the International ellipsoid in 1924 but with 1/f taken as
            297 exactly from which b is derived as 6356911.946m.
            </remarks>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Ellipsoid.Clarke1880">
            <summary>
            Clarke 1880
            </summary>
            <remarks>
            Clarke gave a and b and also 1/f=293.465 (to 3 decimal places).  1/f derived from a and b = 293.4663077
            </remarks>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Ellipsoid.Clarke1866">
            <summary>
            Clarke 1866
            </summary>
            <remarks>
            Original definition a=20926062 and b=20855121 (British) feet. Uses Clarke's 1865 inch-metre ratio of 39.370432 to obtain metres. (Metric value then converted to US survey feet for use in the United States using 39.37 exactly giving a=20925832.16 ft US).
            </remarks>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Ellipsoid.Sphere">
            <summary>
            Sphere
            </summary>
            <remarks>
            Authalic sphere derived from GRS 1980 ellipsoid (code 7019).  (An authalic sphere is
            one with a surface area equal to the surface area of the ellipsoid). 1/f is infinite.
            </remarks>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Ellipsoid.SemiMajorAxis">
            <summary>
            Gets or sets the value of the semi-major axis.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Ellipsoid.SemiMinorAxis">
            <summary>
            Gets or sets the value of the semi-minor axis.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Ellipsoid.InverseFlattening">
            <summary>
            Gets or sets the value of the inverse of the flattening constant of the ellipsoid.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Ellipsoid.AxisUnit">
            <summary>
            Gets or sets the value of the axis unit.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Ellipsoid.IsIvfDefinitive">
            <summary>
            Tells if the Inverse Flattening is definitive for this ellipsoid. Some ellipsoids use 
            the IVF as the defining value, and calculate the polar radius whenever asked. Other
            ellipsoids use the polar radius to calculate the IVF whenever asked. This 
            distinction can be important to avoid floating-point rounding errors.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Ellipsoid.WKT">
            <summary>
            Returns the Well-known text for this object
            as defined in the simple features specification.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Ellipsoid.XML">
            <summary>
            Gets an XML representation of this object
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.NonRobustLineIntersector">
            <summary> 
            A non-robust version of <c>LineIntersector</c>.
            </summary>   
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.NonRobustLineIntersector.IsSameSignAndNonZero(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns> 
            <c>true</c> if both numbers are positive or if both numbers are negative, 
            <c>false</c> if both numbers are zero.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.NonRobustLineIntersector.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.NonRobustLineIntersector.ComputeIntersection(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="p"></param>
            <param name="p1"></param>
            <param name="p2"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.NonRobustLineIntersector.ComputeIntersect(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="p3"></param>
            <param name="p4"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.NonRobustLineIntersector.ComputeCollinearIntersection(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="p3"></param>
            <param name="p4"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.NonRobustLineIntersector.RParameter(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary> 
            RParameter computes the parameter for the point p
            in the parameterized equation
            of the line from p1 to p2.
            This is equal to the 'distance' of p along p1-p2.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.ConvexHull">
            <summary> 
            Computes the convex hull of a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>.
            The convex hull is the smallest convex Geometry that contains all the
            points in the input Geometry.
            Uses the Graham Scan algorithm.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.ConvexHull.#ctor(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary> 
            Create a new convex hull construction for the input <c>Geometry</c>.
            </summary>
            <param name="geometry"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.ConvexHull.#ctor(MapWindow.Interfaces.Geometries.ICoordinate[],MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            Create a new convex hull construction for the input <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> array.
            </summary>
            <param name="pts"></param>
            <param name="geomFactory"></param>   
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.ConvexHull.ExtractCoordinates(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.ConvexHull.GetConvexHull">
            <summary> 
            Returns a <c>Geometry</c> that represents the convex hull of the input point.
            The point will contain the minimal number of points needed to
            represent the convex hull.  In particular, no more than two consecutive
            points will be collinear.
            </summary>
            <returns> 
            If the convex hull contains 3 or more points, a <c>Polygon</c>;
            2 points, a <c>LineString</c>;
            1 point, a <c>Point</c>;
            0 points, an empty <c>GeometryCollection</c>.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.ConvexHull.Reduce(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Uses a heuristic to reduce the number of points scanned to compute the hull.
            The heuristic is to find a polygon guaranteed to
            be in (or on) the hull, and eliminate all points inside it.
            A quadrilateral defined by the extremal points
            in the four orthogonal directions
            can be used, but even more inclusive is
            to use an octilateral defined by the points in the 8 cardinal directions.
            Note that even if the method used to determine the polygon vertices
            is not 100% robust, this does not affect the robustness of the convex hull.
            </summary>
            <param name="pts"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.ConvexHull.PreSort(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            
            </summary>
            <param name="pts"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.ConvexHull.GrahamScan(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            
            </summary>
            <param name="c"></param>
            <returns></returns>        
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.ConvexHull.ReverseStack(System.Collections.Generic.Stack{MapWindow.Interfaces.Geometries.ICoordinate})">
            <summary>
            
            </summary>
            <param name="ps"></param>
            <returns></returns>    
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.ConvexHull.IsBetween(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="c1"></param>
            <param name="c2"></param>
            <param name="c3"></param>
            <returns>
            Whether the three coordinates are collinear 
            and c2 lies between c1 and c3 inclusive.
            </returns>        
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.ConvexHull.ComputeOctRing(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            
            </summary>
            <param name="inputPts"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.ConvexHull.ComputeOctPts(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            
            </summary>
            <param name="inputPts"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.ConvexHull.LineOrPolygon(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            
            </summary>
            <param name="coordinates"> The vertices of a linear ring, which may or may not be flattened (i.e. vertices collinear).</param>
            <returns>A 2-vertex <c>LineString</c> if the vertices are collinear; 
            otherwise, a <c>Polygon</c> with unnecessary (collinear) vertices removed. </returns>       
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.ConvexHull.CleanRing(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            
            </summary>
            <param name="original">The vertices of a linear ring, which may or may not be flattened (i.e. vertices collinear).</param>
            <returns>The coordinates with unnecessary (collinear) vertices removed.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.ConvexHull.RadialComparator">
            <summary>
            Compares <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/>s for their angle and distance
            relative to an origin.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.ConvexHull.RadialComparator.#ctor(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Initializes a new instance of the <see cref="T:MapWinGeoProc.NTS.Topology.Algorithm.ConvexHull.RadialComparator"/> class.
            </summary>
            <param name="origin"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.ConvexHull.RadialComparator.Compare(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.ConvexHull.RadialComparator.PolarCompare(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="o"></param>
            <param name="p"></param>
            <param name="q"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.ImageAnalysis">
            <summary>
            Contains static functions for image transforms, especially filters
            </summary>
        </member>
        <member name="M:MapWinGeoProc.ImageAnalysis.ApplyFilter(System.String,System.String,System.Single[0:,0:],System.Boolean,MapWinGIS.ICallback)">
            <summary>
            Will convolve the 2-D filter with the source image, producing the output image.
            This overload assumes that you are working with files.
            </summary>
            <param name="SourceFile">A string representing the image file to open.</param>
            <param name="DestFile">A string representing the image file to save to.</param>
            <param name="filter">A 2D array of floats, row major.  Filter must be smaller than image.</param>
            <param name="ShowProgressDialog">Boolean, true to have the function automatically show a dialog.</param>
            <param name="ICallBack">A MapWinGIS.ICallback for handling errors and progress messages</param>
            <returns>Boolean, false if the process was canceled.</returns>
        </member>
        <member name="M:MapWinGeoProc.ImageAnalysis.ApplyFilter(System.String,System.String,System.Single[0:,0:])">
             <summary>
             Will convolve the 2-D filter with the source image, producing the output image.
             This overload assumes that you are working with files.
             </summary>
            <param name="SourceFile">A string representing the image file to open.</param>
             <param name="DestFile">A string representing the image file to save to.</param>
             <param name="filter">A 2D array of floats, row major.  Filter must be smaller than image.</param>
             <returns>Boolean, false if the process was canceled.</returns>
        </member>
        <member name="M:MapWinGeoProc.ImageAnalysis.ApplyFilter(MapWinGIS.Image,MapWinGIS.Image@,System.Single[0:,0:],System.Boolean,MapWinGIS.ICallback)">
            <summary>
            Will convolve the SourceImage specified using the filter specified, returning the result in a new image
            as the ref parameter DestImage.  
            </summary>
            <param name="SourceImage">A MapWinGIS.Image object to be processed</param>
            <param name="DestImage">The output MapWinGIS.Image object from this process</param>
            <param name="filter">The 2D float array of filter coefficients to use (Row Major)</param>
            <param name="ShowProgressDialog">If true, will show progress in a typical dialog form</param>
            <param name="ICallBack">If specified, will return data as a MapWinGIS.ICallBack object</param>
            <returns>Boolean, false if the process was canceled.</returns>
        </member>
        <member name="M:MapWinGeoProc.ImageAnalysis.ApplyFilter(MapWinGIS.Image,MapWinGIS.Image@,System.Single[0:,0:])">
            <summary>
            Will convolve the SourceImage specified using the filter specified, returning the result in a new image
            as the ref parameter DestImage.  
            </summary>
            <param name="SourceImage">A MapWinGIS.Image object to be processed</param>
            <param name="DestImage">The output MapWinGIS.Image object from this process</param>
            <param name="filter">The 2D float array of filter coefficients to use (Row Major)</param>
            <returns>Boolean, false if the process was canceled.</returns>
        </member>
        <member name="M:MapWinGeoProc.ImageAnalysis.Difference(MapWinGIS.Grid,MapWinGIS.Grid,MapWinGIS.Grid,MapWinGIS.ICallback)">
            <summary>
            Calculates the difference values and stores them in the Dest grid.  This only works if the grids
            have the same number of rows and columns.
            </summary>
            <param name="Source1">MapWinGIS.Grid representing one source grid</param>
            <param name="Source2">MapWinGIS.Grid to compare Source1 against</param>
            <param name="Dest">MapWinGIS.Grid where the output is to be saved</param>
            <param name="ICallBack">A MapWinGIS.ICallBack</param>
            <remarks>Uses ArgumentExceptions if the grids are different sizes</remarks>
        </member>
        <member name="M:MapWinGeoProc.ImageAnalysis.Difference(System.String,System.String,System.String,System.Boolean,MapWinGIS.ICallback)">
            <summary>
            This overload calculates the difference between files.  THe number of rows and columns should be the same.
            </summary>
            <param name="SourceFile1">String filename of one grid to compare</param>
            <param name="SourceFile2">String filename of another grid to compare</param>
            <param name="DestFile">String filename of the output difference file</param>
            <param name="Overwrite">Boolean, true if you wish to overwrite an existing output 
            file and delete the associated .bmp file.  False raises a messagebox if the files exist.</param>
            <param name="ICallBack">A MapWinGIS.ICallBack for status messages</param>
        </member>
        <member name="T:MapWinGeoProc.Compatibility.Convert">
            <summary>
            Converts types form MapWinGIS format to MapWindow.Interfaces format
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Convert.GetGridDataType(MapWinGIS.GridDataType)">
            <summary>
            Returns a MapWindow.Interfaces.Types.GridDataType that corresponds to a MapWinGIs.GridDataType
            </summary>
            <param name="MapWinGIS_GridDataType">A MapWinGIS.GridDataType</param>
            <returns>A MapWindow.Interfaces.Types.GridDataType</returns>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Convert.GetGridFileType(MapWinGIS.GridFileType)">
            <summary>
            Returns a new MapWindow.Interfaces.Types.GridFileType that corresponds to the
            older MapWinGIS.GridFileType
            </summary>
            <param name="MapWinGIS_GridFileType">A MapWinGIS.GridFileType</param>
            <returns>A MapWindow.Interfaces.Types.GridFileType</returns>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Convert.mwGridDataType(MapWindow.Interfaces.Raster.GridDataType)">
            <summary>
            Converts a new MapWindow.Interfaces.Types.GridDataType to an older MapWinGIS.GridDataType format
            </summary>
            <param name="Types_GridDataType">A Mapwindow.Interfaces.Types.GridDataType</param>
            <returns>A MapWinGIS.GridDataType</returns>
        </member>
        <member name="M:MapWinGeoProc.Compatibility.Convert.mwGridFileType(MapWindow.Interfaces.Raster.GridFileType)">
            <summary>
            Converts a newer Mapwindow.Interfaces.Types.GridFileType to an older
            MapWinGIS.GridFileType
            </summary>
            <param name="Types_GridFileType">A MapWindow.Interfaces.Types.GridFileType</param>
            <returns>A MapWinGIS.GridFiletype</returns>
        </member>
        <member name="M:MapWinGeoProc.Rasterization.Rasterizer.Poly2Grid(MapWinGIS.Shapefile,System.Int32,MapWinGIS.Grid,MapWinGIS.GridHeader,MapWinGIS.GridDataType,MapWinGIS.ICallback)">
            <summary>
            This function converts a polygon shapefile to grid. It implements the line-scan algorithm.
            <param name="PolySf">The polygon shapefile</param>
            <param name="FldID">The field index</param>
            <param name="Newgrd">File name of the new grid</param>
            <param name="header">Header object of the new grid</param>
            <param name="grType">Grid data type</param>
            <param name="cback">can be used to report progress (optional)</param>
            <returns>true if successful</returns>
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Rasterization.Rasterizer.FirstLineXY(System.Double,System.Double,System.Double,System.Int32)">
            <summary>
            'return the closest line referring to the grid extention
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Rasterization.Rasterizer.IsGridContainsShape(MapWinGIS.Shape,MapWinGIS.GridHeader)">
            <summary>
            determine if the shape is partially inside grid extents
            </summary>
            <param name="shp"></param>
            <param name="hdr"></param>
            <returns>false, if the shape is completely outside grid extents
                     true, if it's at least partially inside</returns>
        </member>
        <member name="M:MapWinGeoProc.Rasterization.Rasterizer.Interseca(System.Collections.ArrayList,System.Collections.ArrayList,System.Double)">
            <summary>
            Creates a list of all intersections between the vertical line-scan and polygon's borders
            </summary>
            <param name="bordi2">The list of polygon borders</param>
            <param name="intersezioni">The list of intersections</param>
            <param name="xls">The line-scan x-value</param>
        </member>
        <member name="M:MapWinGeoProc.Rasterization.Rasterizer.ScanLine(System.Collections.ArrayList,System.Double,System.Collections.ArrayList,MapWinGIS.GridHeader,System.Object,MapWinGIS.ICallback)">
            <summary>
            populate all the grid cells between two consecutive intersections with shape's value
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Rasterization.Rasterizer.Line2Grid(MapWinGIS.Shapefile,System.Int32,MapWinGIS.Grid,MapWinGIS.GridHeader,MapWinGIS.GridDataType,MapWinGIS.ICallback)">
            <summary>
            converts a Line shapefile to grid using Bresenham algorithm
            </summary>
            <param name="LineSf">Polyline shapefile object</param>
            <param name="FldID">Field index</param>
            <param name="Newgrd">New grid object</param>
            <param name="header">Grid header</param>
            <param name="grType">Grid data type</param>
            <param name="cback">optional, for reporting progress</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:MapWinGeoProc.Rasterization.Rasterizer.RasterizePolyline(System.Collections.ArrayList,System.Collections.ArrayList)">
            <summary>
            implements the Bresenham's line algorithm
            </summary>
            <param name="vertices">ArrayList of points (shape2grid.pixel struct) in grid coordinates</param>
            <param name="gridPixels">ArrayList of pixels on the rasterized line</param>
        </member>
        <member name="M:MapWinGeoProc.Rasterization.Rasterizer.Point2Grid(MapWinGIS.Shapefile,System.Int32,MapWinGIS.Grid,MapWinGIS.GridHeader,MapWinGIS.GridDataType,MapWinGIS.ICallback)">
            <summary>
            Converts a point shapefile to grid
            </summary>
            <param name="PointSf">Point shapefile object</param>
            <param name="FldID">Index of field that contains data</param>
            <param name="Newgrd">The new grid object</param>
            <param name="header">The grid header object</param>
            <param name="grType">The grid data type</param>
            <param name="cback">(optional) callback object for reporting progress</param>
            <returns>False when error encountered, true otherwise</returns>
        </member>
        <member name="M:MapWinGeoProc.Rasterization.Rasterizer.Multipoint2Grid(MapWinGIS.Shapefile,System.Int32,MapWinGIS.Grid,MapWinGIS.GridHeader,MapWinGIS.GridDataType,MapWinGIS.ICallback)">
            <summary>
            Converts a multipoint shapefile to grid
            </summary>
            <param name="MultipointSf">Multipoint shapefile object</param>
            <param name="FldID">Index of field that contains data</param>
            <param name="Newgrd">The new grid object</param>
            <param name="header">Grid header object</param>
            <param name="grType">Data type of the new grid</param>
            <param name="cback">optional object for reporting progress</param>
            <returns>False in case of error, true otherwise</returns>
        </member>
        <member name="M:MapWinGeoProc.Rasterization.Rasterizer.writePx(MapWinGIS.Grid,MapWinGIS.GridDataType,MapWinGeoProc.Rasterization.Rasterizer.GridPixel,System.Object,MapWinGIS.ICallback)">
            <summary>
            writes a single grid pixel
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Rasterization.Rasterizer.writePxList(MapWinGIS.Grid,MapWinGIS.GridDataType,System.Collections.ArrayList,System.Object,MapWinGIS.ICallback)">
            <summary>
            writes the pixel values from arrayList to grid
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Rasterization.Rasterizer.GetCellValue(MapWinGIS.Shapefile,System.Int32,System.Int32,System.Object)">
            <summary>
            returns the shape's attribute field value
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Rasterization.Rasterizer.reportProgress(System.Int32,System.Int32,System.String,MapWinGIS.ICallback)">
            <summary>
            reports the progress
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Rasterization.Rasterizer.reportError(System.String,MapWinGIS.ICallback)">
            <summary>
            reports an error
            </summary>
        </member>
        <member name="T:KDTreeDLL.KeySizeException">
            <summary>
            KeySizeException is thrown when a KDTree method is invoked on a
            key whose size (array length) mismatches the one used in the that
            KDTree's constructor.
            
            @author Simon Levy
            Translation by Marco A. Alvarez
            </summary> 
        </member>
        <member name="M:KDTreeDLL.KeySizeException.#ctor">
            <summary>
            KeySizeException
            </summary>
        </member>
        <member name="T:KDTreeDLL.KeyMissingException">
            <summary>
            Key-size mismatch exception supporting KDTree class
            
            @author Simon Levy
            Translation by Marco A. Alvarez
            </summary> 
        </member>
        <member name="M:KDTreeDLL.KeyMissingException.#ctor">
            <summary>
            KeyMissing Exception
            </summary>
        </member>
        <member name="T:RTools.Util.Logger">
            <summary>
            This is a simple implementation of a Logger class.
            The purpose is to threshold output based on a verbosity setting,
            format messages similarly, and collect all message writes such that
            they can be redirected easily.  You (and I) should probably use
            the some other library for this, but I haven't found one that suits
            my needs.
            </summary>
            <remarks>
            This doesn't implement much of the functionality possible
            with this interface.  This could redirect messages to other
            text writers, forward messages to subscribers, etc.
            </remarks>
        </member>
        <member name="F:RTools.Util.Logger.log">
            <summary>Backer for Log.</summary>
        </member>
        <member name="F:RTools.Util.Logger.name">
            <summary>The name is prepended to all messages. </summary>
        </member>
        <member name="F:RTools.Util.Logger.verbosity">
            <summary>
            The verbosity of this logger.  Messages are filtered
            based on this setting.
            </summary>
        </member>
        <member name="M:RTools.Util.Logger.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:RTools.Util.Logger.#ctor(System.String)">
            <summary>
            Construct and set name.
            </summary>
            <param name="name">The name for this logger.  This name
            is prepended to output messages (except Out messages).</param>
        </member>
        <member name="M:RTools.Util.Logger.Write(System.String,System.Object[])">
            <summary>
            Write a string with no verbosity checking and no formatting.
            </summary>
            <param name="msg">The format string.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:RTools.Util.Logger.WriteLine(System.String,System.Object[])">
            <summary>
            Write a line with no verbosity checking and no formatting.
            </summary>
            <param name="msg">The format string.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:RTools.Util.Logger.Debug(System.String,System.Object[])">
            <summary>
            Write a string of this particular verbosity.
            This will not output the string unless the verbosity is
            greater than or equal to this object's threshold.
            This prepends the level of the message and
            the name of this Logger.
            </summary>
            <param name="msg">The format string.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:RTools.Util.Logger.Info(System.String,System.Object[])">
            <summary>
            Write a string of this particular verbosity.
            This will not output the string unless the verbosity is
            greater than or equal to this object's threshold.
            This prepends the level of the message and
            the name of this Logger.
            </summary>
            <param name="msg">The format string.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:RTools.Util.Logger.Warn(System.String,System.Object[])">
            <summary>
            Write a string of this particular verbosity.
            This will not output the string unless the verbosity is
            greater than or equal to this object's threshold.
            This prepends the level of the message and
            the name of this Logger.
            </summary>
            <param name="msg">The format string.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:RTools.Util.Logger.Error(System.String,System.Object[])">
            <summary>
            Write a string of this particular verbosity.
            This will not output the string unless the verbosity is
            greater than or equal to this object's threshold.
            This prepends the level of the message and
            the name of this Logger.
            </summary>
            <param name="msg">The format string.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:RTools.Util.Logger.TestSelf">
            <summary>
            A simple static self test method.
            </summary>
            <returns>bool - currently always true</returns>
        </member>
        <member name="P:RTools.Util.Logger.Log">
            <summary>
            A static instance you can use without creating your own.
            </summary>
        </member>
        <member name="P:RTools.Util.Logger.Verbosity">
            <summary>
            The verbosity of this logger.  Messages are filtered
            based on this setting.
            </summary>
        </member>
        <member name="T:Iesi.Collections.SynchronizedSet">
            <summary>
            <p>Implements a thread-safe <c>Set</c> wrapper.  The implementation is extremely conservative, 
            serializing critical sections to prevent possible deadlocks, and locking on everything.
            The one exception is for enumeration, which is inherently not thread-safe.  For this, you
            have to <c>lock</c> the <c>SyncRoot</c> object for the duration of the enumeration.</p>
            </summary>
        </member>
        <member name="M:Iesi.Collections.SynchronizedSet.#ctor(Iesi.Collections.ISet)">
            <summary>
            Constructs a thread-safe <c>Set</c> wrapper.
            </summary>
            <param name="basisSet">The <c>Set</c> object that this object will wrap.</param>
        </member>
        <member name="M:Iesi.Collections.SynchronizedSet.Add(System.Object)">
            <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
            <param name="o">The object to add to the set.</param>
            <returns><c>true</c> is the object was added, <c>false</c> if it was already present.</returns>
        </member>
        <member name="M:Iesi.Collections.SynchronizedSet.AddAll(System.Collections.ICollection)">
            <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
            <param name="c">A collection of objects to add to the set.</param>
            <returns><c>true</c> is the set changed as a result of this operation, <c>false</c> if not.</returns>
        </member>
        <member name="M:Iesi.Collections.SynchronizedSet.Clear">
            <summary>
            Removes all objects from the set.
            </summary>
        </member>
        <member name="M:Iesi.Collections.SynchronizedSet.Contains(System.Object)">
            <summary>
            Returns <c>true</c> if this set contains the specified element.
            </summary>
            <param name="o">The element to look for.</param>
            <returns><c>true</c> if this set contains the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.SynchronizedSet.ContainsAll(System.Collections.ICollection)">
            <summary>
            Returns <c>true</c> if the set contains all the elements in the specified collection.
            </summary>
            <param name="c">A collection of objects.</param>
            <returns><c>true</c> if the set contains all the elements in the specified collection, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.SynchronizedSet.Remove(System.Object)">
            <summary>
            Removes the specified element from the set.
            </summary>
            <param name="o">The element to be removed.</param>
            <returns><c>true</c> if the set contained the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.SynchronizedSet.RemoveAll(System.Collections.ICollection)">
            <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
            <param name="c">A collection of elements to remove.</param>
            <returns><c>true</c> if the set was modified as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.SynchronizedSet.RetainAll(System.Collections.ICollection)">
            <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
            <param name="c">Collection that defines the set of elements to be retained.</param>
            <returns><c>true</c> if this set changed as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.SynchronizedSet.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements in the <c>Set</c> to an array.  The type of array needs
            to be compatible with the objects in the <c>Set</c>, obviously.
            </summary>
            <param name="array">An array that will be the target of the copy operation.</param>
            <param name="index">The zero-based index where copying will start.</param>
        </member>
        <member name="M:Iesi.Collections.SynchronizedSet.GetEnumerator">
            <summary>
            Enumeration is, by definition, not thread-safe.  Use a <c>lock</c> on the <c>SyncRoot</c> 
            to synchronize the entire enumeration process.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Iesi.Collections.SynchronizedSet.Clone">
            <summary>
            Returns a clone of the <c>Set</c> instance.  
            </summary>
            <returns>A clone of this object.</returns>
        </member>
        <member name="P:Iesi.Collections.SynchronizedSet.IsEmpty">
            <summary>
            Returns <c>true</c> if this set contains no elements.
            </summary>
        </member>
        <member name="P:Iesi.Collections.SynchronizedSet.Count">
            <summary>
            The number of elements contained in this collection.
            </summary>
        </member>
        <member name="P:Iesi.Collections.SynchronizedSet.IsSynchronized">
            <summary>
            Returns <c>true</c>, indicating that this object is thread-safe.  The exception to this
            is enumeration, which is inherently not thread-safe.  Use the <c>SyncRoot</c> object to
            lock this object for the entire duration of the enumeration.
            </summary>
        </member>
        <member name="P:Iesi.Collections.SynchronizedSet.SyncRoot">
            <summary>
            Returns an object that can be used to synchronize the <c>Set</c> between threads.
            </summary>
        </member>
        <member name="T:Iesi.Collections.HybridSet">
            <summary>
            Implements a <c>Set</c> that automatically changes from a list to a hash table
            when the size reaches a certain threshold.  This is good if you are unsure about
            whether you data-set will be tiny or huge.  Because this uses a dual implementation,
            iteration order is not guaranteed!
            </summary>
        </member>
        <member name="M:Iesi.Collections.HybridSet.#ctor">
            <summary>
            Creates a new set instance based on either a list or a hash table, depending on which 
            will be more efficient based on the data-set size.
            </summary>
        </member>
        <member name="M:Iesi.Collections.HybridSet.#ctor(System.Collections.ICollection)">
            <summary>
            Creates a new set instance based on either a list or a hash table, depending on which 
            will be more efficient based on the data-set size, and
            initializes it based on a collection of elements.
            </summary>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Simplify.DouglasPeuckerLineSimplifier">
            <summary>
            Simplifies a line (sequence of points) using
            the standard Douglas-Peucker algorithm.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.DouglasPeuckerLineSimplifier.Simplify(MapWindow.Interfaces.Geometries.ICoordinate[],System.Double)">
            <summary>
            
            </summary>
            <param name="pts"></param>
            <param name="distanceTolerance"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.DouglasPeuckerLineSimplifier.#ctor(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            
            </summary>
            <param name="pts"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.DouglasPeuckerLineSimplifier.Simplify">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.DouglasPeuckerLineSimplifier.SimplifySection(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <param name="j"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Simplify.DouglasPeuckerLineSimplifier.DistanceTolerance">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Precision.CommonBits">
            <summary> 
            Determines the maximum number of common most-significant
            bits in the mantissa of one or numbers.
            Can be used to compute the double-precision number which
            is represented by the common bits.
            If there are no common bits, the number computed is 0.0.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBits.SignExpBits(System.Int64)">
            <summary>
            Computes the bit pattern for the sign and exponent of a
            double-precision number.
            </summary>
            <param name="num"></param>
            <returns>The bit pattern for the sign and exponent.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBits.NumCommonMostSigMantissaBits(System.Int64,System.Int64)">
            <summary>
            This computes the number of common most-significant bits in the mantissas
            of two double-precision numbers.
            It does not count the hidden bit, which is always 1.
            It does not determine whether the numbers have the same exponent - if they do
            not, the value computed by this function is meaningless.
            </summary>
            <param name="num1"></param>
            /// <param name="num2"></param>
            <returns>The number of common most-significant mantissa bits.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBits.ZeroLowerBits(System.Int64,System.Int32)">
            <summary>
            Zeroes the lower n bits of a bitstring.
            </summary>
            <param name="bits">The bitstring to alter.</param>
            <param name="nBits">the number of bits to zero.</param>
            <returns>The zeroed bitstring.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBits.GetBit(System.Int64,System.Int32)">
            <summary>
            Extracts the i'th bit of a bitstring.
            </summary>
            <param name="bits">The bitstring to extract from.</param>
            <param name="i">The bit to extract.</param>
            <returns>The value of the extracted bit.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBits.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBits.Add(System.Double)">
            <summary>
            
            </summary>
            <param name="num"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Precision.CommonBits.ToString(System.Int64)">
            <summary>
            A representation of the Double bits formatted for easy readability
            </summary>
            <param name="bits"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Precision.CommonBits.Common">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdgeStar">
            <summary>
            A sorted collection of <c>DirectedEdge</c>s which leave a <c>Node</c>
            in a <c>PlanarGraph</c>.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdgeStar.outEdges">
            <summary>
            The underlying list of outgoing DirectedEdges.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdgeStar.#ctor">
            <summary>
            Constructs a DirectedEdgeStar with no edges.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdgeStar.Add(MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge)">
            <summary>
            Adds a new member to this DirectedEdgeStar.
            </summary>
            <param name="de"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdgeStar.Remove(MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge)">
            <summary>
            Drops a member of this DirectedEdgeStar.
            </summary>
            <param name="de"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdgeStar.GetEnumerator">
            <summary>
            Returns an Iterator over the DirectedEdges, in ascending order by angle with the positive x-axis.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdgeStar.SortEdges">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdgeStar.GetIndex(MapWinGeoProc.NTS.Topology.Planargraph.Edge)">
            <summary>
            Returns the zero-based index of the given Edge, after sorting in ascending order
            by angle with the positive x-axis.
            </summary>
            <param name="edge"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdgeStar.GetIndex(MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge)">
            <summary>
            Returns the zero-based index of the given DirectedEdge, after sorting in ascending order
            by angle with the positive x-axis.
            </summary>
            <param name="dirEdge"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdgeStar.GetIndex(System.Int32)">
            <summary> 
            Returns the remainder when i is divided by the number of edges in this
            DirectedEdgeStar. 
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdgeStar.GetNextEdge(MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdge)">
            <summary>
            Returns the DirectedEdge on the left-hand side of the given DirectedEdge (which
            must be a member of this DirectedEdgeStar). 
            </summary>
            <param name="dirEdge"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdgeStar.Degree">
            <summary>
            Returns the number of edges around the Node associated with this DirectedEdgeStar.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdgeStar.Coordinate">
            <summary>
            Returns the coordinate for the node at wich this star is based.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.DirectedEdgeStar.Edges">
            <summary>
            Returns the DirectedEdges, in ascending order by angle with the positive x-axis.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateNodeGraph">
            <summary>
            Implements the simple graph of Nodes and EdgeEnd which is all that is
            required to determine topological relationships between Geometries.
            Also supports building a topological graph of a single Geometry, to
            allow verification of valid topology.    
            It is not necessary to create a fully linked
            PlanarGraph to determine relationships, since it is sufficient
            to know how the Geometries interact locally around the nodes.
            In fact, this is not even feasible, since it is not possible to compute
            exact intersection points, and hence the topology around those nodes
            cannot be computed robustly.
            The only Nodes that are created are for improper intersections;
            that is, nodes which occur at existing vertices of the Geometries.
            Proper intersections (e.g. ones which occur between the interior of line segments)
            have their topology determined implicitly, without creating a Node object
            to represent them.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateNodeGraph.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateNodeGraph.GetNodeEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateNodeGraph.Build(MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            
            </summary>
            <param name="geomGraph"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateNodeGraph.ComputeIntersectionNodes(MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph,System.Int32)">
            <summary>
            Insert nodes for all intersections on the edges of a Geometry.
            Label the created nodes the same as the edge label if they do not already have a label.
            This allows nodes created by either self-intersections or
            mutual intersections to be labelled.
            Endpoint nodes will already be labelled from when they were inserted.
            Precondition: edge intersections have been computed.
            </summary>
            <param name="geomGraph"></param>
            <param name="argIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateNodeGraph.CopyNodesAndLabels(MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph,System.Int32)">
            <summary>
            Copy all nodes from an arg point into this graph.
            The node label in the arg point overrides any previously computed
            label for that argIndex.
            (E.g. a node may be an intersection node with
            a computed label of Boundary,
            but in the original arg Geometry it is actually
            in the interior due to the Boundary Determination Rule).
            </summary>
            <param name="geomGraph"></param>
            <param name="argIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateNodeGraph.InsertEdgeEnds(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="ee"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Relate.EdgeEndBundle">
            <summary>
            A collection of EdgeStubs which obey the following invariant:
            They originate at the same node and have the same direction.
            Contains all <c>EdgeEnd</c>s which start at the same point and are parallel.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.EdgeEndBundle.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.EdgeEndBundle.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.EdgeEndBundle.Insert(MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.EdgeEndBundle.ComputeLabel">
            <summary>
            This computes the overall edge label for the set of
            edges in this EdgeStubBundle.  It essentially merges
            the ON and side labels for each edge. 
            These labels must be compatible
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.EdgeEndBundle.ComputeLabelOn(System.Int32)">
            <summary>
            Compute the overall ON location for the list of EdgeStubs.
            (This is essentially equivalent to computing the self-overlay of a single Geometry)
            edgeStubs can be either on the boundary (eg Polygon edge)
            OR in the interior (e.g. segment of a LineString)
            of their parent Geometry.
            In addition, GeometryCollections use the mod-2 rule to determine
            whether a segment is on the boundary or not.
            Finally, in GeometryCollections it can still occur that an edge is both
            on the boundary and in the interior (e.g. a LineString segment lying on
            top of a Polygon edge.) In this case as usual the Boundary is given precendence.
            These observations result in the following rules for computing the ON location:
             if there are an odd number of Bdy edges, the attribute is Bdy
             if there are an even number >= 2 of Bdy edges, the attribute is Int
             if there are any Int edges, the attribute is Int
             otherwise, the attribute is Null.
            </summary>
            <param name="geomIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.EdgeEndBundle.ComputeLabelSides(System.Int32)">
            <summary>
            Compute the labelling for each side
            </summary>
            <param name="geomIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.EdgeEndBundle.ComputeLabelSide(System.Int32,MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions)">
            <summary>
            To compute the summary label for a side, the algorithm is:
            FOR all edges
            IF any edge's location is Interior for the side, side location = Interior
            ELSE IF there is at least one Exterior attribute, side location = Exterior
            ELSE  side location = Null
            Note that it is possible for two sides to have apparently contradictory information
            i.e. one edge side may indicate that it is in the interior of a point, while
            another edge side may indicate the exterior of the same point.  This is
            not an incompatibility - GeometryCollections may contain two Polygons that touch
            along an edge.  This is the reason for Interior-primacy rule above - it
            results in the summary label having the Geometry interior on both sides.
            </summary>
            <param name="geomIndex"></param>
            <param name="side"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.EdgeEndBundle.UpdateIM(MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix)">
            <summary>
            Update the IM with the contribution for the computed label for the EdgeStubs.
            </summary>
            <param name="im"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.EdgeEndBundle.Write(System.IO.StreamWriter)">
            <summary>
            
            </summary>
            <param name="outstream"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Relate.EdgeEndBundle.Label">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Relate.EdgeEndBundle.EdgeEnds">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayNodeFactory">
            <summary>
            Creates nodes for use in the <c>PlanarGraph</c>s constructed during
            overlay operations.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.OverlayNodeFactory.CreateNode(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="coord"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.SimpleNoder">
            <summary>
            Nodes a set of <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s by
            performing a brute-force comparison of every segment to every other one.
            This has n^2 performance, so is too slow for use on large numbers of segments.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SimpleNoder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SimpleNoder"/> class.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SimpleNoder.#ctor(MapWinGeoProc.NTS.Topology.Noding.ISegmentIntersector)">
            <summary>
            Initializes a new instance of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SimpleNoder"/> class.
            </summary>
            <param name="segInt"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SimpleNoder.GetNodedSubstrings">
            <summary>
            Returns a <see cref="T:System.Collections.IList"/> of fully noded <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s.
            The <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s have the same context as their parent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SimpleNoder.ComputeNodes(System.Collections.IList)">
            <summary>
            Computes the noding for a collection of <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s.
            Some Noders may add all these nodes to the input <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s;
            others may only add some or none at all.
            </summary>
            <param name="inputSegStrings"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SimpleNoder.ComputeIntersects(MapWinGeoProc.NTS.Topology.Noding.SegmentString,MapWinGeoProc.NTS.Topology.Noding.SegmentString)">
            <summary>
            
            </summary>
            <param name="e0"></param>
            <param name="e1"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.LinearReferencing.ExtractLineByLocation">
            <summary>
            Extracts the subline of a linear <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/> between
            two <see cref="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation"/>s on the line.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.ExtractLineByLocation.Extract(MapWindow.Interfaces.Geometries.IGeometry,MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation,MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation)">
            <summary>
            Computes the subline of a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.LineString"/> between
            two LineStringLocations on the line.
            If the start location is after the end location,
            the computed geometry is reversed.
            </summary>
            <param name="line">The line to use as the baseline.</param>
            <param name="start">The start location.</param>
            <param name="end">The end location.</param>
            <returns>The extracted subline.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.ExtractLineByLocation.#ctor(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Initializes a new instance of the <see cref="T:ExtractLineByLocation"/> class.
            </summary>
            <param name="line"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.ExtractLineByLocation.Extract(MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation,MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation)">
            <summary>
            Extracts a subline of the input.
            If <paramref name="end" /> is minor that <paramref name="start" />,
            the linear geometry computed will be reversed.
            </summary>
            <param name="start">The start location.</param>
            <param name="end">The end location.</param>
            <returns>A linear geometry.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.ExtractLineByLocation.Reverse(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="linear"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.ExtractLineByLocation.ComputeLine(MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation,MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation)">
            <summary>
            Assumes input is valid 
            (e.g. <paramref name="start" /> minor or equals to <paramref name="end" />).
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.ExtractLineByLocation.ComputeLinear(MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation,MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation)">
            <summary>
            Assumes input is valid 
            (e.g. <paramref name="start" /> minor or equals to <paramref name="end" />).
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.ParseException">
            <summary>  
            Thrown by a <c>WKTReader</c> when a parsing problem occurs.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ParseException.#ctor(System.String)">
            <summary>
            Creates a <c>ParseException</c> with the given detail message.
            </summary>
            <param name="message">A description of this <c>ParseException</c>.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ParseException.#ctor(System.Exception)">
            <summary>  
            Creates a <c>ParseException</c> with <c>e</c>s detail message.
            </summary>
            <param name="e">An exception that occurred while a <c>WKTReader</c> was
            parsing a Well-known Text string.</param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.ShapefileDataWriter">
            <summary>
            A simple test class for write a complete (shp, shx and dbf) shapefile structure.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataWriter.GetHeader(MapWinGeoProc.NTS.Topology.Features.Feature,System.Int32)">
            <summary>
            Gets the stub header.
            </summary>
            <param name="feature">The feature.</param>
            <param name="count">The count.</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataWriter.GetHeader(System.String)">
            <summary>
            Gets the header from a dbf file.
            </summary>
            <param name="dbfFile">The DBF file.</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataWriter.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ShapefileDataWriter"/> class.
            </summary>
            <param name="fileName">Name of the file with or without any extension.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataWriter.#ctor(System.String,MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:ShapefileDataWriter"/> class.
            </summary>
            <param name="fileName">File path without any extension</param>
            <param name="geometryFactory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataWriter.Write(System.Collections.IList)">
            <summary>
            Writes the specified feature collection.
            </summary>
            <param name="featureCollection">The feature collection.</param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ShapefileDataWriter.Header">
            <summary>
            Gets or sets the header of the shapefile.
            </summary>
            <value>The header.</value>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ShapefileDataWriter.GeometryFactory">
            <summary>
            Gets or sets the geometry factory.
            </summary>
            <value>The geometry factory.</value>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader">
            <summary>
            Creates a IDataReader that can be used to enumerate through an ESRI shape file.
            </summary>
            <remarks>	
            To create a ShapefileDataReader, use the static methods on the Shapefile class.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.#ctor(System.String,MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory)">
             <summary>
             Initializes a new instance of the ShapefileDataReader class.
             </summary>
             <param name="filename">The shapefile to read (minus the .shp extension)</param>
            <param name="geometryFactory">The GeometryFactory to use.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.NextResult">
            <summary>
            Advances the data reader to the next result, when reading the shapefile.
            </summary>
            <returns>false</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.Close">
            <summary>
            Closes the IDataReader 0bject.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.Read">
            <summary>
            Advances the IDataReader to the next record.
            </summary>
            <returns>true if there are more rows; otherwise, false.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetSchemaTable">
            <summary>
            Returns a DataTable that describes the column metadata of the IDataReader.
            </summary>
            <returns>A DataTable that describes the column metadata.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetInt32(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetValue(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.IsDBNull(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <param name="fieldOffset"></param>
            <param name="buffer"></param>
            <param name="bufferoffset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetByte(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetFieldType(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetDecimal(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetValues(System.Object[])">
            <summary>
            
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetName(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetInt64(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetDouble(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetBoolean(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetGuid(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetDateTime(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetOrdinal(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetDataTypeName(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetFloat(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetData(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <param name="fieldoffset"></param>
            <param name="buffer"></param>
            <param name="bufferoffset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetString(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetChar(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetInt16(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.CultureAwareCompare(System.String,System.String)">
            <summary>
            Implementation specific methods.
            </summary>
            <param name="strA"></param>
            <param name="strB"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.Geometry">
            <summary>
            Return geometry feature of the shapefile.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.RecordsAffected">
            <summary>
            Not applicable for this data reader.
            </summary>
            <value>Always -1 for this data reader.</value>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.IsClosed">
            <summary>
            Gets a value indicating whether the data reader is closed.
            </summary>
            <value>true if the data reader is closed; otherwise, false.</value>
            <remarks>IsClosed and RecordsAffected are the only properties that you can call after the IDataReader is closed.</remarks>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.Depth">
            <summary>
            Always return a value of zero since nesting is not supported.
            </summary>
            <value>The level of nesting.</value>
            <remarks>The outermost table has a depth of zero.</remarks>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.RecordCount">
            <summary>
            Gets the numbers of records in the Shapefile.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.Item(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.Item(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.FieldCount">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.ShapeHeader">
            <summary>
            Gets the header for the Shapefile.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.DbaseHeader">
            <summary>
            Gets the header for the Dbase file.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.ShapefileDataReaderEnumerator">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.ShapefileDataReaderEnumerator.#ctor(MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader)">
            <summary>
            
            </summary>
            <param name="parent"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.ShapefileDataReaderEnumerator.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.ShapefileDataReaderEnumerator.MoveNext">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ShapefileDataReader.ShapefileDataReaderEnumerator.Current">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.GDBWriter">
            <summary>
            Writes features as ESRI GeoDatabase binary format in a SqlServer database,
            and converts this features to <coordinate>Geometry</coordinate> format.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GDBWriter.#ctor">
            <summary> 
            Creates a <coordinate>GDBWriter</coordinate> that creates objects using a basic GeometryFactory.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GDBWriter.Write(MapWinGeoProc.NTS.Topology.Geometries.Geometry)">
            <summary>
            Returns a byte array containing binary data for the given <c>Geometry</c>.
            </summary>
            <param name="geometry"></param>
            <returns>Byte[] data</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GDBWriter.Write(MapWinGeoProc.NTS.Topology.Geometries.Geometry,System.IO.Stream)">
            <summary>
            Writes a <c>Geometry</c> into a given <c>Stream</c>.
            </summary>
            <param name="geometry"></param>
            <param name="stream"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GDBWriter.Writer(MapWinGeoProc.NTS.Topology.Geometries.Geometry,System.IO.BinaryWriter)">
            <summary>
            
            </summary>
            <param name="geometry"></param>
            <param name="writer"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.GDBReader">
            <summary>
            Read features stored as ESRI GeoDatabase binary format in a SqlServer database,
            and converts this features to <coordinate>Geometry</coordinate> format.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GDBReader.#ctor">
            <summary> 
            Creates a <coordinate>GDBReader</coordinate> that creates objects using a basic GeometryFactory.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GDBReader.#ctor(MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory)">
            <summary>  
            Creates a <coordinate>GDBReader</coordinate> that creates objects using the given
            <coordinate>GeometryFactory</coordinate>.
            </summary>
            <param name="factory">The factory used to create <coordinate>Geometry</coordinate>s.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GDBReader.Read(System.IO.Stream)">
            <summary>
            Read VeDEx geometries.
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GDBReader.Read(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.GDBReader.Read(System.Byte[])">
            <summary>
            Read VeDEx geometries.
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Bintree.Root">
            <summary> 
            The root node of a single <c>Bintree</c>.
            It is centred at the origin,
            and does not have a defined extent.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Root.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Root.Insert(MapWinGeoProc.NTS.Topology.Index.Bintree.Interval,System.Object)">
            <summary> 
            Insert an item into the tree this is the root of.
            </summary>
            <param name="itemInterval"></param>
            <param name="item"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Root.InsertContained(MapWinGeoProc.NTS.Topology.Index.Bintree.Node,MapWinGeoProc.NTS.Topology.Index.Bintree.Interval,System.Object)">
            <summary> 
            Insert an item which is known to be contained in the tree rooted at
            the given Node.  Lower levels of the tree will be created
            if necessary to hold the item.
            </summary>
            <param name="tree"></param>
            <param name="itemInterval"></param>
            <param name="item"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Root.IsSearchMatch(MapWinGeoProc.NTS.Topology.Index.Bintree.Interval)">
            <summary>
            The root node matches all searches.
            </summary>
            <param name="interval"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequenceFactory">
            <summary>
            Creates CoordinateSequences represented as an array of Coordinates.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequenceFactory.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequenceFactory.ReadResolve">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequenceFactory.Create(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
             Returns a CoordinateArraySequence based on the given array (the array is not copied).
            </summary>
            <param name="coordinates">the coordinates, which may not be null nor contain null elements.</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequenceFactory.Create(MapWindow.Interfaces.Geometries.ICoordinateSequence)">
            <summary>
            
            </summary>
            <param name="coordSeq"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequenceFactory.Create(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
            <param name="dimension"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.CoordinateArraySequenceFactory.Instance">
            <summary>
            Returns the singleton instance of CoordinateArraySequenceFactory.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeList">
            <summary>
            A EdgeList is a list of Edges.  It supports locating edges
            that are pointwise equals to a target edge.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeList.index">
            <summary>
            An index of the edges, for fast lookup.
            a Quadtree is used, because this index needs to be dynamic
            (e.g. allow insertions after queries).
            An alternative would be to use an ordered set based on the values
            of the edge coordinates.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeList.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeList.Remove(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge)">
            <summary>
            Remove the selected Edge element from the list if present.
            </summary>
            <param name="e">Edge element to remove from list</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeList.Add(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge)">
            <summary> 
            Insert an edge unless it is already in the list.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeList.AddAll(System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="edgeColl"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeList.FindEqualEdge(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge)">
            <summary>
            If there is an edge equal to e already in the list, return it.
            Otherwise return null.
            </summary>
            <param name="e"></param>
            <returns>  
            equal edge, if there is one already in the list,
            null otherwise.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeList.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeList.Get(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeList.FindEdgeIndex(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge)">
            <summary>
            If the edge e is already in the list, return its index.
            </summary>
            <param name="e"></param>
            <returns>  
            Index, if e is already in the list,
            -1 otherwise.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeList.Write(System.IO.StreamWriter)">
            <summary>
            
            </summary>
            <param name="outstream"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeList.Edges">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeList.Item(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdgeStar">
            <summary> 
            A DirectedEdgeStar is an ordered list of outgoing DirectedEdges around a node.
            It supports labelling the edges as well as linking the edges to form both
            MaximalEdgeRings and MinimalEdgeRings.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEndStar">
            <summary>
            A EdgeEndStar is an ordered list of EdgeEnds around a node.
            They are maintained in CCW order (starting with the positive x-axis) around the node
            for efficient lookup and topology building.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEndStar.edgeMap">
            <summary>
            A map which maintains the edges in sorted order around the node.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEndStar.edgeList">
            <summary> 
            A list of all outgoing edges in the result, in CCW order.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEndStar.ptInAreaLocation">
            <summary>
            The location of the point for this star in Geometry i Areas.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEndStar.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEndStar.Insert(MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd)">
            <summary> 
            Insert a EdgeEnd into this EdgeEndStar.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEndStar.InsertEdgeEnd(MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd,System.Object)">
            <summary> 
            Insert an EdgeEnd into the map, and clear the edgeList cache,
            since the list of edges has now changed.
            </summary>
            <param name="e"></param>
            <param name="obj"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEndStar.GetEnumerator">
            <summary>
            Iterator access to the ordered list of edges is optimized by
            copying the map collection to a list.  (This assumes that
            once an iterator is requested, it is likely that insertion into
            the map is complete).
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEndStar.GetNextCW(MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd)">
            <summary>
            
            </summary>
            <param name="ee"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEndStar.ComputeLabelling(MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph[])">
            <summary>
            
            </summary>
            <param name="geom"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEndStar.ComputeEdgeEndLabels">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEndStar.GetLocation(System.Int32,MapWindow.Interfaces.Geometries.ICoordinate,MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph[])">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <param name="p"></param>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEndStar.CheckAreaLabelsConsistent(System.Int32)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEndStar.PropagateSideLabels(System.Int32)">
            <summary>
            
            </summary>
            <param name="geomIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEndStar.FindIndex(MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd)">
            <summary>
            
            </summary>
            <param name="eSearch"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEndStar.Write(System.IO.StreamWriter)">
            <summary>
            
            </summary>
            <param name="outstream"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEndStar.Coordinate">
            <returns>
            The coordinate for the node this star is based at.
            </returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEndStar.Degree">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEndStar.Edges">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEndStar.IsAreaLabelsConsistent">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdgeStar.resultAreaEdgeList">
            <summary> 
            A list of all outgoing edges in the result, in CCW order.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdgeStar.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdgeStar.Insert(MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd)">
            <summary> 
            Insert a directed edge in the list.
            </summary>
            <param name="ee"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdgeStar.GetOutgoingDegree">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdgeStar.GetOutgoingDegree(MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing)">
            <summary>
            
            </summary>
            <param name="er"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdgeStar.GetRightmostEdge">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdgeStar.ComputeLabelling(MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph[])">
            <summary> 
            Compute the labelling for all dirEdges in this star, as well
            as the overall labelling.
            </summary>
            <param name="geom"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdgeStar.MergeSymLabels">
            <summary> 
            For each dirEdge in the star, merge the label .
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdgeStar.UpdateLabelling(MapWinGeoProc.NTS.Topology.GeometriesGraph.Label)">
            <summary> 
            Update incomplete dirEdge labels from the labelling for the node.
            </summary>
            <param name="nodeLabel"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdgeStar.GetResultAreaEdges">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdgeStar.LinkResultDirectedEdges">
            <summary> 
            Traverse the star of DirectedEdges, linking the included edges together.
            To link two dirEdges, the next pointer for an incoming dirEdge
            is set to the next outgoing edge.
            DirEdges are only linked if:
            they belong to an area (i.e. they have sides)
            they are marked as being in the result
            Edges are linked in CCW order (the order they are stored).
            This means that rings have their face on the Right
            (in other words, the topological location of the face is given by the RHS label of the DirectedEdge).
            PRECONDITION: No pair of dirEdges are both marked as being in the result.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdgeStar.LinkMinimalDirectedEdges(MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing)">
            <summary>
            
            </summary>
            <param name="er"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdgeStar.LinkAllDirectedEdges">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdgeStar.FindCoveredLineEdges">
            <summary> 
            Traverse the star of edges, maintaing the current location in the result
            area at this node (if any).
            If any L edges are found in the interior of the result, mark them as covered.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdgeStar.ComputeDepths(MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge)">
            <summary>
            
            </summary>
            <param name="de"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdgeStar.ComputeDepths(System.Int32,System.Int32,System.Int32)">
            <summary> 
            Compute the DirectedEdge depths for a subsequence of the edge array.
            </summary>
            <returns>The last depth assigned (from the R side of the last edge visited).</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdgeStar.Write(System.IO.StreamWriter)">
            <summary>
            
            </summary>
            <param name="outstream"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdgeStar.Label">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Parameter">
            <summary>
            A named parameter value.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Parameter.#ctor(System.String,System.Double)">
            <summary>
            Creates an instance of a parameter
            </summary>
            <remarks>Units are always either meters or degrees.</remarks>
            <param name="name">Name of parameter</param>
            <param name="value">Value</param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Parameter.Name">
            <summary>
            Parameter name
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Parameter.Value">
            <summary>
            Parameter value
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeocentricCoordinateSystem">
            <summary>
            A 3D coordinate system, with its origin at the center of the Earth.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeocentricCoordinateSystem.HorizontalDatum">
            <summary>
            Returns the HorizontalDatum. The horizontal datum is used to determine where
            the centre of the Earth is considered to be. All coordinate points will be 
            measured from the centre of the Earth, and not the surface.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeocentricCoordinateSystem.LinearUnit">
            <summary>
            Gets the units used along all the axes.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.IGeocentricCoordinateSystem.PrimeMeridian">
            <summary>
            Returns the PrimeMeridian.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICompoundCoordinateSystem">
            <summary>
            An aggregate of two coordinate systems (CRS). One of these is usually a 
            CRS based on a two dimensional coordinate system such as a geographic or
            a projected coordinate system with a horizontal datum. The other is a 
            vertical CRS which is a one-dimensional coordinate system with a vertical
            datum.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICompoundCoordinateSystem.HeadCS">
            <summary>
            Gets first sub-coordinate system.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.ICompoundCoordinateSystem.TailCS">
            <summary>
            Gets second sub-coordinate system.
            </summary>
        </member>
        <member name="T:KDTreeDLL.KDTree">
            <summary>
            This is an adaptation of the Java KDTree library implemented by Levy 
            and Heckel. This simplified version is written by Marco A. Alvarez
            
            KDTree is a class supporting KD-tree insertion, deletion, equality
            search, range search, and nearest neighbor(s) using double-precision
            floating-point keys.  Splitting dimension is chosen naively, by
            depth modulo K.  Semantics are as follows:
            
             Two different keys containing identical numbers should retrieve the 
                 same value from a given KD-tree.  Therefore keys are cloned when a 
                 node is inserted.
            
             As with Hashtables, values inserted into a KD-tree are <I>not</I>
                 cloned.  Modifying a value between insertion and retrieval will
                 therefore modify the value stored in the tree.
            
            
            @author Simon Levy, Bjoern Heckel
            Translation by Marco A. Alvarez
            </summary>
        </member>
        <member name="M:KDTreeDLL.KDTree.#ctor(System.Int32)">
             Creates a KD-tree with specified number of dimensions.
            
             @param k number of dimensions
        </member>
        <member name="M:KDTreeDLL.KDTree.insert(System.Double[],System.Object)">
             Insert a node in a KD-tree.  Uses algorithm translated from 352.ins.c of
            
               <PRE>
               &#064;Book{GonnetBaezaYates1991,                                   
                 author =    {G.H. Gonnet and R. Baeza-Yates},
                 title =     {Handbook of Algorithms and Data Structures},
                 publisher = {Addison-Wesley},
                 year =      {1991}
               }
               </PRE>
            
             @param key key for KD-tree node
             @param value value at that key
            
             @throws KeySizeException if key.length mismatches K
             @throws KeyDuplicateException if key already in tree
        </member>
        <member name="M:KDTreeDLL.KDTree.search(System.Double[])">
             Find  KD-tree node whose key is identical to key.  Uses algorithm 
             translated from 352.srch.c of Gonnet and Baeza-Yates.
            
             @param key key for KD-tree node
            
             @return object at key, or null if not found
            
             @throws KeySizeException if key.length mismatches K
        </member>
        <member name="M:KDTreeDLL.KDTree.delete(System.Double[])">
             Delete a node from a KD-tree.  Instead of actually deleting node and
             rebuilding tree, marks node as deleted.  Hence, it is up to the caller
             to rebuild the tree as needed for efficiency.
            
             @param key key for KD-tree node
            
             @throws KeySizeException if key.length mismatches K
             @throws KeyMissingException if no node in tree has key
        </member>
        <member name="M:KDTreeDLL.KDTree.nearest(System.Double[])">
                    * Find KD-tree node whose key is nearest neighbor to
                    * key. Implements the Nearest Neighbor algorithm (Table 6.4) of
                    *
                    * <PRE>
                    * &#064;techreport{AndrewMooreNearestNeighbor,
                    *   author  = {Andrew Moore},
                    *   title   = {An introductory tutorial on kd-trees},
                    *   institution = {Robotics Institute, Carnegie Mellon University},
                    *   year    = {1991},
                    *   number  = {Technical Report No. 209, Computer Laboratory, 
                    *              University of Cambridge},
                    *   address = {Pittsburgh, PA}
                    * }
                    * </PRE>
                    *
                    * @param key key for KD-tree node
                    *
                    * @return object at node nearest to key, or null on failure
                    *
                    * @throws KeySizeException if key.length mismatches K
            
        </member>
        <member name="M:KDTreeDLL.KDTree.nearest(System.Double[],System.Int32)">
             Find KD-tree nodes whose keys are <I>n</I> nearest neighbors to
             key. Uses algorithm above.  Neighbors are returned in ascending
             order of distance to key. 
            
             @param key key for KD-tree node
             @param n how many neighbors to find
            
             @return objects at node nearest to key, or null on failure
            
             @throws KeySizeException if key.length mismatches K
             @throws IllegalArgumentException if <I>n</I> is negative or
             exceeds tree size 
        </member>
        <member name="M:KDTreeDLL.KDTree.range(System.Double[],System.Double[])">
             Range search in a KD-tree.  Uses algorithm translated from
             352.range.c of Gonnet and Baeza-Yates.
            
             @param lowk lower-bounds for key
             @param uppk upper-bounds for key
            
             @return array of Objects whose keys fall in range [lowk,uppk]
            
             @throws KeySizeException on mismatch among lowk.length, uppk.length, or K
        </member>
        <member name="M:KDTreeDLL.KDTree.toString">
            <summary>
            tostring function
            </summary>
            <returns></returns>
        </member>
        <member name="T:KDTreeDLL.KDTree.KDNode">
            <summary>
            K-D Tree node class
            </summary>
        </member>
        <member name="T:MapWinGeoProc.FlowArea">
             <summary>
             FlowArea provides users the ability to form flow areas from a D8 grid, source polygon, and stream network
             </summary>
            
        </member>
        <member name="M:MapWinGeoProc.FlowArea.FormFlowAreas(System.String,System.String,System.Int32,System.String,System.String,System.Double,System.String,MapWinGIS.ICallback)">
             <summary>
             Generates a flow area analysis polygon from a given D8 grid, source polygon, and stream network
             <param name="currD8Path">The string path to the D8 grid</param>
             <param name="sourcePath">The string path to the source polygon shapefile</param>
             <param name="idxSelected">The index of the shape in the sourcePath shapefile which is to be used as the initiation zone</param>
             <param name="currStreamPath">The string path to the stream network polyline shapefile</param>
             <param name="demPath">The string path to the DEM used to calculate average slope of flow area polygons</param>
             <param name="zFactor">The z factor used for the slope calculations</param>
             <param name="outFlowShapePath">The output polygon shapefile path which will have the flow areas</param>
             <param name="callback">A callback object which provides progress and status messages</param>
             </summary>
            
        </member>
        <member name="M:MapWinGeoProc.clsMergeShapefiles.#ctor">
            <summary>
            Creates a new instance of the AppendShapes class
            </summary>
            <param name="inMap">The map to add the merged shape to</param>
        </member>
        <member name="M:MapWinGeoProc.clsMergeShapefiles.DoMergeShapefiles">
            <summary>
            Actually engages the append shapes process
            </summary>
        </member>
        <member name="T:MapWinGeoProc.DataManagement">
            <summary>
            The DataManagement namespace will contain basic file handling routines 
            such as copy and delete, as well as some more complex methods for appending and merging..
            </summary>
        </member>
        <member name="M:MapWinGeoProc.DataManagement.RenameGrid(System.String@,System.String@)">
            <summary>
            Rename a grid (or move it's path) and all associated files.
            </summary>
            <param name="oldGridPath">The full path to the original grid file (including extension).</param>
            <param name="newGridPath">The full path to the new grid file (including extension).</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.DataManagement.RenameShapefile(System.String@,System.String@)">
            <summary>
            Rename a shapefile and all associated files.
            </summary>
            <param name="oldShapefilePath">Full path to the original shapefile (including the .shp extension).</param>
            <param name="newShapefilePath">New path to the shapefile (including the .shp extension).</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.DataManagement.CopyGrid(System.String@,System.String@)">
            <summary>
            Copies a grid and all associated files from one destination path to another.
            </summary>
            <param name="oldGridPath">The original path to the grid (including extension).</param>
            <param name="newGridPath">The path to where the grid copy should be (including extension).</param>
            <returns>False if an error was encountered, true otherwise.</returns>
            <remarks>Won't work for Grid formats that are directory names like an ESRI grid format yet</remarks>
        </member>
        <member name="M:MapWinGeoProc.DataManagement.CopyShapefile(System.String@,System.String@)">
            <summary>
            Copies a shapefile and all associated files.
            </summary>
            <param name="oldShapefilePath">Full path to the original shapefile (including .shp extension).</param>
            <param name="newShapefilePath">Full path to where the copy should be saved (including .shp extension).</param>
            <returns>False if an error was encoutered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.DataManagement.TryDelete(System.String)">
            <summary>
            Attempts to delete a file.
            </summary>
            <returns>Boolean, false if the file is null or the directory doesn't exist or the file doesn't exist</returns>
        </member>
        <member name="M:MapWinGeoProc.DataManagement.CopyGridLegend(System.String,System.String)">
            <summary>
            Copies the .mwleg file from the input grid to the output grid.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.DataManagement.DeleteGrid(System.String@)">
            <summary>
            Deletes the grid and associated  files (.bmp, .bpw, .mwleg, .prj).
            </summary>
            <param name="gridPath">Full path to the grid file, including extension.</param>
            <returns>Boolean, False if gridPath is null, the directory doesn't exist, or any of the files exist but could not be deleted.</returns>
        </member>
        <member name="M:MapWinGeoProc.DataManagement.DeleteShapefile(System.String@)">
            <summary>
            Deletes shapefile and associated files (.shx, .dbf, .prj).
            </summary>
            <param name="shapefilePath">Full path to shapefile, including .shp extension</param>
        </member>
        <member name="M:MapWinGeoProc.DataManagement.ChangeGridFormat(System.String,System.String,MapWinGIS.GridFileType,MapWinGIS.GridDataType,System.Single)">
            <summary>
            Er... Changes a grid format?
            </summary>
            <param name="origFilename">Original Grid Filename</param>
            <param name="newFilename">Output Grid Filename</param>
            <param name="newFileType">Specifies the original file format of the grid</param>
            <param name="newFileFormat">Specifies the new file format</param>
            <param name="multFactor">Like Extrusion, this multiplies the Z value</param>
            <returns>Boolean, false if there was an error</returns>
        </member>
        <member name="M:MapWinGeoProc.DataManagement.AppendShapefile(System.String@,System.String@)">
            <summary>
            Not Implemented
            Appends one shapefile to another. No intersection/union operation is performed
            on overlapping shapes. The input shapefile is overwritten.
            </summary>
            <param name="inputSFPath">Full path to the input shapefile.</param>
            <param name="appendSFPath">Full path to the shapefile that needs to be appended to the input shapefile.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.DataManagement.Dissolve(System.String@,System.String@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Not Implemented
            Removes shapes from the shapefile that contain a specified attribute.
            </summary>
            <param name="inputSFPath">The full path to the input shapefile.</param>
            <param name="resultSFPath">The full path to the resulting shapefile.</param>
            <param name="fieldID">The ID value for which field in the input shapefile will be considered.</param>
            <param name="attributeLoc">The location of an attribute value to compare against for removing shapes.</param>
            <param name="compOperation">The comparison method to use (==, !=, >=, etc).</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.DataManagement.MergeGrids(System.String@,System.String@,System.String@)">
            <summary>
            Not Implemented
            Combines two grids into one.
            </summary>
            <param name="grid1Path">Full path to the first grid.</param>
            <param name="grid2Path">Full path to the second grid.</param>
            <param name="resultGridPath">Full path to the result grid.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.DataManagement.MergeShapefiles(System.String@,System.String@,System.String@,System.Int32,System.Int32)">
            <summary>
            Not Implemented
            Combines two shapefiles into one.
            </summary>
            <param name="sf1Path">Full path to the first shapefile.</param>
            <param name="sf2Path">Full path to the second shapefile.</param>
            <param name="resultSFPath">Full path to the result shapefile.</param>
            <param name="mergeOperation">Indicates whether Union or Intersect should be performed on overlapping shapes.</param>
            <param name="tableOperation">Indicates how table data should be combined.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.DataManagement.MergeShapefiles">
            <summary>
            Uses dialogs to obtain input and output information for processing files
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Topology2D.Vector">
            <summary>
            Contains a magnitude and direction
            Supports more fundamental calculations than LineSegment, rather than topological functions
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.Vector.X">
            <summary>
            The X component of the vector
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.Vector.Y">
            <summary>
            The Y component of the vector
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.#ctor(MapWinGeoProc.Topology2D.Point)">
            <summary>
            Creates a new vector from the Point, assuming the tail of the vector is the origin
            </summary>
            <param name="Point">The Point to create a vector from</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.#ctor(MapWinGeoProc.Topology2D.Coordinate)">
            <summary>
            Creates a new vector from the specified coordinate
            </summary>
            <param name="Coord"></param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.#ctor(MapWinGeoProc.Topology2D.LineSegment)">
            <summary>
            Creates a new vector from a line segment, assuming that the direction is from the start point to the end point
            </summary>
            <param name="LineLineSegment">A Topology.LineSegment object to turn into a vector</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.#ctor(MapWinGeoProc.Topology2D.Point,MapWinGeoProc.Topology2D.Point)">
            <summary>
            Creates a new vector from two points, assuming that the direction is from the start point to the end point
            and uses the StartPoint as the origin.
            </summary>
            <param name="StartPoint">The beginning of the vector</param>
            <param name="EndPoint">The end of the vector</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.#ctor(MapWinGeoProc.Topology2D.Coordinate,MapWinGeoProc.Topology2D.Coordinate)">
            <summary>
            Creates a vector using two coordinates
            </summary>
            <param name="Tail">Coordinate where the vector starts</param>
            <param name="Tip">coordinate where the vector ends</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a mathematical vector from X1, Y1 to X2, Y2
            </summary>
            <param name="x1">Double, The X coordinate of the start point for the vector</param>
            <param name="y1">Double, The Y coordinate of the start point for the vector </param>
            <param name="x2">Double, The X coordinate of the end point for the vector</param>
            <param name="y2">Double, The Y coordinate of the end point for the vector</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.#ctor(System.Double,System.Double)">
            <summary>
            Creates a mathemtacal vector from the origin to the x, y, z coordinates
            </summary>
            <param name="x">Double, the X coordinate from the origin</param>
            <param name="y">Double, the Y coordinate from the origin</param>   
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.#ctor(System.Double,MapWinGeoProc.Topology2D.Angle)">
            <summary>
            Creates a mathematical vector from the origin with the new magnitude and directions specified
            </summary>
            <param name="newMagnitude">Double, the length of the vector</param>
            <param name="Theta">The angle in the x-y plane</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.Copy">
            <summary>
            Returns a new instance of the vector class with the same values as this object.
            </summary>
            <returns>Vector with identical properties.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.Cross(MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Returns the cross product of this vector with the specified vector V.
            Given X and Y vectors, this creates a vector in the Z direction, so
            simply interpret the double value to be positive in the positive Z direction.
            </summary>
            <param name="V">The vector to perform a cross product against</param>
            <returns>A vector result from the inner product</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.DividedBy(System.Double)">
            <summary>
            Returns the quotient of this vector with Scalar
            </summary>
            <param name="Scalar">Double, a value to divide all the members of this vector by</param>
            <returns>A vector where each element has been divided by the scalar</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.DividedBy(MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Divides each of the elements of this vector by the elements of V
            </summary>
            <param name="V">Vector, the vector to divide this vector by</param>
            <returns>A vector result from the division</returns>
            <remarks>To prevent division by 0, members of V that are 0 will produce an output
            vector with 0 in that column</remarks>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.Dot(MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Returns the dot product of this vector with V2
            </summary>
            <param name="V">The vector to perform an inner product against</param>
            <returns>A Double result from the inner product</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.Norm2">
            <summary>
            Returns the square of the distance of the vector without taking the square root
            This is the same as doting the vector with itself
            </summary>
            <returns>Double, the square of the distance between the vectors</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.Equals(System.Object)">
            <summary>
            This function has been overriden to compare the vectors in the mathematical sense.
            If the components of the vector are equal, then this will return true.
            </summary>
            <param name="obj">An object to compare with this object</param>
            <returns>Boolean, true if the X and Y components are equal.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.GetHashCode">
            <summary>
            Returns a hash code, whatever that is.
            </summary>
            <returns>A hash code.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.Minus(MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Subtracts each element of V from each element of this vector
            </summary>
            <param name="V">Vector, the vector to subtract from this vector</param>
            <returns>A vector result from the subtraction</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.Plus(MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Adds each of the elements of V to the elements of this vector
            </summary>
            <param name="V">Vector, the vector to add to this vector</param>
            <returns>A vector result from the addition</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.Times(System.Double)">
            <summary>
            Returns the scalar product of this vector against a scalar
            </summary>
            <param name="Scalar">Double, a value to multiply against all the members of this vector</param>
            <returns>A vector multiplied by the scalar</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.Times(MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Multiplies each of the elements of V to the elements of this vector
            </summary>
            <param name="V">Vector, the vector to multply with this vector</param>
            <returns>A vector result from the multiplication</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.To_MapWinGIS_Point">
            <summary>
            A MapWinGIS.Point Representing the tip of the vector,
            where the beginning of the vector is at the origin 
            </summary>
            <remarks>This is passed as an object to isolate MapWinGIS refs</remarks>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.ToPoint">
            <summary>
            Assuming the vector starts at the origin of 0,0,0, this function returns
            a Point representing the tip of the vector.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.ToCoordinate">
            <summary>
            A MapWinGIS.Point Representing the tip of the vector,
            where the beginning of the vector is at the origin 
            /// </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.ToLineSegment">
            <summary>
            Returns a new segment from this vector, where the StartPoint is 0, 0, 0
            and the End Point is the tip of this vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.Norm2(MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Non-static version of taking the square distance for a vector
            </summary>
            <param name="U">The vector to find the square of the distance of</param>
            <returns>Double, the square of the distance</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.AddVectors(MapWinGeoProc.Topology2D.Vector,MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Adds the vectors U and V using vector addition, which adds the corresponding components
            </summary>
            <param name="U">One vector to be added</param>
            <param name="V">A second vector to be added</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.CrossProduct(MapWinGeoProc.Topology2D.Vector,MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Returns the Cross Product of two vectors U and V
            </summary>
            <param name="U">Vector, the first input vector</param>
            <param name="V">Vector, the second input vector</param>
            <returns>A double containing the cross product of U and V</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.DivideVectors(MapWinGeoProc.Topology2D.Vector,MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Divides the components of vector U by the respective components
            of vector V and returns the resulting vector. 
            </summary>
            <param name="U">Vector Dividend (Numbers to be divided)</param>
            <param name="V">Vector Divisor (Numbers to divide by)</param>
            <returns>A Vector quotient of U and V</returns>
            <remarks>To prevent divide by 0, if a 0 is in V, it will return 0 in the result</remarks>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.DivideVectors(MapWinGeoProc.Topology2D.Vector,System.Double)">
            <summary>
            Multiplies each component of vector U by the Scalar value
            </summary>
            <param name="U">A vector representing the vector to be multiplied</param>
            <param name="Scalar">Double, the scalar value to mulitiply the vector components by</param>
            <returns>A Vector representing the vector product of vector U and the Scalar</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.DotProduct(MapWinGeoProc.Topology2D.Vector,MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Returns the Inner Product also known as the dot product of two vectors, U and V
            </summary>
            <param name="U">The input vector</param>
            <param name="V">The vector to take the inner product against U</param>
            <returns>a Double containing the dot product of U and V</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.MultiplyVectors(MapWinGeoProc.Topology2D.Vector,System.Double)">
            <summary>
            Multiplies each component of vector U by the Scalar value
            </summary>
            <param name="U">A vector representing the vector to be multiplied</param>
            <param name="Scalar">Double, the scalar value to mulitiply the vector components by</param>
            <returns>A Vector representing the vector product of vector U and the Scalar</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.SubtractVectors(MapWinGeoProc.Topology2D.Vector,MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Subtracts Vector V from Vector U
            </summary>
            <param name="U">A Vector to subtract from</param>
            <param name="V">A Vector to subtract</param>
            <returns>The Vector difference U - V</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.op_Equality(MapWinGeoProc.Topology2D.Vector,MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Returns true if X and Y coordinates are equal
            </summary>
            <param name="U">A vector to compare</param>
            <param name="V">A second vector to compare</param>
            <returns>Boolean, true if the vectors are the same</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.op_Inequality(MapWinGeoProc.Topology2D.Vector,MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Returns true if X and Y coordinates are different
            </summary>
            <param name="U">A vector to compare</param>
            <param name="V">A second vector to compare</param>
            <returns>Boolean, true if the vectors are the different</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.op_Addition(MapWinGeoProc.Topology2D.Vector,MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Adds the vectors U and V using vector addition, which adds the corresponding components
            </summary>
            <param name="U">One vector to be added</param>
            <param name="V">A second vector to be added</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.op_ExclusiveOr(MapWinGeoProc.Topology2D.Vector,MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Returns the Cross Product of two vectors U and V
            </summary>
            <param name="U">Vector, the first input vector</param>
            <param name="V">Vector, the second input vector</param>
            <returns>A double containing the cross product of U and V</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.op_Division(MapWinGeoProc.Topology2D.Vector,MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Divides the components of vector U by the respective components
            ov vector V and returns the resulting vector. 
            </summary>
            <param name="U">Vector Dividend (Numbers to be divided)</param>
            <param name="V">Vector Divisor (Numbers to divide by)</param>
            <returns>A Vector quotient of U and V</returns>
            <remarks>To prevent divide by 0, if a 0 is in V, it will return 0 in the result</remarks>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.op_Division(MapWinGeoProc.Topology2D.Vector,System.Double)">
            <summary>
            Multiplies each component of vector U by the Scalar value
            </summary>
            <param name="U">A vector representing the vector to be multiplied</param>
            <param name="Scalar">Double, the scalar value to mulitiply the vector components by</param>
            <returns>A Vector representing the vector product of vector U and the Scalar</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.op_Multiply(MapWinGeoProc.Topology2D.Vector,MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Returns the Inner Product also known as the dot product of two vectors, U and V
            </summary>
            <param name="U">The input vector</param>
            <param name="V">The vector to take the inner product against U</param>
            <returns>a Double containing the dot product of U and V</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.op_Multiply(System.Double,MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Multiplies the vectors U and V using vector multiplication,
            which adds the corresponding components
            </summary>
            <param name="Scalar">One vector to be multiplied</param>
            <param name="V">A second vector to be multiplied</param>
            <returns>A Vector product of U and V</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.op_Multiply(MapWinGeoProc.Topology2D.Vector,System.Double)">
            <summary>
            Multiplies each component of vector U by the Scalar value
            </summary>
            <param name="U">A vector representing the vector to be multiplied</param>
            <param name="Scalar">Double, the scalar value to mulitiply the vector components by</param>
            <returns>A Vector representing the vector product of vector U and the Scalar</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Vector.op_Subtraction(MapWinGeoProc.Topology2D.Vector,MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Subtracts Vector V from Vector U
            </summary>
            <param name="U">A Vector to subtract from</param>
            <param name="V">A Vector to subtract</param>
            <returns>The Vector difference U - V</returns>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.Vector.Magnitude">
            <summary>
            The Euclidean distance from the origin to the tip of the 3 dimensional vector
            Setting the magntiude won't change the direction.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.Vector.Theta">
            <summary>
            Represents the angle in the X-Y plane.  0 along the positive X axis, and increasing counterclockwise
            Values are in Radians.  Setting this value when no X-Y magnitude exists results in a unit vector
            between X and Y.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Topology2D.Adapter">
            <summary>
            Supports some functions related to polygon adjacency etc.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Adapter.GetCategory(MapWinGIS.Shape)">
            <summary>
            reads a MapWinGIS.Shape to find the ShapeCategory
            </summary>
            <param name="Shape">A MapWinGIS.Shape object to learn the category of</param>
            <returns>A ShapeCategories enumeration</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Adapter.ShapeBoundariesTouch(MapWinGIS.Shape,MapWinGIS.Shape)">
            <summary>
            Checks whether the borders of a polygon shape, lines of line shapes, or points of point shapes touch.
            </summary>
            <param name="Shape1">A MapWinGIS.Shape object to test</param>
            <param name="Shape2">A MapWinGIS.Shape object to test</param>
            <returns>True if the boundaries touch</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Adapter.PointsWithinEnvelope(MapWinGIS.Shape,MapWinGIS.Extents)">
            <summary>
            Finds a list of point indecies from a MapWinGIS.Shape that are within the extents specified
            </summary>
            <param name="Shape">Any shapefile with points.</param>
            <param name="Envelope">A MapWinGIS.Extents object representing the area of interrest</param>
            <returns>Returns a list of integer point indecies in Shape that are within Envelope</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Adapter.PointsWithinRect(MapWinGIS.Shape,MapWinGeoProc.Topology2D.Envelope)">
            <summary>
            Finds a list of point indecies from a MapWinGIS.Shape that are within the rectangle specified
            </summary>
            <param name="Shape">A mapWinGIS.Shape object to select points from</param>
            <param name="Rect">A Envelope structure representing a rectangle to search</param>
            <returns>A List of integer values representing the index values of the points within the rectangle</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Adapter.LineSegmentsWithinEnvelope(MapWinGIS.Shape,MapWinGIS.Extents)">
            <summary>
            Finds the points within extents for polygons and polylines and automatically creates a list
            of appropriate line segments representing all the segments found within the extents.
            </summary>
            <param name="LineOrPolygon">A MapWinGIS.Shape that is a line or polygon shape</param>
            <param name="Envelope">A MapWinGIS.Extents object showing the area of interrest</param>
            <returns>A list of LineSegment structures that have at least one point within or on extents</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Adapter.LineSegmentsWithinRect(MapWinGIS.Shape,MapWinGeoProc.Topology2D.Envelope)">
            <summary>
            Finds the points within extents for polygons and polylines and automatically creates a list
            of appropriate line segments representing all the segments found within the extents.
            </summary>
            <param name="LineOrPolygon">A MapWinGIS.Shape that is a line or polygon shape</param>
            <param name="Rect">A Envelope defining the region of interrest</param>
            <returns>A list of all segments that have at least one point within or on the extents</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Adapter.EnvelopeIntersect(MapWinGIS.Shapefile,System.Int32,System.Int32)">
            <summary>
            Determines if two shapes in the same shapefile have rectangular extents that touch or intersect.
            </summary>
            <param name="mwShapefile">A MapWinGIS.Shapefile containing both shapes to compare</param>
            <param name="ShapeIndex1">The integer index of the first shape</param>
            <param name="ShapeIndex2">The integer index of the second shape</param>
            <returns>Boolean, true if the extents overlap or touch</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Adapter.EnvelopeIntersect(MapWinGIS.Shape,MapWinGIS.Shape)">
            <summary>
            Determines if two MapWinGIS.Shape objects have rectangular extents that touch or intersect
            </summary>
            <param name="Shape1">A MapWinGIS.Shape to test the rectangular extents of</param>
            <param name="Shape2">A Second MapWinGIS.Shape to test the rectangular extents of</param>
            <returns>Boolean, true if the extents overlap or touch.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Adapter.ShapesWithIntersectingEnvelope(MapWinGIS.Shapefile,System.Int32)">
            <summary>
            Returns a System.Collections.List if integer shape indecies
            </summary>
            <param name="mwShapefile">The MapWinGIS.Shapefile to find shapes from</param>
            <param name="ShapeIndex">The integer shape index in shapefile of the shape to compare with</param>
            <returns>A System.Collections.List of integers that are the shape indecies of shapes overlapping extents</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Adapter.ShapesWithIntersectingEnvelope(MapWinGIS.Shapefile,MapWinGIS.Shape)">
            <summary>
            Returns a System.Collections.List if integer shape indecies
            </summary>
            <param name="mwShapefile">The MapWinGIS.Shapefile to find shapes from</param>
            <param name="Shape">The MapWinGIS.Shape to compare with (not necessarilly in the same shapefile)</param>
            <returns>A System.Collections.List of integers that are the shape indecies of shapes overlapping extents</returns>
            <remarks>Even if Shape is in the shapefile, its index will also be returned</remarks>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Utilities.HexConverter">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.HexConverter.#ctor">
            <summary>
            Only static methods!
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.HexConverter.ConvertAny2Any(System.String,System.Int32,System.Int32)">
            <summary>
            Convert the given numeric value (passed as string) of the base specified by <c>baseIn</c>
            to the value specified by <c>baseOut</c>.
            </summary>
            <param name="valueIn">Numeric value to be converted, as string.</param>
            <param name="baseIn">Base of input value.</param>
            <param name="baseOut">Base to use for conversion.</param>
            <returns>Converted value, as string.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.ScaledNoder">
            <summary>
            Wraps a <see cref="T:MapWinGeoProc.NTS.Topology.Noding.INoder"/> and transforms its input into the integer domain.
            This is intended for use with Snap-Rounding noders,
            which typically are only intended to work in the integer domain.
            Offsets can be provided to increase the number of digits of available precision.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.ScaledNoder.#ctor(MapWinGeoProc.NTS.Topology.Noding.INoder,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.ScaledNoder"/> class.
            </summary>
            <param name="noder"></param>
            <param name="scaleFactor"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.ScaledNoder.#ctor(MapWinGeoProc.NTS.Topology.Noding.INoder,System.Double,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="noder"></param>
            <param name="scaleFactor"></param>
            <param name="offsetX"></param>
            <param name="offsetY"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.ScaledNoder.GetNodedSubstrings">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.ScaledNoder.ComputeNodes(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="inputSegStrings"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.ScaledNoder.Scale(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="segStrings"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.ScaledNoder.Scale(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            
            </summary>
            <param name="pts"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.ScaledNoder.Rescale(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="segStrings"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.ScaledNoder.Rescale(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            
            </summary>
            <param name="pts"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.ScaledNoder.isIntegerPrecision">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexedLine">
            <summary>
            Supports linear referencing along a linear <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>
            using <see cref="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation"/>s as the index.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexedLine.#ctor(MapWinGeoProc.NTS.Topology.Geometries.Geometry)">
            <summary>
            Constructs an object which allows linear referencing along
            a given linear <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>.
            </summary>
            <param name="linearGeom"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexedLine.CheckGeometryType">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexedLine.ExtractPoint(MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation)">
            <summary>
            Computes the <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/>for the point on the line at the given index.
            If the <paramref name="index"/> is out of range,
            the first or last point on the line will be returned.
            </summary>
            <param name="index">The index of the desired point.</param>
            <returns>The <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> at the given index.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexedLine.ExtractLine(MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation,MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation)">
            <summary>
            Computes the <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.LineString"/> for the interval
            on the line between the given indices.
            </summary>
            <param name="startIndex">The index of the start of the interval.</param>
            <param name="endIndex">The index of the end of the interval.</param>
            <returns>The linear interval between the indices.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexedLine.IndexOf(MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            Computes the index for a given point on the line.
            The supplied point does not necessarily have to lie precisely
            on the line, but if it is far from the line the accuracy and
            performance of this function is not guaranteed.
            Use <see cref="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexedLine.Project(MapWinGeoProc.NTS.Topology.Geometries.Coordinate)"/> to compute a guaranteed result for points
            which may be far from the line.
            </summary>
            <param name="pt">A point on the line.</param>
            <returns>The index of the point.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexedLine.IndicesOf(MapWinGeoProc.NTS.Topology.Geometries.Geometry)">
            <summary>
            Computes the indices for a subline of the line.
            (The subline must conform to the line; that is,
            all vertices in the subline (except possibly the first and last)
            must be vertices of the line and occcur in the same order).
            </summary>
            <param name="subLine">A subLine of the line.</param>
            <returns>A pair of indices for the start and end of the subline.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexedLine.Project(MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            Computes the index for the closest point on the line to the given point.
            If more than one point has the closest distance the first one along the line is returned.
            (The point does not necessarily have to lie precisely on the line.)
            </summary>
            <param name="pt">A point on the line.</param>
            <returns>The index of the point.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexedLine.isValidIndex(MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation)">
            <summary>
            Tests whether an index is in the valid index range for the line.
            </summary>
            <param name="index">The index to test.</param>
            <returns><c>true</c> if the index is in the valid range.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexedLine.ClampIndex(MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation)">
            <summary>
            Computes a valid index for this line by clamping 
            the given index to the valid range of index values.
            </summary>
            <param name="index"></param>
            <returns>A valid index value.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexedLine.StartIndex">
            <summary>
            Returns the index of the start of the line.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LocationIndexedLine.EndIndex">
            <summary>
            Returns the index of the end of the line.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.DbaseFileReader">
            <summary>
            Class that allows records in a dbase file to be enumerated.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileReader.#ctor(System.String)">
            <summary>
            Initializes a new instance of the DbaseFileReader class.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileReader.GetHeader">
            <summary>
            Gets the header information for the dbase file.
            </summary>
            <returns>DbaseFileHeader contain header and field information.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileReader.GetEnumerator">
            <summary>
            Gets the object that allows iterating through the members of the collection.
            </summary>
            <returns>An object that implements the IEnumerator interface.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.DbaseFileReader.DbaseFileEnumerator">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileReader.DbaseFileEnumerator.#ctor(MapWinGeoProc.NTS.Topology.IO.DbaseFileReader)">
            <summary>
            
            </summary>
            <param name="parent"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileReader.DbaseFileEnumerator.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileReader.DbaseFileEnumerator.MoveNext">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileReader.DbaseFileEnumerator.ReadHeader">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileReader.DbaseFileEnumerator.Read">
            <summary>
            Read a single dbase record
            </summary>
            <returns>return the read shapefile record or null if there are no more records</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.DbaseFileReader.DbaseFileEnumerator.Current">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.DbaseFieldDescriptor">
            <summary>
            Class for holding the information assicated with a dbase field.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFieldDescriptor.GetDbaseType(System.Type)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFieldDescriptor.ShapeField">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFieldDescriptor.IdField">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.DbaseFieldDescriptor.Name">
            <summary>
            Field Name.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.DbaseFieldDescriptor.DbaseType">
            <summary>
            Field Type (C N L D or M).
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.DbaseFieldDescriptor.DataAddress">
            <summary>
            Field Data Address offset from the start of the record.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.DbaseFieldDescriptor.Length">
            <summary>
            Length of the data in bytes.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.DbaseFieldDescriptor.DecimalCount">
            <summary>
            Field decimal count in Binary, indicating where the decimal is.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.DbaseFieldDescriptor.Type">
            <summary>
            Returns the equivalent CLR type for this field.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.MultiPolygon">
            <summary>
            Basic implementation of <c>MultiPolygon</c>.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.MultiPolygon.Empty">
            <summary>
            Represents an empty <c>MultiPolygon</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.MultiPolygon.#ctor(MapWinGeoProc.NTS.Topology.Geometries.Polygon[])">
            <summary>
            Constructs a <c>MultiPolygon</c>.
            </summary>
            <param name="polygons">
            The <c>Polygon</c>s for this <c>MultiPolygon</c>
            , or <c>null</c> or an empty array to create the empty point.
            Elements may be empty <c>Polygon</c>s, but not <c>null</c>
            s. The polygons must conform to the assertions specified in the 
            <see href="http://www.opengis.org/techno/specs.htm"/> OpenGIS Simple Features
            Specification for SQL.        
            </param>
            <remarks>
            For create this <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/> is used a standard <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory"/> 
            with <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel"/> <c> == </c> <see cref="F:MapWindow.Interfaces.Geometries.PrecisionModels.Floating"/>.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.MultiPolygon.#ctor(MapWindow.Interfaces.Geometries.IPolygon[],MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            Constructs a <c>MultiPolygon</c>.
            </summary>
            <param name="polygons">
            The <c>Polygon</c>s for this <c>MultiPolygon</c>
            , or <c>null</c> or an empty array to create the empty point.
            Elements may be empty <c>Polygon</c>s, but not <c>null</c>
            s. The polygons must conform to the assertions specified in the 
            <see href="http://www.opengis.org/techno/specs.htm"/> OpenGIS Simple Features
            Specification for SQL.        
            </param>
            <param name="factory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.MultiPolygon.EqualsExact(MapWindow.Interfaces.Geometries.IGeometry,System.Double)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <param name="tolerance"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.MultiPolygon.Dimension">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.MultiPolygon.BoundaryDimension">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.MultiPolygon.GeometryType">
            <summary>
            A clarifier to help identify the kind of geometry
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.MultiPolygon.IsSimple">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.MultiPolygon.Boundary">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.LinearRing">
            <summary>  
            Basic implementation of <c>LinearRing</c>.
            The first and last point in the coordinate sequence must be equal.
            Either orientation of the ring is allowed.
            A valid ring must not self-intersect.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.LineString">
            <summary>  
            Basic implementation of <c>LineString</c>.
            </summary>  
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.LineString.Empty">
            <summary>
            Represents an empty <c>LineString</c>.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.LineString.points">
            <summary>  
            The points of this <c>LineString</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineString.#ctor(MapWindow.Interfaces.Geometries.ICoordinateSequence,MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            
            </summary>
            <param name="points">
            The points of the linestring, or <c>null</c>
            to create the empty point. Consecutive points may not be equal.
            </param>
            <param name="factory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineString.#ctor(MapWindow.Interfaces.Geometries.ILineStringBase)">
            <summary>
            Creates a new topologically complete LineString from a LineStringBase
            </summary>
            <param name="lineStringBase"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineString.#ctor(MapWindow.Interfaces.Geometries.ILineStringBase,MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            
            </summary>
            <param name="lineString">
            The points of the linestring, or <c>null</c>
            to create the empty point. Consecutive points may not be equal.
            </param>
            <param name="factory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineString.GetCoordinateN(System.Int32)">
            <summary>
            
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineString.GetPointN(System.Int32)">
            <summary>
            
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineString.Reverse">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.LineString"/> whose coordinates are in the reverse order of this objects.
            </summary>
            <returns>A <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.LineString"/> with coordinates in the reverse order.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineString.IsCoordinate(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Returns true if the given point is a vertex of this <c>LineString</c>.
            </summary>
            <param name="pt">The <c>Coordinate</c> to check.</param>
            <returns><c>true</c> if <c>pt</c> is one of this <c>LineString</c>'s vertices.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineString.ComputeEnvelopeInternal">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineString.EqualsExact(MapWindow.Interfaces.Geometries.IGeometry,System.Double)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <param name="tolerance"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineString.Apply(MapWindow.Interfaces.Geometries.ICoordinateFilter)">
            <summary>
            
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineString.Apply(MapWindow.Interfaces.Geometries.IGeometryFilter)">
            <summary>
            
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineString.Apply(MapWindow.Interfaces.Geometries.IGeometryComponentFilter)">
            <summary>
            
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineString.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineString.Normalize">
            <summary> 
            Normalizes a <c>LineString</c>.  A normalized linestring
            has the first point which is not equal to it's reflected point
            less than the reflected point.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineString.IsEquivalentClass(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineString.CompareToSameClass(System.Object)">
            <summary>
            
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineString.#ctor(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[])">
            <summary>
            Initializes a new instance of the <see cref="T:LineString"/> class.
            </summary>        
            <remarks>
            For create this <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/> is used a standard <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory"/> 
            with <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel"/> <c> == </c> <see cref="F:MapWindow.Interfaces.Geometries.PrecisionModels.Floating"/>.
            </remarks>
            <param name="points">The coordinates used for create this <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.LineString"/>.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineString.#ctor(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Creates a new linestring from an array of ICoordinate
            </summary>
            <param name="points"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LineString.GetCoordinateBaseN(System.Int32)">
            <summary>
            Gets a specific coordinate
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineString.Coordinates">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineString.CoordinateSequence">
            <summary>
            Gets the actual listing of point values as an ICoordinateSequence interface
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineString.Coordinate">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineString.Dimension">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineString.BoundaryDimension">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineString.IsEmpty">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineString.NumPoints">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineString.StartPoint">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineString.EndPoint">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineString.IsClosed">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineString.IsRing">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineString.GeometryType">
            <summary>
            A clarifier that identifies the type of geometry as a LineString
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineString.Length">
            <summary>  
            Returns the length of this <c>LineString</c>
            </summary>
            <returns>The length of the polygon.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineString.IsSimple">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineString.Boundary">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineString.Item(System.Int32)">
            <summary>
            
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineString.Count">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LineString.Angle">
            <summary>
            Returns the value of the angle between the <see cref="P:MapWinGeoProc.NTS.Topology.Geometries.LineString.StartPoint"/>
            and the <see cref="P:MapWinGeoProc.NTS.Topology.Geometries.LineString.EndPoint"/>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LinearRing.#ctor(MapWindow.Interfaces.Geometries.ICoordinateSequence,MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory)">
            <summary>
            Constructs a <c>LinearRing</c> with the given points.
            </summary>
            <param name="points">
            Points forming a closed and simple linestring, or
            <c>null</c> or an empty array to create the empty point.
            This array must not contain <c>null</c> elements.
            </param>
            <param name="factory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LinearRing.#ctor(MapWindow.Interfaces.Geometries.ILineStringBase)">
            <summary>
            creates a LinearRing given a basic linestring 
            </summary>
            <param name="linestringbase">the base data to make into a linear ring</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LinearRing.#ctor(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[])">
            <summary>
            Initializes a new instance of the <see cref="T:LinearRing"/> class.
            </summary>
            <param name="points">The points used for create this instance.</param>
            <remarks>
            For create this <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/> is used a standard <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory"/> 
            with <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel"/> <c> == </c> <see cref="F:MapWindow.Interfaces.Geometries.PrecisionModels.Floating"/>.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.LinearRing.#ctor(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Creates a new instance of a Linear Ring using only ICoordinate
            </summary>
            <param name="points"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LinearRing.IsSimple">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LinearRing.GeometryType">
            <summary>
            Specifies that this is a LinearRing
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.LinearRing.IsClosed">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions.On">
            <summary>
             An indicator that a Location is <c>on</c> a GraphComponent (0)
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions.Left">
            <summary>
            An indicator that a Location is to the <c>left</c> of a GraphComponent (1)
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions.Right">
            <summary> 
            An indicator that a Location is to the <c>right</c> of a GraphComponent (2)
            </summary> 
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions.Parallel">
            <summary> 
            An indicator that a Location is <c>is parallel to x-axis</c> of a GraphComponent (-1)
            /// </summary> 
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.Position">
            <summary> 
            A Position indicates the position of a Location relative to a graph component
            (Node, Edge, or Area).
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Position.Opposite(MapWinGeoProc.NTS.Topology.GeometriesGraph.Positions)">
            <summary> 
            Returns Positions.Left if the position is Positions.Right, 
            Positions.Right if the position is Left, or the position
            otherwise.
            </summary>
            <param name="position"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointArea">
            <summary> 
            Computes a point in the interior of an area point.
            Algorithm:
            Find the intersections between the point
            and the horizontal bisector of the area's envelope
            Pick the midpoint of the largest intersection (the intersections
            will be lines and points)
            Note: If a fixed precision model is used,
            in some cases this method may return a point
            which does not lie in the interior.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointArea.Avg(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointArea.#ctor(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointArea.Add(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary> 
            Tests the interior vertices (if any)
            defined by a linear Geometry for the best inside point.
            If a Geometry is not of dimension 1 it is not tested.
            </summary>
            <param name="geom">The point to add.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointArea.AddPolygon(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary> 
            Finds a reasonable point at which to label a Geometry.
            </summary>
            <param name="geometry">The point to analyze.</param>
            <returns> 
            The midpoint of the largest intersection between the point and
            a line halfway down its envelope.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointArea.WidestGeometry(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geometry"></param>
            <returns>
            If point is a collection, the widest sub-point; otherwise,
            the point itself.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointArea.WidestGeometry(MapWindow.Interfaces.Geometries.IGeometryCollection)">
            <summary>
            
            </summary>
            <param name="gc"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointArea.HorizontalBisector(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geometry"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointArea.Centre(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary> 
            Returns the centre point of the envelope.
            </summary>
            <param name="envelope">The envelope to analyze.</param>
            <returns> The centre of the envelope.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Algorithm.InteriorPointArea.InteriorPoint">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.CGAlgorithms">
            <summary>
            Specifies and implements various fundamental Computational Geometric algorithms.
            The algorithms supplied in this class are robust for double-precision floating point.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Algorithm.CGAlgorithms.Clockwise">
            <summary> 
            A value that indicates an orientation of clockwise, or a right turn.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Algorithm.CGAlgorithms.Right">
            <summary> 
            A value that indicates an orientation of clockwise, or a right turn.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Algorithm.CGAlgorithms.CounterClockwise">
            <summary>
            A value that indicates an orientation of counterclockwise, or a left turn.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Algorithm.CGAlgorithms.Left">
            <summary>
            A value that indicates an orientation of counterclockwise, or a left turn.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Algorithm.CGAlgorithms.Collinear">
            <summary>
            A value that indicates an orientation of collinear, or no turn (straight).
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Algorithm.CGAlgorithms.Straight">
            <summary>
            A value that indicates an orientation of collinear, or no turn (straight).
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CGAlgorithms.OrientationIndex(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary> 
            Returns the index of the direction of the point <c>q</c>
            relative to a vector specified by <c>p1-p2</c>.
            </summary>
            <param name="p1">The origin point of the vector.</param>
            <param name="p2">The final point of the vector.</param>
            <param name="q">The point to compute the direction to.</param>
            <returns> 
            1 if q is counter-clockwise (left) from p1-p2,
            -1 if q is clockwise (right) from p1-p2,
            0 if q is collinear with p1-p2.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CGAlgorithms.IsPointInRing(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary> 
            Test whether a point lies inside a ring.
            The ring may be oriented in either direction.
            If the point lies on the ring boundary the result of this method is unspecified.
            This algorithm does not attempt to first check the point against the envelope
            of the ring.
            </summary>
            <param name="p">Point to check for ring inclusion.</param>
            <param name="ring">Assumed to have first point identical to last point.</param>
            <returns><c>true</c> if p is inside ring.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CGAlgorithms.IsOnLine(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary> 
            Test whether a point lies on the line segments defined by a
            list of coordinates.
            </summary>
            <param name="p"></param>
            <param name="pt"></param>
            <returns> 
            <c>true</c> true if
            the point is a vertex of the line or lies in the interior of a line
            segment in the linestring.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CGAlgorithms.IsCCW(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Computes whether a ring defined by an array of <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/>s is oriented counter-clockwise.
            The list of points is assumed to have the first and last points equal.
            This will handle coordinate lists which contain repeated points.
            This algorithm is only guaranteed to work with valid rings.
            If the ring is invalid (e.g. self-crosses or touches),
            the computed result may not be correct.
            </summary>&gt;
            <param name="ring"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CGAlgorithms.ComputeOrientation(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Computes the orientation of a point q to the directed line segment p1-p2.
            The orientation of a point relative to a directed line segment indicates
            which way you turn to get to q after travelling from p1 to p2.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="q"></param>
            <returns> 
            1 if q is counter-clockwise from p1-p2,
            -1 if q is clockwise from p1-p2,
            0 if q is collinear with p1-p2-
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CGAlgorithms.DistancePointLine(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary> 
            Computes the distance from a point p to a line segment AB.
            Note: NON-ROBUST!
            </summary>
            <param name="p">The point to compute the distance for.</param>
            <param name="A">One point of the line.</param>
            <param name="B">Another point of the line (must be different to A).</param>
            <returns> The distance from p to line segment AB.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CGAlgorithms.DistancePointLinePerpendicular(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary> 
            Computes the perpendicular distance from a point p
            to the (infinite) line containing the points AB
            </summary>
            <param name="p">The point to compute the distance for.</param>
            <param name="A">One point of the line.</param>
            <param name="B">Another point of the line (must be different to A).</param>
            <returns>The perpendicular distance from p to line AB.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CGAlgorithms.DistanceLineLine(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary> 
            Computes the distance from a line segment AB to a line segment CD.
            Note: NON-ROBUST!
            </summary>
            <param name="A">A point of one line.</param>
            <param name="B">The second point of the line (must be different to A).</param>
            <param name="C">One point of the line.</param>
            <param name="D">Another point of the line (must be different to A).</param>
            <returns>The distance from line segment AB to line segment CD.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CGAlgorithms.SignedArea(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            Returns the signed area for a ring.  The area is positive ifthe ring is oriented CW.
            </summary>
            <param name="ring"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CGAlgorithms.Length(MapWindow.Interfaces.Geometries.ICoordinateSequence)">
            <summary> 
            Computes the length of a linestring specified by a sequence of points.
            </summary>
            <param name="pts">The points specifying the linestring.</param>
            <returns>The length of the linestring.</returns>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.BooleanElement">
            <summary>
            A modular component that displays a checkbox to retrieve true-false parameters for functions.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.BooleanElement.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.BooleanElement.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.BooleanElement.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.BooleanElement.cmdHelp">
            <summary>
            Help button
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.BooleanElement.groupBox1">
            <summary>
            A group box to surround individual components
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.BooleanElement.#ctor">
            <summary>
            Initializes a new instance of the BooleanElement class
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.BooleanElement.OnClick(System.EventArgs)">
            <summary>
            Called to fire the click event for this element
            </summary>
            <param name="e">A mouse event args thingy</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.BooleanElement.OnHelpButtonPressed(MapWinGeoProc.Dialogs.HelpPannelEventArgs)">
            <summary>
            Called when the help button has been pressed
            </summary>
            <param name="e">A HelpPanelEventArgs parameter with a new help title, text and image.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.BooleanElement.OnHelpContextChanged(MapWinGeoProc.Dialogs.HelpPannelEventArgs)">
            <summary>
            Called when the data entry field is entered to change a topic, but only if panel is visible
            </summary>
            <param name="e">A HelpPanelEventArgs parameter with a new help title, text and image.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.BooleanElement.OnResizeStarted">
            <summary>
            Fires when someone uses the resize grip to resize the element
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.BooleanElement.OnResizeEnded">
            <summary>
            Fires when someone has stopped resizing with the grip
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.BooleanElement.HelpText_Append(System.String)">
            <summary>
            Appends a string to the end of the help content
            </summary>
            <param name="HelpText"></param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.BooleanElement.HelpText_Clear(System.String)">
            <summary>
            Clears the existing help content.
            </summary>
            <param name="HelpText"></param>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.BooleanElement.Clicked">
            <summary>
            Fires when the inactive areas around the controls are clicked on the element.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.BooleanElement.HelpButtonPressed">
            <summary>
            Fires when the help button is clicked.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.BooleanElement.HelpContextChanged">
            <summary>
            Fires when the the user enters a data entry region.  Changes help without opening panel.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.BooleanElement.ResizeStarted">
            <summary>
            Fires when the element is being resized.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.BooleanElement.ResizeEnded">
            <summary>
            Fires when the element is no longer being resized.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BooleanElement.Caption">
            <summary>
            Controls the caption for this element (the group box text)
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BooleanElement.HelpButtonVisible">
            <summary>
            Gets or sets whether or not the help button is visible.
            The help button that looks like a question mark will force open the help pannel
            and populate it with the help content from this control.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BooleanElement.ResizeGripVisible">
            <summary>
            Gets or sets whether a resize grip is provided for the user to change the dimensions of the control.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BooleanElement.AllowGripResize">
            <summary>
            Gets or sets a boolean.  True if the user is allowed to adjust the width of the 
            element to better display longer filenames.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BooleanElement.MaxWidth">
            <summary>
            Gets or sets the maximum allowable width for dynamic resize.  The dialog form sets this
            dynamically to the size of the container panel.  This is because the behavior for
            resizing larger than the size of the panel is erratic because of the autoscrolling
            behavior.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BooleanElement.MinWidth">
            <summary>
            Gets or sets the minimum allowable width for dynamic resizing.  This specifically affects
            the behavior when the user uses the grip to resize the element.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BooleanElement.HelpImage">
            <summary>
            Gets or Sets the image that will appear after the help text in the panel, if any.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BooleanElement.HelpText">
            <summary>
            Gets or Sets the text to appear in the help pannel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BooleanElement.HelpTitle">
            <summary>
            Gets or Sets the title to be shown in the help panel.  Defaults to the Caption.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BooleanElement.WikiAddress">
            <summary>
            Gets or Sets the web address to use from the wiki button in the help panel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BooleanElement.DefaultImage">
            <summary>
            Gets or Sets the default image that will be used in the help panel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BooleanElement.AlternateImage">
            <summary>
            Gets or Sets the alternate image that can be used in the help panel instead.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BooleanElement.Value">
            <summary>
            Gets or sets a boolean value that is true if the parameter is checked.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BooleanElement.Text">
            <summary>
            Gets or sets the label that describes the checkbox.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.BooleanElement.CheckboxEnabled">
            <summary>
            Gets or sets whether the checkbox is enabled
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.BooleanElement.LightStatus">
            <summary>
            Indicates the allowed values for the status of the element, illustrated by the light
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.BooleanElement.LightStatus.Empty">
            <summary>
            Indicates that no value has been set for this yet.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.BooleanElement.LightStatus.Ok">
            <summary>
            Indicates that the element parameter is ok and won't halt.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.BooleanElement.LightStatus.Error">
            <summary>
            Indicates that the element value will cause an error.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.BooleanElement.HelpButtonHandler">
            <summary>
            Public delegate for when someone presses the help button
            </summary>
            <param name="sender">The element sending the event</param>
            <param name="e">HelpPannelEventArgs with help title, text and an image</param>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.BooleanElement.ResizeStartedHandler">
            <summary>
            Delegate for the when someone starts resizing an element
            </summary>
            <param name="sender">The element being resized</param>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.BooleanElement.ResizeEndedHandler">
            <summary>
            Fires when the element is no longer being resized.
            </summary>
            <param name="sender"></param>
        </member>
        <member name="T:MapWinGeoProc.Topology.Vector">
            <summary>
            Contains a magnitude and direction
            Supports more fundamental calculations than LineSegment, rather than topological functions
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.Vector.X">
            <summary>
            The X component of the vector
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.Vector.Y">
            <summary>
            The Y component of the vector
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.Vector.Z">
            <summary>
            The Z component of the vector
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.#ctor(MapWinGeoProc.Topology.Point)">
            <summary>
            Creates a new vector from the Point, assuming the tail of the vector is the origin
            </summary>
            <param name="Point">The Point to create a vector from</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.#ctor(MapWinGeoProc.Topology.LineSegment)">
            <summary>
            Creates a new vector from a line segment, assuming that the direction is from the start point to the end point
            </summary>
            <param name="LineLineSegment">A Topology.LineSegment object to turn into a vector</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.#ctor(MapWinGeoProc.Topology.Point,MapWinGeoProc.Topology.Point)">
            <summary>
            Creates a new vector from two points, assuming that the direction is from the start point to the end point
            and uses the StartPoint as the origin.
            </summary>
            <param name="StartPoint">The beginning of the vector</param>
            <param name="EndPoint">The end of the vector</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a mathematical vector from X1, Y1 to X2, Y2
            </summary>
            <param name="x1">Double, The X coordinate of the start point for the vector</param>
            <param name="y1">Double, The Y coordinate of the start point for the vector </param>
            <param name="z1">Double, the Z coordinate of the start point for the vector</param>
            <param name="x2">Double, The X coordinate of the end point for the vector</param>
            <param name="y2">Double, The Y coordinate of the end point for the vector</param>
            <param name="z2">Double, the Z coordinate of the end point for the vector</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Creates a mathemtacal vector from the origin to the x, y, z coordinates
            </summary>
            <param name="x">Double, the X coordinate from the origin</param>
            <param name="y">Double, the Y coordinate from the origin</param>
            <param name="z">Double, the Z coordinate from the origin</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.#ctor(System.Double,MapWinGeoProc.Topology.Angle,MapWinGeoProc.Topology.Angle)">
            <summary>
            Creates a mathematical vector from the origin with the new magnitude and directions specified
            </summary>
            <param name="newMagnitude">Double, the length of the vector</param>
            <param name="Theta">The angle in the x-y plane</param>
            <param name="Phi">The angle in the z direction</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.#ctor(System.Double,MapWinGeoProc.Topology.Angle)">
            <summary>
            Creates a mathematical vector in the X-Y plane with angle Theta
            </summary>
            <param name="newMagnitude">Double, The magnitude of the vector</param>
            <param name="Theta">Angle, The direction measured counterclockwise from Positive X Axis </param>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.Norm2">
            <summary>
            Returns the square of the distance of the vector without taking the square root
            This is the same as doting the vector with itself
            </summary>
            <returns>Double, the square of the distance between the vectors</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.Normalize">
            <summary>
            Normalizes the vector.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.Cross(MapWinGeoProc.Topology.Vector)">
            <summary>
            Returns the cross product of this vector with the specified vector V
            </summary>
            <param name="V">The vector to perform a cross product against</param>
            <returns>A vector result from the inner product</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.DividedBy(System.Double)">
            <summary>
            Returns the quotient of this vector with Scalar
            </summary>
            <param name="Scalar">Double, a value to divide all the members of this vector by</param>
            <returns>A vector where each element has been divided by the scalar</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.DividedBy(MapWinGeoProc.Topology.Vector)">
            <summary>
            Divides each of the elements of this vector by the elements of V
            </summary>
            <param name="V">Vector, the vector to divide this vector by</param>
            <returns>A vector result from the division</returns>
            <remarks>To prevent division by 0, members of V that are 0 will produce an output
            vector with 0 in that column</remarks>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.Dot(MapWinGeoProc.Topology.Vector)">
            <summary>
            Returns the dot product of this vector with V2
            </summary>
            <param name="V">The vector to perform an inner product against</param>
            <returns>A Double result from the inner product</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.Intersects(MapWinGeoProc.Topology.Vector)">
            <summary>
            Compares the values of each element, and if all the elements are equal, returns true.
            </summary>
            <param name="V">The vector to compare against this vector.</param>
            <returns>Boolean, true if all the elements have the same value.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.Equals(MapWinGeoProc.Topology.Vector)">
            <summary>
            Override  for definition of equality for vectors
            </summary>
            <param name="V">A vector to compare with</param>
            <returns>true if the X, Y, and Z coordinates are all equal</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.Equals(System.Object)">
            <summary>
            Checks first to make sure that both objects are vectors.  If they are, 
            then it checks to determine whether or not the X, Y and Z values are equal.
            </summary>
            <param name="Vect">The object to test against</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.GetHashCode">
            <summary>
            Returns the hash code.. or something
            </summary>
            <returns>A hash code I guess</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.Minus(MapWinGeoProc.Topology.Vector)">
            <summary>
            Subtracts each element of V from each element of this vector
            </summary>
            <param name="V">Vector, the vector to subtract from this vector</param>
            <returns>A vector result from the subtraction</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.Plus(MapWinGeoProc.Topology.Vector)">
            <summary>
            Adds each of the elements of V to the elements of this vector
            </summary>
            <param name="V">Vector, the vector to add to this vector</param>
            <returns>A vector result from the addition</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.Times(System.Double)">
            <summary>
            Returns the scalar product of this vector against a scalar
            </summary>
            <param name="Scalar">Double, a value to multiply against all the members of this vector</param>
            <returns>A vector multiplied by the scalar</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.Times(MapWinGeoProc.Topology.Vector)">
            <summary>
            Multiplies each of the elements of V to the elements of this vector
            </summary>
            <param name="V">Vector, the vector to multply with this vector</param>
            <returns>A vector result from the multiplication</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.ToMWPoint">
            <summary>
            A MapWinGIS.Point Representing the tip of the vector,
            where the beginning of the vector is at the origin 
            /// </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.ToPoint">
            <summary>
            Assuming the vector starts at the origin of 0,0,0, this function returns
            a Point representing the tip of the vector.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.ToLineSegment">
            <summary>
            Returns a new segment from this vector, where the StartPoint is 0, 0, 0
            and the End Point is the tip of this vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.AddVectors(MapWinGeoProc.Topology.Vector,MapWinGeoProc.Topology.Vector)">
            <summary>
            Adds the vectors U and V using vector addition, which adds the corresponding components
            </summary>
            <param name="U">One vector to be added</param>
            <param name="V">A second vector to be added</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.CrossProduct(MapWinGeoProc.Topology.Vector,MapWinGeoProc.Topology.Vector)">
            <summary>
            Returns the Cross Product of two vectors U and V
            </summary>
            <param name="U">Vector, the first input vector</param>
            <param name="V">Vector, the second input vector</param>
            <returns>A Vector containing the cross product of U and V</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.DivideVectors(MapWinGeoProc.Topology.Vector,MapWinGeoProc.Topology.Vector)">
            <summary>
            Divides the components of vector U by the respective components
            ov vector V and returns the resulting vector. 
            </summary>
            <param name="U">Vector Dividend (Numbers to be divided)</param>
            <param name="V">Vector Divisor (Numbers to divide by)</param>
            <returns>A Vector quotient of U and V</returns>
            <remarks>To prevent divide by 0, if a 0 is in V, it will return 0 in the result</remarks>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.DivideVectors(MapWinGeoProc.Topology.Vector,System.Double)">
            <summary>
            Multiplies each component of vector U by the Scalar value
            </summary>
            <param name="U">A vector representing the vector to be multiplied</param>
            <param name="Scalar">Double, the scalar value to mulitiply the vector components by</param>
            <returns>A Vector representing the vector product of vector U and the Scalar</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.DotProduct(MapWinGeoProc.Topology.Vector,MapWinGeoProc.Topology.Vector)">
            <summary>
            Returns the Inner Product also known as the dot product of two vectors, U and V
            </summary>
            <param name="U">The input vector</param>
            <param name="V">The vector to take the inner product against U</param>
            <returns>a Double containing the dot product of U and V</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.Norm2(MapWinGeoProc.Topology.Vector)">
            <summary>
            Non-static version of taking the square distance for a vector
            </summary>
            <param name="U">The vector to find the square of the distance of</param>
            <returns>Double, the square of the distance</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.MultiplyVectors(MapWinGeoProc.Topology.Vector,System.Double)">
            <summary>
            Multiplies each component of vector U by the Scalar value
            </summary>
            <param name="U">A vector representing the vector to be multiplied</param>
            <param name="Scalar">Double, the scalar value to mulitiply the vector components by</param>
            <returns>A Vector representing the vector product of vector U and the Scalar</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.SubtractVectors(MapWinGeoProc.Topology.Vector,MapWinGeoProc.Topology.Vector)">
            <summary>
            Subtracts Vector V from Vector U
            </summary>
            <param name="U">A Vector to subtract from</param>
            <param name="V">A Vector to subtract</param>
            <returns>The Vector difference U - V</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.op_Addition(MapWinGeoProc.Topology.Vector,MapWinGeoProc.Topology.Vector)">
            <summary>
            Adds the vectors U and V using vector addition, which adds the corresponding components
            </summary>
            <param name="U">One vector to be added</param>
            <param name="V">A second vector to be added</param>
            <returns>The sum of the vectors</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.op_Equality(MapWinGeoProc.Topology.Vector,MapWinGeoProc.Topology.Vector)">
            <summary>
            Tests equality
            </summary>
            <param name="U">A Vector to test</param>
            <param name="V">A Vector to test</param>
            <returns>Returns true if X, Y and Z are equal</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.op_Inequality(MapWinGeoProc.Topology.Vector,MapWinGeoProc.Topology.Vector)">
            <summary>
            Tests equality
            </summary>
            <param name="U">A Vector to test</param>
            <param name="V">A Vector to test</param>
            <returns>Returns true if X, Y and Z are equal</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.op_ExclusiveOr(MapWinGeoProc.Topology.Vector,MapWinGeoProc.Topology.Vector)">
            <summary>
            Returns the Cross Product of two vectors U and V
            </summary>
            <param name="U">Vector, the first input vector</param>
            <param name="V">Vector, the second input vector</param>
            <returns>A Vector containing the cross product of U and V</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.op_Division(MapWinGeoProc.Topology.Vector,MapWinGeoProc.Topology.Vector)">
            <summary>
            Divides the components of vector U by the respective components
            ov vector V and returns the resulting vector. 
            </summary>
            <param name="U">Vector Dividend (Numbers to be divided)</param>
            <param name="V">Vector Divisor (Numbers to divide by)</param>
            <returns>A Vector quotient of U and V</returns>
            <remarks>To prevent divide by 0, if a 0 is in V, it will return 0 in the result</remarks>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.op_Division(MapWinGeoProc.Topology.Vector,System.Double)">
            <summary>
            Multiplies each component of vector U by the Scalar value
            </summary>
            <param name="U">A vector representing the vector to be multiplied</param>
            <param name="Scalar">Double, the scalar value to mulitiply the vector components by</param>
            <returns>A Vector representing the vector product of vector U and the Scalar</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.op_Multiply(MapWinGeoProc.Topology.Vector,MapWinGeoProc.Topology.Vector)">
            <summary>
            Returns the Inner Product also known as the dot product of two vectors, U and V
            </summary>
            <param name="U">The input vector</param>
            <param name="V">The vector to take the inner product against U</param>
            <returns>a Double containing the dot product of U and V</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.op_Multiply(System.Double,MapWinGeoProc.Topology.Vector)">
            <summary>
            Multiplies the vectors U and V using vector multiplication,
            which adds the corresponding components
            </summary>
            <param name="Scalar">A scalar to multpy to the vector</param>
            <param name="V">A vector to be multiplied</param>
            <returns>The scalar product for the vectors</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.op_Multiply(MapWinGeoProc.Topology.Vector,System.Double)">
            <summary>
            Multiplies each component of vector U by the Scalar value
            </summary>
            <param name="U">A vector representing the vector to be multiplied</param>
            <param name="Scalar">Double, the scalar value to mulitiply the vector components by</param>
            <returns>A Vector representing the vector product of vector U and the Scalar</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Vector.op_Subtraction(MapWinGeoProc.Topology.Vector,MapWinGeoProc.Topology.Vector)">
            <summary>
            Subtracts Vector V from Vector U
            </summary>
            <param name="U">A Vector to subtract from</param>
            <param name="V">A Vector to subtract</param>
            <returns>The Vector difference U - V</returns>
        </member>
        <member name="P:MapWinGeoProc.Topology.Vector.Magnitude">
            <summary>
            The Euclidean distance from the origin to the tip of the 3 dimensional vector
            Setting the magntiude won't change the direction.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology.Vector.Magnitude2D">
            <summary>
            Returns the magnitude of the projection of the vector onto the X-Y plane
            Setting this magnitude will not affect Z, which should be adjusted separately
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology.Vector.Phi">
            <summary>
            Obtains the angle above the X-Y plane.  Positive towards positive Z.
            Values are in radians from -Pi/2 to Pi/2
            Setting this value when no magnitude exists results in a unit vector with angle phi in the X direction.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology.Vector.Theta">
            <summary>
            Represents the angle in the X-Y plane.  0 along the positive X axis, and increasing counterclockwise
            Values are in Radians.  Setting this value when no X-Y magnitude exists results in a unit vector
            between X and Y, but does not affect Z, so you may have something other than a unit vector in 3-D.
            Set theta before phi in order to obtain a unit vector in 3-D space.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Topology2D.Polygon">
            <summary>
            A structure representing a single closed polygon.  This would represent a single part
            of a polygon shape.  No holes.  Unlike a shapefile, this polygon does not list the
            first point again at the end.  (This prevents confusion when adding points to the
            list.)
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.Polygon.m_Shell">
            <summary>
            List of points.  For normal use, please use Add_Point or Insert_Point to correctly
            handle extents and prevent duplicate entries
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.#ctor">
            <summary>
            Creates a new empty instance of a polygon class.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.Contains(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.Crosses(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.Disjoint(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.Equals(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.Intersects(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.Overlaps(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.Touches(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.Within(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.AsBinary">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.AsText">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.Boundary">
            <summary>
            Returns the LinearRing that is the shell
            </summary>
            <returns>LinearRing</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.Buffer(System.Double)">
            <summary>
            Not Implemented
            </summary>
            <param name="Distance"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.ConvexHull">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.Difference(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.Distance(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.Equals(System.Object)">
            <summary>
            Not Implemented
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.GetHashCode">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.Intersection(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.Relate(MapWinGeoProc.Topology2D.Geometry,System.String)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <param name="IntersectionPatternMatrix"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.ShortestPathTo(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.SymDifference(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.ToString">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.Union(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.Copy">
            <summary>
            Returns a new instance of the Polygon class with the same values as this object.
            </summary>
            <returns>Topology2D.Polygon with identical points.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.Intersects(MapWinGeoProc.Topology2D.Point)">
            <summary>
            Only returns true if the point is in the same plane as the polygon
            and the polygon encloses the point.  Touching a node is considered intersecting.
            </summary>
            <param name="Point"></param>
            <returns>Boolean, true if the sum of all the angles = 360</returns>
            <remarks>The code for cross-type intersect is in the larger structure</remarks>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.Intersects(MapWinGeoProc.Topology2D.LineString)">
            <summary>
            Returns true if any segment from the polyline touches any segment from the borders of this polygon
            or in the case where no segments touch, the first point is intersects with this polygon.
            </summary>
            <param name="Poly">The Polyline to test.</param>
            <returns>Boolean, true if the specified polyline intersects with this polygon.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.Intersects(MapWinGeoProc.Topology2D.Polygon)">
            <summary>
            Returns true if any of the border segments touch or no segments touch but one point
            from either polygon is inside the other polygon.  Makes sure rectangular extents
            overlap first.
            </summary>
            <param name="Poly">A Polygon object to compare to this polygon.</param>
            <returns>Boolean, true if the the polygons intersect.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.TouchesTheBoundaryOf(MapWinGeoProc.Topology2D.Envelope)">
            <summary>
            Tests to see if the distance between any segments is 0.  Will test extents
            first, since if the extents don't overlap, then neither do any segments.
            
            </summary>
            <param name="Ext">The extents to compare with </param>
            <returns>True if the borders of this polygon touch any of the four segments that
            define the outer boundaries of the specified extents object Ext.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Polygon.TouchesTheBoundaryOf(MapWinGeoProc.Topology2D.Polygon)">
            <summary>
            Tests to see if the extents overlap.  If they do, it will check
            the segments from the overlapping region for an intersection.
            </summary>
            <param name="Poly">The polygon to test against this polygon.</param>
            <returns>Boolean, true if there are two segments that touch.</returns>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.Polygon.Dimension">
            <summary>
            Returns the dimension of the geometry.  In this case, polygons are 2 dimensional,
            so we return a 2.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.Polygon.Envelope">
            <summary>
            The extents that form a bounding box around the polyline.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.Polygon.Shell">
            <summary>
            A list of points that make up the outer shell of the polygon
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.Polygon.Holes">
            <summary>
            This is a collection of linear rings defining holes in the polygon
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.Polygon.NumHoles">
            <summary>
            Returns the number of interior linear rings that make up "holes" in the polygon.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Topology2D.LineSegment">
            <summary>
            Stores a set of double values that represents a line segment.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.LineSegment.X1">
            <summary>
            The X coordinate of the Start Point of the segment
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.LineSegment.Y1">
            <summary>
            The Y coordinate of the Start Point of the segment
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.LineSegment.X2">
            <summary>
            The Z coordinate of the Start Point of the segment
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.LineSegment.Y2">
            <summary>
            The Y coordinate of the End Point of the segment
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.#ctor">
            <summary>
            Creates a new blank instance of a segment with 0 for values.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.#ctor(MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Creates a new segment from the vector, assuming that the startpoint of the segment
            is the origin and the endpoint of the segment is the tail of the vector.
            </summary>
            <param name="V">The Vector to create a segment from.</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.#ctor(System.Collections.Generic.List{MapWinGeoProc.Topology2D.Coordinate})">
            <summary>
            Creates a new instance of a segment using a list of two coordinates
            </summary>
            <param name="Coords">A list of coordinates to use when building the segment</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.#ctor(MapWinGIS.Point,MapWinGIS.Point)">
            <summary>
            Stores a set of double values that represents a line segment.
            </summary>
            <param name="StartPoint">A MapWinGIS.Point representing the beginning of the line segment</param>
            <param name="EndPoint">A MapWinGIS.Point representing the end of the line segment</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.#ctor(MapWinGeoProc.Topology2D.Point,MapWinGeoProc.Topology2D.Point)">
            <summary>
            Stores values representing a line segment
            </summary>
            <param name="StartPoint">A Topology.Point representing the start point of the segment</param>
            <param name="EndPoint">A Topology.Point representing the end point of the segment</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.#ctor(MapWinGeoProc.Topology2D.Coordinate,MapWinGeoProc.Topology2D.Coordinate)">
            <summary>
            Stores values representing a line segment
            </summary>
            <param name="Start">A Segment representing the start location</param>
            <param name="End">A Segment representing the end location</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.#ctor(MapWinGeoProc.Topology2D.Point,MapWinGeoProc.Topology2D.Vector)">
            <summary>
            Creates a new segment from a point and a vector.  The point represents the start point
            or tail of the vector, and the vector is added to that point to find the second point.
            </summary>
            <param name="StartPoint">Point representing one of the points of the segment</param>
            <param name="StartToEnd">Vector representing the path of the segment</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Stores a set of double values that represents a line segment.
            </summary>
            <param name="x1">A Double representing the X coordinate of the beginning of the line segment</param>
            <param name="y1">A Double representing the Y coordinate of the beginning of the line segment</param>
            <param name="x2">A Double representing the X coordinate of the end of the line segment</param>
            <param name="y2">A Double representing the Y coordinate of the end of the line segment</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.LocationByX(System.Double,MapWinGeoProc.Topology2D.Point@)">
            <summary>
            Given a segment, we try fix the value of one coordinate to solve
            for the other two.
            </summary>
            <param name="Xcoordinate">The value to use as X</param>
            <param name="Intercept">The location of the segment when X = Xcoordinate </param>
            <returns>Boolean.  False if there is no valid intersection.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.LocationByY(System.Double,MapWinGeoProc.Topology2D.Point@)">
            <summary>
            Given a segment, we try fix the value of one coordinate to solve
            for the other two.
            </summary>
            <param name="Ycoordinate">The value to use as Y</param>
            <param name="Intercept">The location of the segment when Y = Ycoordinate </param>
            <returns>Boolean.  False if there is no valid intersection.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.Contains(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            If geom is a point, this will return true if geom is on this line.
            In order for a LineSegment to be within this
            segment, its intersection must be equal to the supplied geom.
            </summary>
            <param name="geom">Any geometry</param>
            <returns>Boolean, true if the geometry is contained by this LineSegment</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.Crosses(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Can't be true for points.
            True if the segments intersect in a point, but the endpoints don't intersect.
            </summary>
            <param name="geom">Any geometry.</param>
            <returns>Boolean, true if the geometries cross.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.Disjoint(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Tests this segment with a geometry to see if they are disjoint.
            </summary>
            <param name="geom">Any class derived from the geometry class.</param>
            <returns>Boolean, true if the two geometries are disjoint.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.Equals(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            This form of equals satisfies the geometry requirements.
            There is also an overload that compares to any object.
            They will only be found equal, however if they are LineSegments.
            </summary>
            <param name="geom">Any geometry.</param>
            <returns>Boolean, true if the LineSegments are the same (endpoints can be flipped.)</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.Intersects(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Determines whether or not this LineSegment intersects with the specified geometry.
            </summary>
            <param name="geom">Any of the derivative classes of Topology2D.Geometry</param>
            <returns>Boolean, true if an intersection occurs with this LineSegment</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.Overlaps(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            This is a special form of intersection for Segments.  Two segments overlap
            if they intersect to form a line segment that is not equal to either of the 
            contributing segments.  Returns false for points.  Defers to the code found in
            more complex objects for other intersections.
            </summary>
            <param name="geom">Any geometry.</param>
            <returns>Boolean, true if the two geometries overlap.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.Touches(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Tests whether this LineSegment touches the specified geometry.
            </summary>
            <param name="geom">Any geometry</param>
            <returns>Boolean, true if the geometries touch.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.Within(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Tests to see if this segment falls "within" another geometry.
            False for points.  True for segments where the intersection
            results in a segment that is the same as this segment.
            </summary>
            <param name="geom">The geometry to test.</param>
            <returns>Boolean, true if this geometry is within the specified geometry.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.AsBinary">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.AsText">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.Boundary">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.Buffer(System.Double)">
            <summary>
            Returns a polygon of Distance around this segment.
            </summary>
            <param name="Distance">The distance in map units of the radius of the buffer</param>
            <returns>Usually a Topology2D.Polygon representing a capsule like shape with end caps of radius r.
            Or a copy of this Topology2D.Point if the Radius is 0</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.Buffer(System.Double,System.Int32)">
            <summary>
            Returns a polygonal circle of Radius around this point.
            </summary>
            <param name="Distance">The distance in map units of the radius of the buffer</param>
            <param name="numPoints">Controls the number of points used in each cap. 
            More points will be smoother.  0 points creates a "flat" end cap.</param>
            <returns>Topology2D.Polygon representing a capsule like shape with end caps of radius r.
            Or a copy of this Topology2D.Point if the Radius is 0</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.Buffer(System.Double,System.Int32,MapWinGeoProc.Topology2D.Enums.BufferSide)">
            <summary>
            Returns a polygonal circle of Radius around this point.
            </summary>
            <param name="Distance">The distance in map units of the radius of the buffer</param>
            <param name="numPoints">Controls the number of points used in each cap. 
            More points will be smoother.  0 points creates a "flat" end cap.</param>
            <returns>Topology2D.Polygon representing a capsule like shape with end caps of radius r.
            <param name="Side">Side: Left or Right.  Specifies to only buffer one side of the segment.</param>
            Or a copy of this Topology2D.Point if the Radius is 0</returns>
            <remarks>This will not "clip" the buffers properly for a linestring.
            Use the linestring Buffer function for that.</remarks>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.ConvexHull">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.Difference(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.Distance(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Type
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.SqrDistance(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            This function returns the Square of the shortest distance 
            without taking any square roots
            </summary>
            <param name="geom">A simple geometry to determine the distance to</param>
            <returns>Double, the square of the shortest distance to the specified geometry</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.Equals(System.Object)">
            <summary>
            Not Implemented
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.GetHashCode">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.Intersection(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns>Geometry, null if no intersection occurs.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.Relate(MapWinGeoProc.Topology2D.Geometry,System.String)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <param name="IntersectionPatternMatrix"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.SymDifference(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.ToString">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.Union(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.Copy">
            <summary>
            Returns a new instance of the Topology2D.LineSegment class with the same values as this object.
            </summary>
            <returns>Topology2D.LineSegment with identical properties.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.Reverse">
            <summary>
            Flips the direction of this segment so that the startpoint becomes the endpoint.
            </summary>
            <returns>A LineSegment with the startpoint and endpoint reversed.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.ClosestPointTo(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Returns a Point representing the closest point.
            </summary>
            <param name="geom">The target point we want to be close to.</param>
            <returns>The point on this segment that is closest to the given geometry.  Null if
            the two features intersect.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.ShortestPathTo(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Returns a LineSegment starting with the closest point on this segment to the specified point
            and terminating at the specified point.  Returns null if the two geometries intersect.
            </summary>
            <param name="geom">The geometry to compare to this segment.</param>
            <returns>Topology2D LineSegment from this segemnt to the specified point deliniating the shortest path.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.ClosestPointOn(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            This retrieves the shortest path, but only returns the point that represents
            the closest point to this segment that is located on the segment specified.
            </summary>
            <param name="geom">The geometry containing the point to find.</param>
            <returns>MapWinGeoProc.Topology2D.Point the closest point to this segment on 
            the specified geometry.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.Intersects(MapWinGIS.Point)">
            <summary>
            Determines whether the point falls on a line segment
            </summary>
            <param name="Point">The MapWinGIS.Point to test agianst this segment</param>
            <returns>Boolean, true if the point is on the segment</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.Intersects(MapWinGeoProc.Topology2D.Point)">
            <summary>
            Determines whether the point falls on a line segment
            </summary>
            <param name="Point">The Point to test agianst this segment</param>
            <returns>Boolean, true if the point is on the segment</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.IsCompletelyWithin(MapWinGeoProc.Topology2D.Polygon)">
            <summary>
            Returns true if the entire segment is within the polygon,
            without touching or crossing any of the edges.
            </summary>
            <param name="Pgn">The polygon to investigate</param>
            <returns>Boolean, true if the segment is completely inside the polygon</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.IsParallelTo(MapWinGeoProc.Topology2D.LineSegment)">
            <summary>
            Returns true if the line segments are parallel
            </summary>
            <param name="Seg">The Topology.SegementD LineSegment to compare to </param>
            <returns>Boolean, true if the segments are parallel</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.IsPerpendicularTo(MapWinGeoProc.Topology2D.LineSegment)">
            <summary>
            Returns true if the line segments are perpendicular
            </summary>
            <param name="Seg">The LineSegment line segment to compare this segment with</param>
            <returns>Boolean, true if the segments are perpendicular</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.IsWithinADistanceOf(MapWinGIS.Point,System.Double)">
            <summary>
            Determines whether the point is within the buffer region of the line segment
            </summary>
            <param name="Point">A MapWinGIS.Point to check agianst this line segment</param>
            <param name="Distance">The double distance the point can be from the line and still be considered contained</param>
            <returns>Boolean, true if the point is within the buffer distance of the line segment</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.IsWithinADistanceOf(MapWinGeoProc.Topology2D.Point,System.Double)">
            <summary>
            Determines whether the point is within the buffer region of the line segment
            </summary>
            <param name="Point">A Point to check agianst this line segment</param>
            <param name="Dist">The double distance the point can be from the line and still be considered contained</param>
            <returns>Boolean, true if the point is within the buffer distance of the line segment</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.IsWithinADistanceOf(MapWinGeoProc.Topology2D.LineSegment,System.Double)">
            <summary>
            Determines whether this segment is within the buffer Distance specified of the line segment specified
            </summary>
            <param name="Seg">The LineSegment to compare to this segment</param>
            <param name="Dist">Double, the maximum distance between segments to allow</param>
            <returns>Boolean, true if this segment is within the specified distance of the other segment.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.SharesALineLineSegmentWith(MapWinGeoProc.Topology2D.LineSegment)">
            <summary>
            Since these are already segments, we just determine if the intersection is a valid line segment.
            If the segments intersect as a point, or don't intersect, this will return false.
            </summary>
            <param name="Seg">Topology2D.LineSegment to compare with.</param>
            <returns>Boolean, true if the two lines intersect in a segment.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.TouchesTheBoundaryOf(MapWinGeoProc.Topology2D.Envelope)">
            <summary>
            This returns true if either endpoint touchest any of the boundaries of the extents.
            This does not distinguish between whether this object is inside or outside or 
            overlapping with the extent borders, simply that one endpoint touches.
            </summary>
            <param name="Ext">The extents to compare to.</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.TouchesTheBoundaryOf(MapWinGeoProc.Topology2D.Polygon)">
            <summary>
            True if either endpoint is found in direct contact with any segment that makes up
            the polygon borders.
            </summary>
            <param name="Pgn">The polygon to compare against</param>
            <returns>Boolean, true if either endpoint of this segment touches any segment of the polygon.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.ToVector">
            <summary>
            Creates a new vector from this segment where the StartPoint becomes
            the beginning of the vector and the end point is the tip of the vector.
            </summary>
            <returns>A Vector from Point 1 to Point 2 in this segment</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.op_Equality(MapWinGeoProc.Topology2D.LineSegment,System.Object)">
            <summary>
            Equality operartor is equal if the endpoints of the segment line up.
            </summary>
            <param name="A">A LineSegment</param>
            <param name="objB">Any Object</param>
            <returns>Boolean, true if the line segments are equal</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.LineSegment.op_Inequality(MapWinGeoProc.Topology2D.LineSegment,System.Object)">
            <summary>
            InEquality operartor is false if the endpoints of the segment line up.
            </summary>
            <param name="A">A LineSegment</param>
            <param name="objB">Any Object</param>
            <returns>Boolean, true if the line segments are equal</returns>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.LineSegment.mwStartPoint">
            <summary>
            A MapWinGIS.Point representing the beginning of the line segment
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.LineSegment.StartPoint">
            <summary>
            A Point representing the beginning of the line segment
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.LineSegment.mwEndPoint">
            <summary>
            A MapWinGIS.Point representing the end of the line segment
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.LineSegment.EndPoint">
            <summary>
            A MapWinGIS.Point representing the end of the line segment
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.LineSegment.Length">
            <summary>
            A Double representing the length of the segment
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.LineSegment.Center">
            <summary>
            The geometric center of the line.  This is simply the average of the
            X, Y and Z coordinates.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.LineSegment.Envelope">
            <summary>
            Gets the Envelope of this segment.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.LineSegment.Dimension">
            <summary>
            Returns the dimension.  In this case, line segments have 1 dimension, so
            the dimension returns 1.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Utilities.Degrees">
            <summary>
            Converts degrees to radians.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.Degrees.ToRadians(System.Double)">
            <summary>
            Converts degrees to radians.
            </summary>
            <param name="degrees">The angle in degrees.</param>
            <returns>The angle in radians.</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Utilities.CoordinateArrayFilter">
            <summary>
            A <c>CoordinateFilter</c> that creates an array containing every coordinate in a <c>Geometry</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.CoordinateArrayFilter.#ctor(System.Int32)">
            <summary>
            Constructs a <c>CoordinateArrayFilter</c>.
            </summary>
            <param name="size">The number of points that the <c>CoordinateArrayFilter</c> will collect.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.CoordinateArrayFilter.Filter(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="coord"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Utilities.CoordinateArrayFilter.Coordinates">
            <summary>
            Returns the <c>Coordinate</c>s collected by this <c>CoordinateArrayFilter</c>.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMergeDirectedEdge">
            <summary>
            A <c>com.vividsolutions.jts.planargraph.DirectedEdge</c> of a <c>LineMergeGraph</c>. 
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMergeDirectedEdge.#ctor(MapWinGeoProc.NTS.Topology.Planargraph.Node,MapWinGeoProc.NTS.Topology.Planargraph.Node,MapWindow.Interfaces.Geometries.ICoordinate,System.Boolean)">
            <summary>
            Constructs a LineMergeDirectedEdge connecting the <c>from</c> node to the <c>to</c> node.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <param name="directionPt">
            specifies this DirectedEdge's direction (given by an imaginary
            line from the <c>from</c> node to <c>directionPt</c>).
            </param>
            <param name="edgeDirection">
            whether this DirectedEdge's direction is the same as or
            opposite to that of the parent Edge (if any).
            </param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Linemerge.LineMergeDirectedEdge.Next">
            <summary>
            Returns the directed edge that starts at this directed edge's end point, or null
            if there are zero or multiple directed edges starting there.  
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Distance.ConnectedElementPointFilter">
            <summary>
            Extracts a single point
            from each connected element in a Geometry
            (e.g. a polygon, linestring or point)
            and returns them in a list
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.ConnectedElementPointFilter.GetCoordinates(MapWinGeoProc.NTS.Topology.Geometries.Geometry)">
            <summary>
            Returns a list containing a Coordinate from each Polygon, LineString, and Point
            found inside the specified point. Thus, if the specified point is
            not a GeometryCollection, an empty list will be returned.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.ConnectedElementPointFilter.#ctor(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="pts"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Distance.ConnectedElementPointFilter.Filter(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="geom"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Buffer.RightmostEdgeFinder">
            <summary>
            A RightmostEdgeFinder find the DirectedEdge in a list which has the highest coordinate,
            and which is oriented L to R at that point. (I.e. the right side is on the RHS of the edge.)
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.RightmostEdgeFinder.#ctor">
            <summary>
            A RightmostEdgeFinder finds the DirectedEdge with the rightmost coordinate.
            The DirectedEdge returned is guaranteed to have the R of the world on its RHS.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.RightmostEdgeFinder.FindEdge(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="dirEdgeList"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.RightmostEdgeFinder.FindRightmostEdgeAtNode">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.RightmostEdgeFinder.FindRightmostEdgeAtVertex">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.RightmostEdgeFinder.CheckForRightmostCoordinate(MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge)">
            <summary>
            
            </summary>
            <param name="de"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.RightmostEdgeFinder.GetRightmostSide(MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge,System.Int32)">
            <summary>
            
            </summary>
            <param name="de"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.RightmostEdgeFinder.GetRightmostSideOfSegment(MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge,System.Int32)">
            <summary>
            
            </summary>
            <param name="de"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Buffer.RightmostEdgeFinder.Edge">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Buffer.RightmostEdgeFinder.Coordinate">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.ShapefileException">
            <summary>
            The exception that is thrown when a non-fatal application error occurs related to Topology functionality.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileException.#ctor">
            <summary>
            Initializes a new instance of the ShapefileException class.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the ShapefileException class with a specified error message.
            </summary>
            <param name="message">A message that describes the error. </param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the ApplicationException class with serialized data.
            </summary>
            <param name="info">The object that holds the serialized object data. </param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ShapefileException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the ApplicationException class with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception. If the innerException parameter is not a null reference, the current exception is raised in a catch block that handles the inner exception</param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.Shapefile">
            <summary>
            This class is used to read and write ESRI Shapefiles.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.Shapefile.GetShapeType(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Given a geomtery object, returns the equilivent shape file type.
            </summary>
            <param name="geom">A Geometry object.</param>
            <returns>The equilivent for the geometry object.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.Shapefile.GetShapeHandler(MapWindow.Interfaces.Geometries.ShapeGeometryTypes)">
            <summary>
            Returns the appropriate class to convert a shaperecord to an OGIS geometry given the type of shape.
            </summary>
            <param name="type">The shapefile type.</param>
            <returns>An instance of the appropriate handler to convert the shape record to a Geometry object.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.Shapefile.CreateDataReader(System.String,MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory)">
            <summary>
            Returns an ShapefileDataReader representing the data in a shapefile.
            </summary>
            <param name="filename">The filename (minus the . and extension) to read.</param>
            <param name="geometryFactory">The geometry factory to use when creating the objects.</param>
            <returns>An ShapefileDataReader representing the data in the shape file.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.Shapefile.CreateDataTable(System.String,System.String,MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory)">
            <summary>
            Creates a DataTable representing the information in a shape file.
            </summary>
            <param name="filename">The filename (minus the . and extension) to read.</param>
            <param name="tableName">The name to give to the table.</param>
            <param name="geometryFactory">The geometry factory to use when creating the objects.</param>
            <returns>DataTable representing the data </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.Shapefile.ImportShapefile(System.String,System.String,System.String)">
            <summary>
            Imports a shapefile into a dababase table.
            </summary>
            <remarks>
            This method assumes a table has already been crated in the database.
            Calling this method does not close the connection that is passed in.
            </remarks>
            <param name="filename"></param>
            <param name="connectionstring"></param>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.Shapefile.CreateDbTable(System.Data.DataTable,System.Boolean)">
            <summary>
            
            </summary>
            <param name="table"></param>
            <param name="deleteExisting"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.Shapefile.GetDbType(System.Type,System.Int32)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.MultiPointHandler">
            <summary>
            Converts a Shapefile point to a OGIS Polygon.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MultiPointHandler.#ctor">
            <summary>
            Initializes a new instance of the MultiPointHandler class.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MultiPointHandler.Read(MapWinGeoProc.NTS.Topology.IO.BigEndianBinaryReader,MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            Reads a stream and converts the shapefile record to an equilivant geometry object.
            </summary>
            <param name="file">The stream to read.</param>
            <param name="geometryFactory">The geometry factory to use when making the object.</param>
            <returns>The Geometry object that represents the shape file record.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MultiPointHandler.Write(MapWindow.Interfaces.Geometries.IGeometry,System.IO.BinaryWriter,MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            Writes a Geometry to the given binary wirter.
            </summary>
            <param name="geometry">The geometry to write.</param>
            <param name="file">The file stream to write to.</param>
            <param name="geometryFactory">The geometry factory to use.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.MultiPointHandler.GetLength(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Gets the length of the shapefile record using the geometry passed in.
            </summary>
            <param name="geometry">The geometry to get the length for.</param>
            <returns>The length in bytes this geometry is going to use when written out as a shapefile record.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.MultiPointHandler.ShapeType">
            <summary>
            The ShapeType this handler handles.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.DbaseFileWriter">
            <summary>
            This class aids in the writing of Dbase IV files. 
            </summary>
            <remarks>
            Attribute information of an ESRI Shapefile is written using Dbase IV files.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileWriter.#ctor(System.String)">
            <summary>
            Initializes a new instance of the DbaseFileWriter class.
            </summary>
            <param name="filename"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileWriter.Write(MapWinGeoProc.NTS.Topology.IO.DbaseFileHeader)">
            <summary>
            
            </summary>
            <param name="header"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileWriter.Write(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="columnValues"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileWriter.Write(System.Double,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="number"></param>
            <param name="length"></param>
            <param name="decimalCount"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileWriter.Write(System.Single,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="number"></param>
            <param name="length"></param>
            <param name="decimalCount"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileWriter.Write(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="text"></param>
            <param name="length"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileWriter.Write(System.DateTime)">
            <summary>
            
            </summary>
            <param name="date"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileWriter.Write(System.Boolean)">
            <summary>
            
            </summary>
            <param name="flag"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileWriter.Close">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.DbaseFileHeader">
            <summary>
            Class for holding the information assicated with a dbase header.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileHeader.#ctor">
            <summary>
            Initializes a new instance of the DbaseFileHeader class.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileHeader.AddColumn(System.String,System.Char,System.Int32,System.Int32)">
            <summary>
             Add a column to this DbaseFileHeader.
            </summary>
            <param name="fieldName">The name of the field to add.</param>
            <param name="fieldType">The type is one of (C N L or D) character, number, logical(true/false), or date.</param>
            <param name="fieldLength"> The Field length is the total length in bytes reserved for this column.</param>
            <param name="decimalCount">The decimal count only applies to numbers(N), and floating point values (F), and refers to the number of characters to reserve after the decimal point.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileHeader.RemoveColumn(System.String)">
            <summary>
            Remove a column from this DbaseFileHeader.
            </summary>
            <param name="fieldName"></param>
            <returns>return index of the removed column, -1 if no found.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileHeader.ReadHeader(System.IO.BinaryReader)">
            <summary>
            Read the header data from the DBF file.
            </summary>
            <param name="reader">BinaryReader containing the header.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileHeader.SetNumRecords(System.Int32)">
            <summary>
            Set the number of records in the file
            </summary>
            <param name="inNumRecords"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.DbaseFileHeader.WriteHeader(System.IO.BinaryWriter)">
            <summary>
            Write the header data to the DBF file.
            </summary>
            <param name="writer"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.DbaseFileHeader.LastUpdateDate">
            <summary>
            Return the date this file was last updated.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.DbaseFileHeader.NumFields">
            <summary>
            Return the number of fields in the records.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.DbaseFileHeader.NumRecords">
            <summary>
            Return the number of records in the file.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.DbaseFileHeader.RecordLength">
            <summary>
            Return the length of the records in bytes.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.DbaseFileHeader.HeaderLength">
            <summary>
            Return the length of the header.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.DbaseFileHeader.Fields">
            <summary>
            Returns the fields in the dbase file.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Strtree.SIRtree">
            <summary>
            One-dimensional version of an STR-packed R-tree. SIR stands for
            "Sort-Interval-Recursive". STR-packed R-trees are described in:
            P. Rigaux, Michel Scholl and Agnes Voisard. Spatial Databases With
            Application To GIS. Morgan Kaufmann, San Francisco, 2002.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.SIRtree.#ctor">
            <summary> 
            Constructs an SIRtree with the default (10) node capacity.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.SIRtree.#ctor(System.Int32)">
            <summary> 
            Constructs an SIRtree with the given maximum number of child nodes that
            a node may have.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.SIRtree.CreateNode(System.Int32)">
            <summary>
            
            </summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.SIRtree.Insert(System.Double,System.Double,System.Object)">
            <summary> 
            Inserts an item having the given bounds into the tree.
            </summary>
            <param name="x1"></param>
            <param name="x2"></param>
            <param name="item"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.SIRtree.Query(System.Double)">
            <summary>
            Returns items whose bounds intersect the given value.
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.SIRtree.Query(System.Double,System.Double)">
            <summary> 
            Returns items whose bounds intersect the given bounds.
            </summary>
            <param name="x1">Possibly equal to x2.</param>
            <param name="x2">Possibly equal to x1.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.SIRtree.GetComparer">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Strtree.SIRtree.IntersectsOp">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Strtree.SIRtree.AnnonymousComparerImpl">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.SIRtree.AnnonymousComparerImpl.Compare(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Strtree.SIRtree.AnonymousIntersectsOpImpl">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.SIRtree.AnonymousIntersectsOpImpl.Intersects(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="aBounds"></param>
            <param name="bBounds"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Strtree.SIRtree.AnonymousAbstractNodeImpl">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.SIRtree.AnonymousAbstractNodeImpl.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="nodeCapacity"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Strtree.SIRtree.AnonymousAbstractNodeImpl.ComputeBounds">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Quadtree.Quadtree">
            <summary>
            A Quadtree is a spatial index structure for efficient querying
            of 2D rectangles.  If other kinds of spatial objects
            need to be indexed they can be represented by their
            envelopes    
            The quadtree structure is used to provide a primary filter
            for range rectangle queries.  The Query() method returns a list of
            all objects which may intersect the query rectangle.  Note that
            it may return objects which do not in fact intersect.
            A secondary filter is required to test for exact intersection.
            Of course, this secondary filter may consist of other tests besides
            intersection, such as testing other kinds of spatial relationships.
            This implementation does not require specifying the extent of the inserted
            items beforehand.  It will automatically expand to accomodate any extent
            of dataset.
            This data structure is also known as an <c>MX-CIF quadtree</c>
            following the usage of Samet and others.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Quadtree.EnsureExtent(MapWindow.Interfaces.Geometries.IEnvelope,System.Double)">
            <summary>
            Ensure that the envelope for the inserted item has non-zero extents.
            Use the current minExtent to pad the envelope, if necessary.
            </summary>
            <param name="itemEnv"></param>
            <param name="minExtent"></param>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Index.Quadtree.Quadtree.minExtent">
            <summary>
            minExtent is the minimum envelope extent of all items
            inserted into the tree so far. It is used as a heuristic value
            to construct non-zero envelopes for features with zero X and/or Y extent.
            Start with a non-zero extent, in case the first feature inserted has
            a zero extent in both directions.  This value may be non-optimal, but
            only one feature will be inserted with this value.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Quadtree.#ctor">
            <summary>
            Constructs a Quadtree with zero items.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Quadtree.Insert(MapWindow.Interfaces.Geometries.IEnvelope,System.Object)">
            <summary>
            
            </summary>
            <param name="itemEnv"></param>
            <param name="item"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Quadtree.Remove(MapWindow.Interfaces.Geometries.IEnvelope,System.Object)">
            <summary> 
            Removes a single item from the tree.
            </summary>
            <param name="itemEnv">The Envelope of the item to remove.</param>
            <param name="item">The item to remove.</param>
            <returns><c>true</c> if the item was found.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Quadtree.Query(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            
            </summary>
            <param name="searchEnv"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Quadtree.Query(MapWindow.Interfaces.Geometries.IEnvelope,MapWinGeoProc.NTS.Topology.Index.IItemVisitor)">
            <summary>
            
            </summary>
            <param name="searchEnv"></param>
            <param name="visitor"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Quadtree.QueryAll">
            <summary>
            Return a list of all items in the Quadtree.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Quadtree.Quadtree.CollectStats(MapWindow.Interfaces.Geometries.IEnvelope)">
            <summary>
            
            </summary>
            <param name="itemEnv"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Quadtree.Quadtree.Depth">
            <summary> 
            Returns the number of levels in the tree.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Quadtree.Quadtree.Count">
            <summary> 
            Returns the number of items in the tree.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.IIndexVisitor">
            <summary> 
            A visitor for nodes and items in an index.
            </summary> 
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.IIndexVisitor.VisitItem(System.Object)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Bintree.Node">
            <summary>
            A node of a <c>Bintree</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Node.CreateNode(MapWinGeoProc.NTS.Topology.Index.Bintree.Interval)">
            <summary>
            
            </summary>
            <param name="itemInterval"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Node.CreateExpanded(MapWinGeoProc.NTS.Topology.Index.Bintree.Node,MapWinGeoProc.NTS.Topology.Index.Bintree.Interval)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="addInterval"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Node.#ctor(MapWinGeoProc.NTS.Topology.Index.Bintree.Interval,System.Int32)">
            <summary>
            
            </summary>
            <param name="interval"></param>
            <param name="level"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Node.IsSearchMatch(MapWinGeoProc.NTS.Topology.Index.Bintree.Interval)">
            <summary>
            
            </summary>
            <param name="itemInterval"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Node.GetNode(MapWinGeoProc.NTS.Topology.Index.Bintree.Interval)">
            <summary>
            Returns the subnode containing the envelope.
            Creates the node if
            it does not already exist.
            </summary>
            <param name="searchInterval"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Node.Find(MapWinGeoProc.NTS.Topology.Index.Bintree.Interval)">
            <summary>
            Returns the smallest existing
            node containing the envelope.
            </summary>
            <param name="searchInterval"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Node.Insert(MapWinGeoProc.NTS.Topology.Index.Bintree.Node)">
            <summary>
            
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Node.GetSubnode(System.Int32)">
            <summary>
            Get the subnode for the index.
            If it doesn't exist, create it.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Node.CreateSubnode(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Bintree.Node.Interval">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Index.Bintree.Key">
            <summary>
            A Key is a unique identifier for a node in a tree.
            It contains a lower-left point and a level number. The level number
            is the power of two for the size of the node envelope.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Key.ComputeLevel(MapWinGeoProc.NTS.Topology.Index.Bintree.Interval)">
            <summary>
            
            </summary>
            <param name="interval"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Key.#ctor(MapWinGeoProc.NTS.Topology.Index.Bintree.Interval)">
            <summary>
            
            </summary>
            <param name="interval"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Key.ComputeKey(MapWinGeoProc.NTS.Topology.Index.Bintree.Interval)">
            <summary>
            Return a square envelope containing the argument envelope,
            whose extent is a power of two and which is based at a power of 2.
            </summary>
            <param name="itemInterval"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Index.Bintree.Key.ComputeInterval(System.Int32,MapWinGeoProc.NTS.Topology.Index.Bintree.Interval)">
            <summary>
            
            </summary>
            <param name="level"></param>
            <param name="itemInterval"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Bintree.Key.Point">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Bintree.Key.Level">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Index.Bintree.Key.Interval">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.PackedCoordinateSequenceFactory">
            <summary>
            Builds packed array coordinate sequences. The array data type can be either
            double or float, and defaults to float.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.PackedCoordinateSequence">
            <summary>
            A <c>/CoordinateSequence</c> implementation based on a packed arrays.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleSweepLineIntersector">
            <summary>
            Finds all intersections in one or two sets of edges,
            using a simple x-axis sweepline algorithm.
            While still O(n^2) in the worst case, this algorithm
            drastically improves the average-case time.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleSweepLineIntersector.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleSweepLineIntersector.ComputeIntersections(System.Collections.IList,MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector,System.Boolean)">
            <summary>
            
            </summary>
            <param name="edges"></param>
            <param name="si"></param>
            <param name="testAllSegments"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleSweepLineIntersector.ComputeIntersections(System.Collections.IList,System.Collections.IList,MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector)">
            <summary>
            
            </summary>
            <param name="edges0"></param>
            <param name="edges1"></param>
            <param name="si"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleSweepLineIntersector.Add(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="edges"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleSweepLineIntersector.Add(System.Collections.IList,System.Object)">
            <summary>
            
            </summary>
            <param name="edges"></param>
            <param name="edgeSet"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleSweepLineIntersector.Add(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge,System.Object)">
            <summary>
            
            </summary>
            <param name="edge"></param>
            <param name="edgeSet"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleSweepLineIntersector.PrepareEvents">
            <summary> 
            Because Delete Events have a link to their corresponding Insert event,
            it is possible to compute exactly the range of events which must be
            compared to a given Insert event object.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleSweepLineIntersector.ComputeIntersections(MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector)">
            <summary>
            
            </summary>
            <param name="si"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SimpleSweepLineIntersector.ProcessOverlaps(System.Int32,System.Int32,MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SweepLineEvent,MapWinGeoProc.NTS.Topology.GeometriesGraph.Index.SegmentIntersector)">
            <summary>
            
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <param name="ev0"></param>
            <param name="si"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projection">
            <summary>
            The Projection class defines the standard information stored with a projection
            objects. A projection object implements a coordinate transformation from a geographic
            coordinate system to a projected coordinate system, given the ellipsoid for the
            geographic coordinate system. It is expected that each coordinate transformation of
            interest, e.g., Transverse Mercator, Lambert, will be implemented as a class of
            type Projection, supporting the IProjection interface.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projection.GetParameter(System.Int32)">
            <summary>
            Gets an indexed parameter of the projection.
            </summary>
            <param name="n">Index of parameter</param>
            <returns>n'th parameter</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projection.GetParameter(System.String)">
            <summary>
            Gets an named parameter of the projection.
            </summary>
            <remarks>The parameter name is case insensitive</remarks>
            <param name="name">Name of parameter</param>
            <returns>parameter or null if not found</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projection.EqualParams(System.Object)">
            <summary>
            Checks whether the values of this instance is equal to the values of another instance.
            Only parameters used for coordinate system are used for comparison.
            Name, abbreviation, authority, alias and remarks are ignored in the comparison.
            </summary>
            <param name="obj"></param>
            <returns>True if equal</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projection.NumParameters">
            <summary>
            Gets the number of parameters of the projection.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projection.Parameters">
            <summary>
            Gets or sets the parameters of the projection
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projection.ClassName">
            <summary>
            Gets the projection classification name (e.g. "Transverse_Mercator").
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projection.WKT">
            <summary>
            Returns the Well-known text for this object
            as defined in the simple features specification.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Projection.XML">
            <summary>
            Gets an XML representation of this object
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.PrimeMeridian">
            <summary>
            A meridian used to take longitude measurements from.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.PrimeMeridian.#ctor(System.Double,MapWinGeoProc.NTS.Topology.CoordinateSystems.IAngularUnit,System.String,System.String,System.Int64,System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of a prime meridian
            </summary>
            <param name="longitude">Longitude of prime meridian</param>
            <param name="angularUnit">Angular unit</param>
            <param name="name">Name</param>
            <param name="authority">Authority name</param>
            <param name="authorityCode">Authority-specific identification code.</param>
            <param name="alias">Alias</param>
            <param name="abbreviation">Abbreviation</param>
            <param name="remarks">Provider-supplied remarks</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.PrimeMeridian.EqualParams(System.Object)">
            <summary>
            Checks whether the values of this instance is equal to the values of another instance.
            Only parameters used for coordinate system are used for comparison.
            Name, abbreviation, authority, alias and remarks are ignored in the comparison.
            </summary>
            <param name="obj"></param>
            <returns>True if equal</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.PrimeMeridian.Greenwich">
            <summary>
            Greenwich prime meridian
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.PrimeMeridian.Lisbon">
            <summary>
            Lisbon prime meridian
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.PrimeMeridian.Paris">
            <summary>
            Paris prime meridian.
            Value adopted by IGN (Paris) in 1936. Equivalent to 2 deg 20min 14.025sec. Preferred by EPSG to earlier value of 2deg 20min 13.95sec (2.596898 grads) used by RGS London.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.PrimeMeridian.Bogota">
            <summary>
            Bogota prime meridian
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.PrimeMeridian.Madrid">
            <summary>
            Madrid prime meridian
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.PrimeMeridian.Rome">
            <summary>
            Rome prime meridian
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.PrimeMeridian.Bern">
            <summary>
            Bern prime meridian.
            1895 value. Newer value of 7 deg 26 min 22.335 sec E determined in 1938.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.PrimeMeridian.Jakarta">
            <summary>
            Jakarta prime meridian
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.PrimeMeridian.Ferro">
            <summary>
            Ferro prime meridian.
            Used in Austria and former Czechoslovakia.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.PrimeMeridian.Brussels">
            <summary>
            Brussels prime meridian
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.PrimeMeridian.Stockholm">
            <summary>
            Stockholm prime meridian
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.PrimeMeridian.Athens">
            <summary>
            Athens prime meridian.
            Used in Greece for older mapping based on Hatt projection.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.PrimeMeridian.Oslo">
            <summary>
            Oslo prime meridian.
            Formerly known as Kristiania or Christiania.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.PrimeMeridian.Longitude">
            <summary>
            Gets or sets the longitude of the prime meridian (relative to the Greenwich prime meridian).
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.PrimeMeridian.AngularUnit">
            <summary>
            Gets or sets the AngularUnits.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.PrimeMeridian.WKT">
            <summary>
            Returns the Well-known text for this object
            as defined in the simple features specification.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.PrimeMeridian.XML">
            <summary>
            Gets an XML representation of this object
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.SimplePointInAreaLocator">
            <summary>
            Computes whether a point
            lies in the interior of an area <c>Geometry</c>.
            The algorithm used is only guaranteed to return correct results
            for points which are not on the boundary of the Geometry.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.SimplePointInAreaLocator.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.SimplePointInAreaLocator.Locate(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary> 
            Locate is the main location function.  It handles both single-element
            and multi-element Geometries.  The algorithm for multi-element Geometries
            is more complex, since it has to take into account the boundaryDetermination rule.
            </summary>
            <param name="geom"></param>
            <param name="p"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.SimplePointInAreaLocator.ContainsPoint(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="p"></param>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.SimplePointInAreaLocator.ContainsPointInPolygon(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.IPolygon)">
            <summary>
            
            </summary>
            <param name="p"></param>
            <param name="poly"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.PointLocator">
            <summary> 
            Computes the topological relationship (Location) of a single point to a Geometry.
            The algorithm obeys the SFS boundaryDetermination rule to correctly determine
            whether the point lies on the boundary or not.
            Note that instances of this class are not reentrant.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.PointLocator.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MapWinGeoProc.NTS.Topology.Algorithm.PointLocator"/> class.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.PointLocator.Intersects(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary> 
            Convenience method to test a point for intersection with a Geometry
            </summary>
            <param name="p">The coordinate to test.</param>
            <param name="geom">The Geometry to test.</param>
            <returns><c>true</c> if the point is in the interior or boundary of the Geometry.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.PointLocator.Locate(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary> 
            Computes the topological relationship ({Location}) of a single point to a Geometry.
            It handles both single-element and multi-element Geometries.
            The algorithm for multi-part Geometries takes into account the boundaryDetermination rule.
            </summary>
            <returns>The Location of the point relative to the input Geometry.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.PointLocator.ComputeLocation(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="p"></param>
            <param name="geom"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.PointLocator.UpdateLocationInfo(MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            
            </summary>
            <param name="loc"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.PointLocator.Locate(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ILineString)">
            <summary>
            
            </summary>
            <param name="p"></param>
            <param name="l"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.PointLocator.LocateInPolygonRing(MapWindow.Interfaces.Geometries.ICoordinate,MapWinGeoProc.NTS.Topology.Geometries.LinearRing)">
            <summary>
            
            </summary>
            <param name="p"></param>
            <param name="ring"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.PointLocator.Locate(MapWindow.Interfaces.Geometries.ICoordinate,MapWinGeoProc.NTS.Topology.Geometries.Polygon)">
            <summary>
            
            </summary>
            <param name="p"></param>
            <param name="poly"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.GridWrapper">
            <summary>
            Summary description for GridWrapper.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.FileElement">
            <summary>
            A modular control that can be used for specifying a filename for opening or closing files.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.FileElement.#ctor">
            <summary>
            Creates a new instance of the FileElement class
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.FileElement.OnClick(System.EventArgs)">
            <summary>
            Called to fire the click event for this element
            </summary>
            <param name="e">A mouse event args thingy</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.FileElement.OnHelpButtonPressed(MapWinGeoProc.Dialogs.HelpPannelEventArgs)">
            <summary>
            Called when the help button has been pressed
            </summary>
            <param name="e">A HelpPanelEventArgs parameter with a new help title, text and image.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.FileElement.OnHelpContextChanged(MapWinGeoProc.Dialogs.HelpPannelEventArgs)">
            <summary>
            Called when the data entry field is entered to change a topic, but only if panel is visible
            </summary>
            <param name="e">A HelpPanelEventArgs parameter with a new help title, text and image.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.FileElement.OnResizeStarted">
            <summary>
            Fires when someone uses the resize grip to resize the element
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.FileElement.OnResizeEnded">
            <summary>
            Fires when someone has stopped resizing with the grip
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.FileElement.HelpText_Append(System.String)">
            <summary>
            Appends a string to the end of the help content
            </summary>
            <param name="HelpText"></param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.FileElement.HelpText_Clear(System.String)">
            <summary>
            Clears the existing help content.
            </summary>
            <param name="HelpText"></param>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.FileElement.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.FileElement.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:MapWinGeoProc.Dialogs.FileElement.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.FileElement.cmdHelp">
            <summary>
            Help button
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.FileElement.lblLight">
            <summary>
            Status Light
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.FileElement.groupBox1">
            <summary>
            A group box to surround individual components
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.FileElement.Clicked">
            <summary>
            Fires when the inactive areas around the controls are clicked on the element.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.FileElement.HelpButtonPressed">
            <summary>
            Fires when the help button is clicked.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.FileElement.HelpContextChanged">
            <summary>
            Fires when the the user enters a data entry region.  Changes help without opening panel.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.FileElement.ResizeStarted">
            <summary>
            Fires when the element is being resized.
            </summary>
        </member>
        <member name="E:MapWinGeoProc.Dialogs.FileElement.ResizeEnded">
            <summary>
            Fires when the element is no longer being resized.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.FileElement.Caption">
            <summary>
            Controls the caption for this element (the group box text)
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.FileElement.LightVisible">
            <summary>
            Gets or sets whether the status light is visible for this element.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.FileElement.LightMessage">
            <summary>
            Gets or sets the tool tip that shows when you hold the mouse over the light
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.FileElement.Status">
            <summary>
            Indicates the current condition of this element.
            - Green = ok to continue
            - Yellow = not specified yet
            - Red = process halting error
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.FileElement.AllowGripResize">
            <summary>
            Gets or sets a boolean.  True if the user is allowed to adjust the width of the 
            element to better display longer filenames.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.FileElement.Halt">
            <summary>
            Boolean, true if either of the conditions that may prevent dialog completion are true 
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.FileElement.HaltOnEmpty">
            <summary>
            Gets or sets a boolean.  True if an unspecified condition will prevent dialog completion.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.FileElement.HaltOnError">
            <summary>
            Gets or sets a boolean.  True if an Error status will prevent dialog completion.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.FileElement.MaxWidth">
            <summary>
            Gets or sets the maximum allowable width for dynamic resize.  The dialog form sets this
            dynamically to the size of the container panel.  This is because the behavior for
            resizing larger than the size of the panel is erratic because of the autoscrolling
            behavior.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.FileElement.MinWidth">
            <summary>
            Gets or sets the minimum allowable width for dynamic resizing.  This specifically affects
            the behavior when the user uses the grip to resize the element.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.FileElement.HelpImage">
            <summary>
            Gets or Sets the image that will appear after the help text in the panel, if any.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.FileElement.HelpText">
            <summary>
            Gets or Sets the text to appear in the help pannel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.FileElement.HelpTitle">
            <summary>
            Gets or Sets the title to be shown in the help panel.  Defaults to the Caption.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.FileElement.WikiAddress">
            <summary>
            Gets or Sets the web address to use from the wiki button in the help panel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.FileElement.DefaultImage">
            <summary>
            Gets or Sets the default image that will be used in the help panel.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.FileElement.AlternateImage">
            <summary>
            Gets or Sets the alternate image that can be used in the help panel instead.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.FileElement.FileAccess">
            <summary>
            Gets or sets whether the file is opened or saved
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.FileElement.Filename">
            <summary>
            Gets or sets the filename shown in the textbox for this element
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.FileElement.FileType">
            <summary>
            Gets or Sets the allowable file types by specifying shapefiles, images, or grids.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.FileElement.Filter">
            <summary>
            Gets or Sets the dialog filter to be used directly.  Setting AllowedFileTypes will
            automatically set this with the filter values allowed for grids, images or shapefiles.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.FileElement.HelpButtonVisible">
            <summary>
            Override the basic help button property change to also handle the text box resize
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Dialogs.FileElement.ResizeGripVisible">
            <summary>
            Gets or sets whether a resize grip is provided for the user to change the dimensions of the control.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.FileElement.LightStatus">
            <summary>
            Indicates the allowed values for the status of the element, illustrated by the light
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.FileElement.LightStatus.Empty">
            <summary>
            Indicates that no value has been set for this yet.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.FileElement.LightStatus.Ok">
            <summary>
            Indicates that the element parameter is ok and won't halt.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.FileElement.LightStatus.Error">
            <summary>
            Indicates that the element value will cause an error.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.FileElement.FileTypes">
            <summary>
            Specifies a GIS file category to help narrow down the open/save file dialogs
            and improve the file format validation.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.FileElement.FileTypes.Shapefile">
            <summary>
            Shapefiles that end with extension .shp
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.FileElement.FileTypes.Grid">
            <summary>
            Grid file formats like geotif, asc, esri grids etc.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.FileElement.FileTypes.Image">
            <summary>
            Image file formats like bmp, jpg, gif, etc.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.FileElement.FileTypes.All">
            <summary>
            The element will not use any filter for file extensions or validation.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.FileElement.FileAccessType">
            <summary>
            Specifies whether an element is being used to open or save a file.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.FileElement.FileAccessType.Open">
            <summary>
            Speficies that the element will be used to open files.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Dialogs.FileElement.FileAccessType.Save">
            <summary>
            Specifies that the element will be used to save files.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.FileElement.HelpButtonHandler">
            <summary>
            Public delegate for when someone presses the help button
            </summary>
            <param name="sender">The element sending the event</param>
            <param name="e">HelpPannelEventArgs with help title, text and an image</param>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.FileElement.ResizeStartedHandler">
            <summary>
            Delegate for the when someone starts resizing an element
            </summary>
            <param name="sender">The element being resized</param>
        </member>
        <member name="T:MapWinGeoProc.Dialogs.FileElement.ResizeEndedHandler">
            <summary>
            Fires when the element is no longer being resized.
            </summary>
            <param name="sender"></param>
        </member>
        <member name="T:MapWinGeoProc.Selection">
            <summary>
            Provides functions for selecting lines/points/polygons from
            a shapefile that intersect with any given polygon.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Selection.ExportSelectedMWViewShapes(MapWindow.Interfaces.IMapWin,System.String)">
            <summary>
            Exports the shapes that are selected in the MapWindow view to a new shapefile.
            </summary>
            <param name="MapWin">A reference to the running MapWindow.</param>
            <param name="ExportToSFPath">The full path to where the result shapefile should be saved.</param>
            <returns>False if an error occurs, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Selection.ExportSelectedMWViewShapes(MapWindow.Interfaces.IMapWin,System.String,System.Boolean)">
            <summary>
            Exports the shapes that are selected in the MapWindow view to a new shapefile.
            </summary>
            <param name="MapWin">A reference to the running MapWindow.</param>
            <param name="ExportToSFPath">The full path to where the result shapefile should be saved.</param>
            <param name="AddToMap">Indicates that the output should be added to the map view immediately.</param>
            <returns>False if an error occurs, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Selection.ExportShapesWithPolygons(MapWinGIS.Shapefile@,MapWinGIS.Shapefile@,MapWinGIS.Shapefile@)">
            <summary>
            This is used by the Identity process to export all shapes intesecting all polygons passed in.
            Each identity polygon is used to select and clip input shapes. The new clipped shape is written
            to the result shapefile. The attribute fields from both input and identity shapefiles are copied
            to the result shapefile.
            This process uses a QuadTree index to speed up the selection of overlapping geometries.
            </summary>
            <param name="inputSF">The shapefile, of any geometry type, to be clipped and exported.</param>
            <param name="identitySF">The polygon shapefile used to clip the inputSF.</param>
            <param name="resultSF">The result shapefile that will contain the results.</param>
            <returns>False if an error occurs, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Selection.SelectPolygonsWithPolygon(MapWinGIS.Shapefile@,MapWinGIS.Shape@,MapWinGIS.Shapefile@)">
            <summary>
            Exports the shapes from the inputSF which fall within the given polygon, saving to the resultSF provided.
            </summary>
            <returns>False if an error occurs, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Selection.SelectPolygonsWithPolygon(MapWinGIS.Shapefile@,MapWinGIS.Shape@,MapWinGIS.Shapefile@,System.Boolean)">
            <summary>
            Exports the shapes from the inputSF which fall within the given polygon, saving to the resultSF provided.
            </summary>
            <returns>False if an error occurs, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Selection.SelectPolygonsWithPolygon(MapWinGIS.Shapefile@,MapWinGIS.Shape@,System.Collections.ArrayList@)">
            <summary>
            Returns the shape indexes of the polygons falling in the specified polygon.
            </summary>
            <returns>True if some are found.</returns>
        </member>
        <member name="M:MapWinGeoProc.Selection.SelectPointsWithPolygon(MapWinGIS.Shapefile@,MapWinGIS.Shape@,MapWinGIS.Shapefile@)">
            <summary>
            Exports the shapes from the inputSF which fall within the given polygon, saving to the resultSF provided.
            </summary>
            <returns>False if an error occurs, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Selection.SelectPointsWithPolygon(MapWinGIS.Shapefile@,MapWinGIS.Shape@,MapWinGIS.Shapefile@,System.Boolean)">
            <summary>
            Exports the shapes from the inputSF which fall within the given polygon, saving to the resultSF provided.
            </summary>
            <returns>False if an error occurs, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Selection.SelectPointsWithPolygon(MapWinGIS.Shapefile@,MapWinGIS.Shape@,System.Collections.ArrayList@)">
            <summary>
            Returns the shape indexes of the shapes falling within the specified polygon.
            </summary>
            <returns>False if an error occurs, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Selection.SelectLinesWithPolygon(MapWinGIS.Shapefile@,MapWinGIS.Shape@,MapWinGIS.Shapefile@)">
            <summary>
            Exports the shapes from the inputSF which fall within the given polygon, saving to the resultSF provided.
            </summary>
            <returns>False if an error occurs, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Selection.SelectLinesWithPolygon(MapWinGIS.Shapefile@,MapWinGIS.Shape@,MapWinGIS.Shapefile@,System.Boolean)">
            <summary>
            Exports the shapes from the inputSF which fall within the given polygon, saving to the resultSF provided.
            </summary>
            <returns>False if an error occurs, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Selection.SelectLinesWithPolygon(MapWinGIS.Shapefile@,MapWinGIS.Shape@,System.Collections.ArrayList@)">
            <summary>
            Returns the indexes of shapes that fall within the specified polygon.
            </summary>
            <returns>False if an error occurs, true otherwise.</returns>
        </member>
        <member name="T:MapWinGeoProc.ClipPointSFWithPoly">
            <summary>
            Functions for clipping a point shapefile with a polygon.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.ClipPointSFWithPoly.ClipPointSFWithPolygon(System.String@,MapWinGIS.Shape@,System.String@,System.Boolean)">
            <summary>
            Returns a shapefile of points from the input shapefile that fall within the polygon.
            </summary>
            <param name="pointSFPath">Full path to the point shapefile.</param>
            <param name="polygon">The polygon used for clipping the point shapefile.</param>
            <param name="resultSFPath">Full path to where the resulting point shapefile should be saved.</param>
            <param name="copyAttributes">True if copying attributes over</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.ClipPointSFWithPoly.ClipPointSFWithPolygon(MapWinGIS.Shapefile@,MapWinGIS.Shape@,MapWinGIS.Shapefile@,System.Boolean)">
            <summary>
            Returns an in-memory shapefile of points from the input shapefile that fall within the polygon.
            </summary>
            <param name="pointSF">Full path to the point shapefile.</param>
            <param name="polygon">The polygon used for clipping the point shapefile.</param>
            <param name="result">Full path to where the resulting point shapefile should be saved.</param>
            <param name="copyAttributes">True if copying attributes over</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="T:MapWinGeoProc.Topology.Angle">
            <summary>
            A geometric angle mesured in degrees or radians
            the angle will wrap around, so setting larger values will
            result in an appropriate angle.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.Angle.PI">
            <summary>
            The value of 3.14159 or whatever from Math.PI
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology.Angle.#ctor(System.Double)">
            <summary>
            Creates a new instance of an angle with the Radians specified
            </summary>
            <param name="Radians">The angle in radians</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.Angle.Equals(System.Object)">
            <summary>
            False for anything that is not an angle.
            Tests two angles to see if they have the same value.
            </summary>
            <param name="obj">An object to test.</param>
            <returns>Boolean, true if the angles have the same value.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Angle.GetHashCode">
            <summary>
            Gets a hash code 
            </summary>
            <returns>Int hash code</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Angle.op_Explicit(System.Double)~MapWinGeoProc.Topology.Angle">
            <summary>
            Returns a new angle object with an angle of Value in radians
            </summary>
            <param name="Value">The double value indicating the angle</param>
            <returns>An Angle structure with the specified value</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Angle.op_Explicit(MapWinGeoProc.Topology.Angle)~System.Double">
            <summary>
            Returns a double specifying the radian value of the angle
            </summary>
            <param name="Value">The angle structure to determine the angle of</param>
            <returns>A Double with the angle in radians</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Angle.op_Equality(MapWinGeoProc.Topology.Angle,MapWinGeoProc.Topology.Angle)">
            <summary>
            Returns true if the two angles are equal to each other.
            </summary>
            <param name="A">An angle to compare</param>
            <param name="B">A second angle.</param>
            <returns>Boolean, true if they are equal.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Angle.op_Inequality(MapWinGeoProc.Topology.Angle,MapWinGeoProc.Topology.Angle)">
            <summary>
            Returns true if the two angles are equal to each other.
            </summary>
            <param name="A">An angle to compare</param>
            <param name="B">A second angle.</param>
            <returns>Boolean, true if they are equal.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Angle.op_Addition(MapWinGeoProc.Topology.Angle,MapWinGeoProc.Topology.Angle)">
            <summary>
            Returns the sum of the two angles, cycling if greater than 2 pi.
            </summary>
            <param name="A">An angle to add</param>
            <param name="B">A second angle to add</param>
            <returns>A new Angle structure equal to the sum of the two angles</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Angle.op_Subtraction(MapWinGeoProc.Topology.Angle,MapWinGeoProc.Topology.Angle)">
            <summary>
            Returns the difference of two angles.
            </summary>
            <param name="A">An angle to subtract from</param>
            <param name="B">The angle to subtract</param>
            <returns>A new angle structure with a sum equal to the two angles</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Angle.op_Division(MapWinGeoProc.Topology.Angle,MapWinGeoProc.Topology.Angle)">
            <summary>
            Divides angle A by angle B
            </summary>
            <param name="A">An angle to divide</param>
            <param name="B">An angle to divide into A</param>
            <returns>A new angle with the quotient of the division</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Angle.op_Multiply(MapWinGeoProc.Topology.Angle,MapWinGeoProc.Topology.Angle)">
            <summary>
            Multiplies angle A by Angle B.
            </summary>
            <param name="A">An angle to multiply</param>
            <param name="B">A second angle to multiply.</param>
            <returns>A new angle with the product of the two angles.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Angle.Cos(MapWinGeoProc.Topology.Angle)">
            <summary>
            Returns the mathematical Cos of the angle specified
            </summary>
            <param name="Value">The Angle to find the cosign of</param>
            <returns>Double, the cosign of the angle specified</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Angle.Sin(MapWinGeoProc.Topology.Angle)">
            <summary>
            Returns the mathematical Sin of the angle specified
            </summary>
            <param name="Value">The Angle to find the Sin of</param>
            <returns>Double, the Sin of the Angle</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Angle.Tan(MapWinGeoProc.Topology.Angle)">
            <summary>
            Returns the mathematical Tan of the angle specified
            </summary>
            <param name="Value">The Angle to find the Tan of</param>
            <returns>Double, the Tan of the Angle</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Angle.ATan(System.Double)">
            <summary>
            Returns the mathematical ATan of the value specified
            </summary>
            <param name="Value">The Double to find the ATan of</param>
            <returns>Angle, the ATan of the Value specified</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Angle.ACos(System.Double)">
            <summary>
            Returns the mathematical ACos of the value specified
            </summary>
            <param name="Value">The Double to find the ACos of</param>
            <returns>Angle, the ACos of the Value specified</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.Angle.ASin(System.Double)">
            <summary>
            Returns the mathematical ASin of the value specified
            </summary>
            <param name="Value">The Double to find the ASin of</param>
            <returns>Angle, the ASin of the Value specified</returns>
        </member>
        <member name="P:MapWinGeoProc.Topology.Angle.Degrees">
            <summary>
            The angle in degrees, ranging from -360 to 360
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology.Angle.Radians">
            <summary>
            Only allows values from -2PI to 2PI.
            </summary>
        </member>
        <member name="T:Iesi.Collections.ImmutableSet">
            <summary>
            <p>Implements an immutable (read-only) <c>Set</c> wrapper.</p>
            <p>Although this is advertised as immutable, it really isn't.  Anyone with access to the
            <c>basisSet</c> can still change the data-set.  So <c>GetHashCode()</c> is not implemented
            for this <c>Set</c>, as is the case for all <c>Set</c> implementations in this library.
            This design decision was based on the efficiency of not having to <c>Clone()</c> the 
            <c>basisSet</c> every time you wrap a mutable <c>Set</c>.</p>
            </summary>
        </member>
        <member name="M:Iesi.Collections.ImmutableSet.#ctor(Iesi.Collections.ISet)">
            <summary>
            Constructs an immutable (read-only) <c>Set</c> wrapper.
            </summary>
            <param name="basisSet">The <c>Set</c> that is wrapped.</param>
        </member>
        <member name="M:Iesi.Collections.ImmutableSet.Add(System.Object)">
            <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
            <param name="o">The object to add to the set.</param>
            <returns><c>true</c> is the object was added, <c>false</c> if it was already present.</returns>
        </member>
        <member name="M:Iesi.Collections.ImmutableSet.AddAll(System.Collections.ICollection)">
            <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
            <param name="c">A collection of objects to add to the set.</param>
            <returns><c>true</c> is the set changed as a result of this operation, <c>false</c> if not.</returns>
        </member>
        <member name="M:Iesi.Collections.ImmutableSet.Clear">
            <summary>
            Removes all objects from the set.
            </summary>
        </member>
        <member name="M:Iesi.Collections.ImmutableSet.Contains(System.Object)">
            <summary>
            Returns <c>true</c> if this set contains the specified element.
            </summary>
            <param name="o">The element to look for.</param>
            <returns><c>true</c> if this set contains the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.ImmutableSet.ContainsAll(System.Collections.ICollection)">
            <summary>
            Returns <c>true</c> if the set contains all the elements in the specified collection.
            </summary>
            <param name="c">A collection of objects.</param>
            <returns><c>true</c> if the set contains all the elements in the specified collection, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.ImmutableSet.Remove(System.Object)">
            <summary>
            Removes the specified element from the set.
            </summary>
            <param name="o">The element to be removed.</param>
            <returns><c>true</c> if the set contained the specified element, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Iesi.Collections.ImmutableSet.RemoveAll(System.Collections.ICollection)">
            <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
            <param name="c">A collection of elements to remove.</param>
            <returns><c>true</c> if the set was modified as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.ImmutableSet.RetainAll(System.Collections.ICollection)">
            <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
            <param name="c">Collection that defines the set of elements to be retained.</param>
            <returns><c>true</c> if this set changed as a result of this operation.</returns>
        </member>
        <member name="M:Iesi.Collections.ImmutableSet.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements in the <c>Set</c> to an array.  The type of array needs
            to be compatible with the objects in the <c>Set</c>, obviously.
            </summary>
            <param name="array">An array that will be the target of the copy operation.</param>
            <param name="index">The zero-based index where copying will start.</param>
        </member>
        <member name="M:Iesi.Collections.ImmutableSet.GetEnumerator">
            <summary>
            Gets an enumerator for the elements in the <c>Set</c>.
            </summary>
            <returns>An <c>IEnumerator</c> over the elements in the <c>Set</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.ImmutableSet.Clone">
            <summary>
            Returns a clone of the <c>Set</c> instance.  
            </summary>
            <returns>A clone of this object.</returns>
        </member>
        <member name="M:Iesi.Collections.ImmutableSet.Union(Iesi.Collections.ISet)">
            <summary>
            Performs a "union" of the two sets, where all the elements
            in both sets are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            Neither this set nor the input set are modified during the operation.  The return value
            is a <c>Clone()</c> of this set with the extra elements added in.
            </summary>
            <param name="a">A collection of elements.</param>
            <returns>A new <c>Set</c> containing the union of this <c>Set</c> with the specified collection.
            Neither of the input objects is modified by the union.</returns>
        </member>
        <member name="M:Iesi.Collections.ImmutableSet.Intersect(Iesi.Collections.ISet)">
            <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included if it exists in
            both sets.  The <c>Intersect()</c> operation does not modify the input sets.  It returns
            a <c>Clone()</c> of this set with the appropriate elements removed.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>The intersection of this set with <c>a</c>.</returns>
        </member>
        <member name="M:Iesi.Collections.ImmutableSet.Minus(Iesi.Collections.ISet)">
            <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of this <c>Set</c> containing the elements from the operation.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>A set containing the elements from this set with the elements in <c>a</c> removed.</returns>
        </member>
        <member name="M:Iesi.Collections.ImmutableSet.ExclusiveOr(Iesi.Collections.ISet)">
            <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of this set containing
            the elements from the exclusive-or operation.
            </summary>
            <param name="a">A set of elements.</param>
            <returns>A set containing the result of <c>a ^ b</c>.</returns>
        </member>
        <member name="P:Iesi.Collections.ImmutableSet.IsEmpty">
            <summary>
            Returns <c>true</c> if this set contains no elements.
            </summary>
        </member>
        <member name="P:Iesi.Collections.ImmutableSet.Count">
            <summary>
            The number of elements contained in this collection.
            </summary>
        </member>
        <member name="P:Iesi.Collections.ImmutableSet.IsSynchronized">
            <summary>
            Returns an object that can be used to synchronize use of the <c>Set</c> across threads.
            </summary>
        </member>
        <member name="P:Iesi.Collections.ImmutableSet.SyncRoot">
            <summary>
            Returns an object that can be used to synchronize the <c>Set</c> between threads.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Utilities.AssertionFailedException">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.AssertionFailedException.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.AssertionFailedException.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineString">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineString.#ctor(MapWinGeoProc.NTS.Topology.Geometries.LineString)">
            <summary>
            
            </summary>
            <param name="parentLine"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineString.#ctor(MapWinGeoProc.NTS.Topology.Geometries.LineString,System.Int32)">
            <summary>
            
            </summary>
            <param name="parentLine"></param>
            <param name="minimumSize"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineString.GetSegment(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineString.Init">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineString.AddToResult(MapWinGeoProc.NTS.Topology.Geometries.LineSegment)">
            <summary>
            
            </summary>
            <param name="seg"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineString.AsLineString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineString.AsLinearRing">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineString.ExtractCoordinates(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="segs"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineString.MinimumSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineString.Parent">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineString.ParentCoordinates">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineString.ResultCoordinates">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineString.ResultSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineString.Segments">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Planargraph.NodeMap">
            <summary>
            A map of <c>Node</c>s, indexed by the coordinate of the node.
            </summary>   
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.NodeMap.#ctor">
            <summary>
            Constructs a NodeMap without any Nodes.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.NodeMap.Add(MapWinGeoProc.NTS.Topology.Planargraph.Node)">
            <summary>
            Adds a node to the map, replacing any that is already at that location.
            </summary>
            <param name="n"></param>
            <returns>The added node.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.NodeMap.Remove(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Removes the Node at the given location, and returns it (or null if no Node was there).
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.NodeMap.Find(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Returns the Node at the given location, or null if no Node was there.
            </summary>
            <param name="coord"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Planargraph.NodeMap.GetEnumerator">
            <summary>
            Returns an Iterator over the Nodes in this NodeMap, sorted in ascending order
            by angle with the positive x-axis.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Planargraph.NodeMap.Values">
            <summary>
            Returns the Nodes in this NodeMap, sorted in ascending order
            by angle with the positive x-axis.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Valid.ConnectedInteriorTester">
            <summary> 
            This class tests that the interior of an area <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>
            (<see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Polygon"/> or <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.MultiPolygon"/>)
            is connected.  An area Geometry is invalid if the interior is disconnected.
            This can happen if:
            - a shell self-intersects,
            - one or more holes form a connected chain touching a shell at two different points,
            - one or more holes form a ring around a subset of the interior.
            If a disconnected situation is found the location of the problem is recorded.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.ConnectedInteriorTester.FindDifferentPoint(MapWindow.Interfaces.Geometries.ICoordinate[],MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="coord"></param>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.ConnectedInteriorTester.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph)">
            <summary>
            
            </summary>
            <param name="geomGraph"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.ConnectedInteriorTester.IsInteriorsConnected">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.ConnectedInteriorTester.SetInteriorEdgesInResult(MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph)">
            <summary>
            
            </summary>
            <param name="graph"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.ConnectedInteriorTester.BuildEdgeRings(System.Collections.IList)">
            <summary>
            Form <see cref="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge"/>s in graph into Minimal EdgeRings.
            (Minimal Edgerings must be used, because only they are guaranteed to provide
            a correct isHole computation).
            </summary>
            <param name="dirEdges"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.ConnectedInteriorTester.VisitShellInteriors(MapWindow.Interfaces.Geometries.IGeometry,MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph)">
            <summary>
            Mark all the edges for the edgeRings corresponding to the shells of the input polygons.  
            Only ONE ring gets marked for each shell - if there are others which remain unmarked
            this indicates a disconnected interior.
            </summary>
            <param name="g"></param>
            <param name="graph"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.ConnectedInteriorTester.VisitInteriorRing(MapWindow.Interfaces.Geometries.ILineString,MapWinGeoProc.NTS.Topology.GeometriesGraph.PlanarGraph)">
            <summary>
            
            </summary>
            <param name="ring"></param>
            <param name="graph"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.ConnectedInteriorTester.VisitLinkedDirectedEdges(MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge)">
            <summary>
            
            </summary>
            <param name="start"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Valid.ConnectedInteriorTester.HasUnvisitedShellEdge(System.Collections.IList)">
            <summary>
            Check if any shell ring has an unvisited edge.
            A shell ring is a ring which is not a hole and which has the interior
            of the parent area on the RHS.
            (Note that there may be non-hole rings with the interior on the LHS,
            since the interior of holes will also be polygonized into CW rings
            by the <c>LinkAllDirectedEdges()</c> step).
            </summary>
            <param name="edgeRings"></param>
            <returns><c>true</c> if there is an unvisited edge in a non-hole ring.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Valid.ConnectedInteriorTester.Coordinate">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Relate.EdgeEndBundleStar">
            <summary>
            An ordered list of <c>EdgeEndBundle</c>s around a <c>RelateNode</c>.
            They are maintained in CCW order (starting with the positive x-axis) around the node
            for efficient lookup and topology building.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.EdgeEndBundleStar.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.EdgeEndBundleStar.Insert(MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd)">
            <summary>
            Insert a EdgeEnd in order in the list.
            If there is an existing EdgeStubBundle which is parallel, the EdgeEnd is
            added to the bundle.  Otherwise, a new EdgeEndBundle is created
            to contain the EdgeEnd.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.EdgeEndBundleStar.UpdateIM(MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix)">
            <summary>
            Update the IM with the contribution for the EdgeStubs around the node.
            </summary>
            <param name="im"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Overlay.MaximalEdgeRing">
            <summary>
            A ring of edges which may contain nodes of degree > 2.
            A MaximalEdgeRing may represent two different spatial entities:
            a single polygon possibly containing inversions (if the ring is oriented CW)
            a single hole possibly containing exversions (if the ring is oriented CCW)    
            If the MaximalEdgeRing represents a polygon,
            the interior of the polygon is strongly connected.
            These are the form of rings used to define polygons under some spatial data models.
            However, under the OGC SFS model, MinimalEdgeRings are required.
            A MaximalEdgeRing can be converted to a list of MinimalEdgeRings using the
            <c>BuildMinimalRings()</c> method.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.MaximalEdgeRing.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge,MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            
            </summary>
            <param name="start"></param>
            <param name="geometryFactory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.MaximalEdgeRing.GetNext(MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge)">
            <summary>
            
            </summary>
            <param name="de"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.MaximalEdgeRing.SetEdgeRing(MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge,MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing)">
            <summary>
            
            </summary>
            <param name="de"></param>
            <param name="er"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.MaximalEdgeRing.LinkDirectedEdgesForMinimalEdgeRings">
            <summary> 
            For all nodes in this EdgeRing,
            link the DirectedEdges at the node to form minimalEdgeRings
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.MaximalEdgeRing.BuildMinimalRings">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferSubgraph">
            <summary>
            A connected subset of the graph of
            <c>DirectedEdges</c> and <c>Node</c>s.
            Its edges will generate either
            a single polygon in the complete buffer, with zero or more holes, or
            one or more connected holes.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferSubgraph.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferSubgraph.Create(MapWinGeoProc.NTS.Topology.GeometriesGraph.Node)">
            <summary>
            Creates the subgraph consisting of all edges reachable from this node.
            Finds the edges in the graph and the rightmost coordinate.
            </summary>
            <param name="node">A node to start the graph traversal from.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferSubgraph.AddReachable(MapWinGeoProc.NTS.Topology.GeometriesGraph.Node)">
            <summary>
            Adds all nodes and edges reachable from this node to the subgraph.
            Uses an explicit stack to avoid a large depth of recursion.
            </summary>
            <param name="startNode">A node known to be in the subgraph.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferSubgraph.Add(MapWinGeoProc.NTS.Topology.GeometriesGraph.Node,System.Collections.Stack)">
            <summary>
            Adds the argument node and all its out edges to the subgraph
            </summary>
            <param name="node">The node to add.</param>
            <param name="nodeStack">The current set of nodes being traversed.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferSubgraph.ClearVisitedEdges">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferSubgraph.ComputeDepth(System.Int32)">
            <summary>
            
            </summary>
            <param name="outsideDepth"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferSubgraph.ComputeDepths(MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge)">
            <summary>
            Compute depths for all dirEdges via breadth-first traversal of nodes in graph.
            </summary>
            <param name="startEdge">Edge to start processing with.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferSubgraph.ComputeNodeDepth(MapWinGeoProc.NTS.Topology.GeometriesGraph.Node)">
            <summary>
            
            </summary>
            <param name="n"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferSubgraph.CopySymDepths(MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge)">
            <summary>
            
            </summary>
            <param name="de"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferSubgraph.FindResultEdges">
            <summary>
            Find all edges whose depths indicates that they are in the result area(s).
            Since we want polygon shells to be
            oriented CW, choose dirEdges with the interior of the result on the RHS.
            Mark them as being in the result.
            Interior Area edges are the result of dimensional collapses.
            They do not form part of the result area boundary.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferSubgraph.CompareTo(System.Object)">
            <summary>
            BufferSubgraphs are compared on the x-value of their rightmost Coordinate.
            This defines a partial ordering on the graphs such that:
            g1 >= g2 - Ring(g2) does not contain Ring(g1)
            where Polygon(g) is the buffer polygon that is built from g.
            This relationship is used to sort the BufferSubgraphs so that shells are guaranteed to
            be built before holes.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferSubgraph.DirectedEdges">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferSubgraph.Nodes">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Buffer.BufferSubgraph.RightMostCoordinate">
            <summary>
            Gets the rightmost coordinate in the edges of the subgraph.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.NodingValidator">
            <summary>
            Validates that a collection of <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s is correctly noded.
            Throws an appropriate exception if an noding error is found.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.NodingValidator.#ctor(System.Collections.IList)">
            <summary>
            Initializes a new instance of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.NodingValidator"/> class.
            </summary>
            <param name="segStrings">The seg strings.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.NodingValidator.CheckValid">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.NodingValidator.CheckCollapses">
            <summary>
            Checks if a segment string contains a segment pattern a-b-a (which implies a self-intersection).
            </summary>   
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.NodingValidator.CheckCollapses(MapWinGeoProc.NTS.Topology.Noding.SegmentString)">
            <summary>
            
            </summary>
            <param name="ss"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.NodingValidator.CheckCollapse(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <param name="p2"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.NodingValidator.CheckInteriorIntersections">
            <summary>
            Checks all pairs of segments for intersections at an interior point of a segment.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.NodingValidator.CheckInteriorIntersections(MapWinGeoProc.NTS.Topology.Noding.SegmentString,MapWinGeoProc.NTS.Topology.Noding.SegmentString)">
            <summary>
            
            </summary>
            <param name="ss0"></param>
            <param name="ss1"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.NodingValidator.CheckInteriorIntersections(MapWinGeoProc.NTS.Topology.Noding.SegmentString,System.Int32,MapWinGeoProc.NTS.Topology.Noding.SegmentString,System.Int32)">
            <summary>
            
            </summary>
            <param name="e0"></param>
            <param name="segIndex0"></param>
            <param name="e1"></param>
            <param name="segIndex1"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.NodingValidator.HasInteriorIntersection(MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="li"></param>
            <param name="p0"></param>
            <param name="p1"></param>
            <returns><c>true</c> if there is an intersection point which is not an endpoint of the segment p0-p1.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.NodingValidator.CheckEndPtVertexIntersections">
            <summary>
            Checks for intersections between an endpoint of a segment string
            and an interior vertex of another segment string
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.NodingValidator.CheckEndPtVertexIntersections(MapWindow.Interfaces.Geometries.ICoordinate,System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="testPt"></param>
            <param name="segStrings"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.SpatialReference">
            <summary>
            Converts spatial reference IDs to a Well-Known Text representation.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Converters.WellKnownText.SpatialReference.SridToWkt(System.Int32)">
            <summary>
            Converts a Spatial Reference ID to a Well-known Text representation
            </summary>
            <param name="srid">Spatial Reference ID</param>
            <returns>Well-known text</returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.Triangle">
            <summary> 
            Represents a planar triangle, and provides methods for calculating various
            properties of triangles.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Triangle.#ctor(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <param name="p2"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Triangle.P2">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Triangle.P1">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Triangle.P0">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Triangle.InCentre">
            <summary>
            The inCentre of a triangle is the point which is equidistant
            from the sides of the triangle.  This is also the point at which the bisectors
            of the angles meet.
            </summary>
            <returns>
            The point which is the InCentre of the triangle.
            </returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.Polygon">
            <summary> 
            Represents a linear polygon, which may include holes.
            The shell and holes of the polygon are represented by {LinearRing}s.
            In a valid polygon, holes may touch the shell or other holes at a single point.
            However, no sequence of touching holes may split the polygon into two pieces.
            The orientation of the rings in the polygon does not matter.
            The shell and holes must conform to the assertions specified in the
            <see href="http://www.opengis.org/techno/specs.htm"/> OpenGIS Simple Features Specification for SQL.     
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.Polygon.Empty">
            <summary>
            Represents an empty <c>Polygon</c>.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.Polygon.shell">
            <summary>
            The exterior boundary, or <c>null</c> if this <c>Polygon</c>
            is the empty point.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.Polygon.holes">
            <summary>
            The interior boundaries, if any.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Polygon.#ctor(MapWinGeoProc.NTS.Topology.Geometries.LinearRing,MapWinGeoProc.NTS.Topology.Geometries.LinearRing[])">
            <summary>
            Initializes a new instance of the <see cref="T:Polygon"/> class.
            </summary>
            <param name="shell">
            The outer boundary of the new <c>Polygon</c>,
            or <c>null</c> or an empty <c>LinearRing</c> if the empty
            point is to be created.
            </param>
            <param name="holes">
            The inner boundaries of the new <c>Polygon</c>
            , or <c>null</c> or empty <c>LinearRing</c>s if the empty
            point is to be created.
            </param>
            <remarks>
            For create this <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/> is used a standard <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory"/> 
            with <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel"/> <c> == </c> <see cref="F:MapWindow.Interfaces.Geometries.PrecisionModels.Floating"/>.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Polygon.#ctor(MapWindow.Interfaces.Geometries.ILinearRing,MapWindow.Interfaces.Geometries.ILinearRing[],MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            Constructs a <c>Polygon</c> with the given exterior boundary and
            interior boundaries.
            </summary>       
            <param name="shell">
            The outer boundary of the new <c>Polygon</c>,
            or <c>null</c> or an empty <c>LinearRing</c> if the empty
            point is to be created.
            </param>
            <param name="holes">
            The inner boundaries of the new <c>Polygon</c>
            , or <c>null</c> or empty <c>LinearRing</c>s if the empty
            point is to be created.
            </param>
            <param name="factory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Polygon.#ctor(MapWindow.Interfaces.Geometries.IPolygonBase)">
            <summary>
            Polygon created from an IPolygonBase
            </summary>
            <param name="polygonBase"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Polygon.GetInteriorRingN(System.Int32)">
            <summary>
            
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Polygon.ComputeEnvelopeInternal">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Polygon.EqualsExact(MapWindow.Interfaces.Geometries.IGeometry,System.Double)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <param name="tolerance"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Polygon.Apply(MapWindow.Interfaces.Geometries.ICoordinateFilter)">
            <summary>
            
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Polygon.Apply(MapWindow.Interfaces.Geometries.IGeometryFilter)">
            <summary>
            
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Polygon.Apply(MapWindow.Interfaces.Geometries.IGeometryComponentFilter)">
            <summary>
            
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Polygon.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Polygon.ConvexHull">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Polygon.Normalize">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Polygon.CompareToSameClass(System.Object)">
            <summary>
            
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Polygon.Normalize(MapWindow.Interfaces.Geometries.ILinearRing,System.Boolean)">
            <summary>
            
            </summary>
            <param name="ring"></param>
            <param name="clockwise"></param>        
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Polygon.#ctor(MapWinGeoProc.NTS.Topology.Geometries.LinearRing,MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory)">
            <summary>
            Constructs a <c>Polygon</c> with the given exterior boundary.
            </summary>
            <param name="shell">
            The outer boundary of the new <c>Polygon</c>,
            or <c>null</c> or an empty <c>LinearRing</c> if the empty
            polygon is to be created.
            </param>
            <param name="factory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Polygon.#ctor(MapWinGeoProc.NTS.Topology.Geometries.LinearRing)">
            <summary>
            Constructs a <c>Polygon</c> with the given exterior boundary.
            </summary>
            <param name="shell">
            The outer boundary of the new <c>Polygon</c>,
            or <c>null</c> or an empty <c>LinearRing</c> if the empty
            polygon is to be created.
            </param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Polygon.Coordinate">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Polygon.Coordinates">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Polygon.NumPoints">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Polygon.Dimension">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Polygon.BoundaryDimension">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Polygon.IsEmpty">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Polygon.IsSimple">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Polygon.ExteriorRing">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Polygon.NumInteriorRings">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Polygon.InteriorRings">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Polygon.Area">
            <summary> 
            Returns the area of this <c>Polygon</c>
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Polygon.Length">
            <summary>
            Returns the perimeter of this <c>Polygon</c>.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Polygon.Boundary">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Polygon.IsRectangle">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Polygon.Shell">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Polygon.Holes">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Polygon.GeometryType">
            <summary>
            Specifically returns a Polygon type
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph">
            <summary>
            A GeometryGraph is a graph that models a given Geometry.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.IsInBoundary(System.Int32)">
            <summary> 
            This method implements the Boundary Determination Rule
            for determining whether
            a component (node or edge) that appears multiple times in elements
            of a MultiGeometry is in the boundary or the interior of the Geometry.
            The SFS uses the "Mod-2 Rule", which this function implements.
            An alternative (and possibly more intuitive) rule would be
            the "At Most One Rule":
            isInBoundary = (componentCount == 1)
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.DetermineBoundary(System.Int32)">
            <summary>
            
            </summary>
            <param name="boundaryCount"></param>
            <returns></returns>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.lineEdgeMap">
            <summary>
            The lineEdgeMap is a map of the linestring components of the
            parentGeometry to the edges which are derived from them.
            This is used to efficiently perform findEdge queries
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.useBoundaryDeterminationRule">
            <summary>
            If this flag is true, the Boundary Determination Rule will used when deciding
            whether nodes are in the boundary or not
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.CreateEdgeSetIntersector">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.#ctor(System.Int32,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="argIndex"></param>
            <param name="parentGeom"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.GetBoundaryPoints">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.FindEdge(MapWinGeoProc.NTS.Topology.Geometries.LineString)">
            <summary>
            
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.ComputeSplitEdges(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="edgelist"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.Add(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.AddCollection(MapWinGeoProc.NTS.Topology.Geometries.GeometryCollection)">
            <summary>
            
            </summary>
            <param name="gc"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.AddPoint(MapWinGeoProc.NTS.Topology.Geometries.Point)">
            <summary> 
            Add a Point to the graph.
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.AddPolygonRing(MapWinGeoProc.NTS.Topology.Geometries.LinearRing,MapWindow.Interfaces.Geometries.Locations,MapWindow.Interfaces.Geometries.Locations)">
            <summary> 
            The left and right topological location arguments assume that the ring is oriented CW.
            If the ring is in the opposite orientation,
            the left and right locations must be interchanged.
            </summary>
            <param name="lr"></param>
            <param name="cwLeft"></param>
            <param name="cwRight"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.AddPolygon(MapWinGeoProc.NTS.Topology.Geometries.Polygon)">
            <summary>
            
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.AddLineString(MapWinGeoProc.NTS.Topology.Geometries.LineString)">
            <summary>
            
            </summary>
            <param name="line"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.AddEdge(MapWinGeoProc.NTS.Topology.GeometriesGraph.Edge)">
            <summary> 
            Add an Edge computed externally.  The label on the Edge is assumed
            to be correct.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.AddPoint(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Add a point computed externally.  The point is assumed to be a
            Point Geometry part, which has a location of INTERIOR.
            </summary>
            <param name="pt"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.ComputeSelfNodes(MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector,System.Boolean)">
            <summary>
            Compute self-nodes, taking advantage of the Geometry type to
            minimize the number of intersection tests.  (E.g. rings are
            not tested for self-intersection, since they are assumed to be valid).
            </summary>
            <param name="li">The <c>LineIntersector</c> to use.</param>
            <param name="computeRingSelfNodes">If <c>false</c>, intersection checks are optimized to not test rings for self-intersection.</param>
            <returns>The SegmentIntersector used, containing information about the intersections found.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.ComputeEdgeIntersections(MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph,MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector,System.Boolean)">
            <summary>
            
            </summary>
            <param name="g"></param>
            <param name="li"></param>
            <param name="includeProper"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.InsertPoint(System.Int32,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            
            </summary>
            <param name="argIndex"></param>
            <param name="coord"></param>
            <param name="onLocation"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.InsertBoundaryPoint(System.Int32,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary> 
            Adds points using the mod-2 rule of SFS.  This is used to add the boundary
            points of dim-1 geometries (Curves/MultiCurves).  According to the SFS,
            an endpoint of a Curve is on the boundary
            if it is in the boundaries of an odd number of Geometries.
            </summary>
            <param name="argIndex"></param>
            <param name="coord"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.AddSelfIntersectionNodes(System.Int32)">
            <summary>
            
            </summary>
            <param name="argIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.AddSelfIntersectionNode(System.Int32,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            Add a node for a self-intersection.
            If the node is a potential boundary node (e.g. came from an edge which
            is a boundary) then insert it as a potential boundary node.
            Otherwise, just add it as a regular node.
            </summary>
            <param name="argIndex"></param>
            <param name="coord"></param>
            <param name="loc"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.HasTooFewPoints">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.InvalidPoint">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.Geometry">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.GeometryGraph.BoundaryNodes">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo">
            <summary>
            Parameters for a geographic transformation into WGS84. The Bursa Wolf parameters should be applied 
            to geocentric coordinates, where the X axis points towards the Greenwich Prime Meridian, the Y axis
            points East, and the Z axis points North.
            </summary>
            <remarks>
            <para>These parameters can be used to approximate a transformation from the horizontal datum to the
            WGS84 datum using a Bursa Wolf transformation. However, it must be remembered that this transformation
            is only an approximation. For a given horizontal datum, different Bursa Wolf transformations can be
            used to minimize the errors over different regions.</para>
            <para>If the DATUM clause contains a TOWGS84 clause, then this should be its “preferred” transformation,
            which will often be the transformation which gives a broad approximation over the whole area of interest
            (e.g. the area of interest in the containing geographic coordinate system).</para>
            <para>Sometimes, only the first three or six parameters are defined. In this case the remaining
            parameters must be zero. If only three parameters are defined, then they can still be plugged into the
            Bursa Wolf formulas, or you can take a short cut. The Bursa Wolf transformation works on geocentric
            coordinates, so you cannot apply it onto geographic coordinates directly. If there are only three
            parameters then you can use the Molodenski or abridged Molodenski formulas.</para>
            <para>If a datums ToWgs84Parameters parameter values are zero, then the receiving
            application can assume that the writing application believed that the datum is approximately equal to
            WGS84.</para>
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo.#ctor">
            <summary>
            Initializes an instance of Wgs84ConversionInfo with default parameters (all values = 0)
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initializes an instance of Wgs84ConversionInfo
            </summary>
            <param name="dx">Bursa Wolf shift in meters.</param>
            <param name="dy">Bursa Wolf shift in meters.</param>
            <param name="dz">Bursa Wolf shift in meters.</param>
            <param name="ex">Bursa Wolf rotation in arc seconds.</param>
            <param name="ey">Bursa Wolf rotation in arc seconds.</param>
            <param name="ez">Bursa Wolf rotation in arc seconds.</param>
            <param name="ppm">Bursa Wolf scaling in parts per million.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.String)">
            <summary>
            Initializes an instance of Wgs84ConversionInfo
            </summary>
            <param name="dx">Bursa Wolf shift in meters.</param>
            <param name="dy">Bursa Wolf shift in meters.</param>
            <param name="dz">Bursa Wolf shift in meters.</param>
            <param name="ex">Bursa Wolf rotation in arc seconds.</param>
            <param name="ey">Bursa Wolf rotation in arc seconds.</param>
            <param name="ez">Bursa Wolf rotation in arc seconds.</param>
            <param name="ppm">Bursa Wolf scaling in parts per million.</param>
            <param name="areaOfUse">Area of use for this transformation</param>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo.Dx">
            <summary>
            Bursa Wolf shift in meters.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo.Dy">
            <summary>
            Bursa Wolf shift in meters.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo.Dz">
            <summary>
            Bursa Wolf shift in meters.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo.Ex">
            <summary>
            Bursa Wolf rotation in arc seconds.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo.Ey">
            <summary>
            Bursa Wolf rotation in arc seconds.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo.Ez">
            <summary>
            Bursa Wolf rotation in arc seconds.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo.Ppm">
            <summary>
            Bursa Wolf scaling in parts per million.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo.AreaOfUse">
            <summary>
            Human readable text describing intended region of transformation.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo.GetAffineTransform">
            <summary>
            Affine Bursa-Wolf matrix transformation
            </summary>
            <remarks>
            <para>Transformation of coordinates from one geographic coordinate system into another 
            (also colloquially known as a "datum transformation") is usually carried out as an 
            implicit concatenation of three transformations:</para>
            <para>[geographical to geocentric >> geocentric to geocentric >> geocentric to geographic</para>
            <para>
            The middle part of the concatenated transformation, from geocentric to geocentric, is usually 
            described as a simplified 7-parameter Helmert transformation, expressed in matrix form with 7 
            parameters, in what is known as the "Bursa-Wolf" formula:<br/>
            <code>
             S = 1 + Ppm/1000000
             [ Xt ]    [     S   -Ez*S   +Ey*S   Dx ]  [ Xs ]
             [ Yt ]  = [ +Ez*S       S   -Ex*S   Dy ]  [ Ys ]
             [ Zt ]    [ -Ey*S   +Ex*S       S   Dz ]  [ Zs ]
             [ 1  ]    [     0       0       0    1 ]  [ 1  ]
            </code><br/>
            The parameters are commonly referred to defining the transformation "from source coordinate system 
            to target coordinate system", whereby (XS, YS, ZS) are the coordinates of the point in the source 
            geocentric coordinate system and (XT, YT, ZT) are the coordinates of the point in the target 
            geocentric coordinate system. But that does not define the parameters uniquely; neither is the
            definition of the parameters implied in the formula, as is often believed. However, the 
            following definition, which is consistent with the "Position Vector Transformation" convention, 
            is common E&amp;P survey practice: 
            </para>	
            <para>(dX, dY, dZ): Translation vector, to be added to the point's position vector in the source 
            coordinate system in order to transform from source system to target system; also: the coordinates 
            of the origin of source coordinate system in the target coordinate system </para>
            <para>(RX, RY, RZ): Rotations to be applied to the point's vector. The sign convention is such that 
            a positive rotation about an axis is defined as a clockwise rotation of the position vector when 
            viewed from the origin of the Cartesian coordinate system in the positive direction of that axis;
            e.g. a positive rotation about the Z-axis only from source system to target system will result in a
            larger longitude value for the point in the target system. Although rotation angles may be quoted in
            any angular unit of measure, the formula as given here requires the angles to be provided in radians.</para>
            <para>: The scale correction to be made to the position vector in the source coordinate system in order 
            to obtain the correct scale in the target coordinate system. M = (1 + dS*10-6), whereby dS is the scale
            correction expressed in parts per million.</para>
            <para><see href="http://www.posc.org/Epicentre.2_2/DataModel/ExamplesofUsage/eu_cs35.html"/> for an explanation of the Bursa-Wolf transformation</para>
            </remarks>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo.ToString">
            <summary>
            Returns the Well Known Text (WKT) for this object.
            </summary>
            <remarks>The WKT format of this object is: <code>TOWGS84[dx, dy, dz, ex, ey, ez, ppm]</code></remarks>
            <returns>WKT representaion</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo.Equals(System.Object)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo.GetHashCode">
            <summary>
            Returns a hash code for the specified object
            </summary>
            <returns>A hash code for the specified object</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo.Equals(MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo)">
            <summary>
            Checks whether the values of this instance is equal to the values of another instance.
            Only parameters used for coordinate system are used for comparison.
            Name, abbreviation, authority, alias and remarks are ignored in the comparison.
            </summary>
            <param name="obj"></param>
            <returns>True if equal</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo.WKT">
            <summary>
            Returns the Well Known Text (WKT) for this object.
            </summary>
            <remarks>The WKT format of this object is: <code>TOWGS84[dx, dy, dz, ex, ey, ez, ppm]</code></remarks>
            <returns>WKT representaion</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo.XML">
            <summary>
            Gets an XML representation of this object
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Wgs84ConversionInfo.HasZeroValuesOnly">
            <summary>
            Returns true of all 7 parameter values are 0.0
            </summary>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.HCoordinate">
            <summary> 
            Represents a homogeneous coordinate for 2-D coordinates.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.HCoordinate.Intersection(MapWinGeoProc.NTS.Topology.Geometries.Coordinate,MapWinGeoProc.NTS.Topology.Geometries.Coordinate,MapWinGeoProc.NTS.Topology.Geometries.Coordinate,MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary> 
            Computes the (approximate) intersection point between two line segments
            using homogeneous coordinates.
            Note that this algorithm is
            not numerically stable; i.e. it can produce intersection points which
            lie outside the envelope of the line segments themselves.  In order
            to increase the precision of the calculation input points should be normalized
            before passing them to this routine.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="q1"></param>
            <param name="q2"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.HCoordinate.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.HCoordinate.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="w"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.HCoordinate.#ctor(MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.HCoordinate.#ctor(MapWinGeoProc.NTS.Topology.Algorithm.HCoordinate,MapWinGeoProc.NTS.Topology.Algorithm.HCoordinate)">
            <summary>
            
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.HCoordinate.GetX">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.HCoordinate.GetY">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Algorithm.HCoordinate.X">
            <summary>
            Direct access to x private field
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Algorithm.HCoordinate.Y">
            <summary>
            Direct access to y private field
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Algorithm.HCoordinate.W">
            <summary>
            Direct access to w private field
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Algorithm.HCoordinate.Coordinate">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Macro.ParamName(MapWinGIS.Grid)">
            <summary>
            Querying a property from a null parameter will cause an error.
            Therefore, this checks for the null case.
            Returns a filename if the grid exists, and "null" otherwise.
            </summary>
            <param name="mwGrid">A MapWinGIS.Grid to obtain the filename for.</param>
        </member>
        <member name="M:MapWinGeoProc.Macro.ParamName(MapWinGIS.Shapefile)">
            <summary>
            Because the "MapWinUtilities" logger needs a report of parameters
            when object parameters might be null, this includes a null check.
            </summary>
            <param name="mwShapefile">A MapWinGIS.Shapefile that might obtain a file.</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Macro.ParamName(System.Object,System.String)">
            <summary>
            Performs a null test.  If the object is null, then it returns "null".
            If the object is not null, it returns nonNullName.
            </summary>
            <param name="nullObject">The object to test for null</param>
            <param name="nonNullName">The name to use if the object is not null.</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Macro.ParamName(MapWinGIS.Shape)">
            <summary>
            Returns a name that describes a shape variable
            </summary>
            <param name="mwShape"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.ScaleTools">
            <summary>
            Returns an extent based on a passed in scale and centerPoint
            </summary>
        </member>
        <member name="M:MapWinGeoProc.ScaleTools.ExtentFromScale(System.Int32,MapWinGIS.Point,System.String,System.Int32,System.Int32)">
            <summary>
            Returns an extent based on a passed in scale and centerPoint
            </summary>
            <param name="Scale">The scale to use in the form of 1:scale</param>
            <param name="CenterPoint">The center location to calculate the extents</param>
            <param name="MapWinUnits">The units that the map is in</param>
            <param name="MapWidthInPixels">Width of the map in pixels</param>
            <param name="MapHeightInPixels">Height of the map in pixels</param>
            <returns>The new extents. Returns null if something went wrong</returns>
        </member>
        <member name="M:MapWinGeoProc.ScaleTools.getConversionFactor(System.String,MapWinGIS.Point)">
            <summary>
            Returns the conversion factor between the map units and inches
            </summary>
            <param name="MapWinUnits">A string represing the MapUnits</param>
            <param name="CenterPoint">The center coodinates of the screen in MapUnits</param>
            <returns>A double representing the conversion factor between MapUnits and inches. If something goes wrong we return 0</returns>
        </member>
        <member name="M:MapWinGeoProc.ScaleTools.DegreesFactor(MapWinGIS.Point)">
            <summary>
            Returns the conversion factor if the map is in degrees
            </summary>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.TerrainAnalysis">
             <summary>
             TerrainAnalysis provides functionality for terrain analysis which is not directly part of the Hydrologic analysis found in HydroProc.cls
             </summary>
            
        </member>
        <member name="M:MapWinGeoProc.TerrainAnalysis.Slope(System.String,System.String,System.Boolean,MapWinGIS.ICallback)">
            <summary>
            Slope will take a DEM and an output path and form a slope grid using the 3rd Order Finite Difference slope algorithm found in Bolstad GIS Fundamentals
            </summary>
            <param name="inDEMPath">Path to the input DEM</param>
            <param name="outSlopePath">Path to the output slope grid</param>
            <param name="slopeInPercent">True if output should be in percent, false if not</param>
            <param name="callback">Callback object for progress and status messages</param>
        </member>
        <member name="M:MapWinGeoProc.TerrainAnalysis.Slope(System.String,System.Double,System.String,System.Boolean,MapWinGIS.ICallback)">
            <summary>
            Overload of slope using Z Factor
            </summary>
            <param name="inDEMPath"></param>
            <param name="inZFactor"></param>
            <param name="outSlopePath"></param>
            <param name="slopeInPercent"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:MapWinGeoProc.TerrainAnalysis.SlopeAspectCurvature(System.String,System.Single,System.String,System.Boolean,System.String,System.String,System.String,MapWinGIS.ICallback)" -->
        <member name="M:MapWinGeoProc.TerrainAnalysis.CalculateSunPosition(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,System.Boolean,System.Double,System.Double,System.Double@,System.Double@)">
            <summary>
            A function to calculate the azimuth and altitude of the estimated sun 
             position at a given time and date as based on the NOAA javascript 
             solar calculations used at 
             http://www.srrb.noaa.gov/highlights/sunrise/azel.html which, in 
             turn, are based on Astronomical Algorithms, by Jean Meeus
            </summary>
            <param name="Month">Month in numeric form January = 1, December = 12</param>
            <param name="Day">Numeric Day of month</param>
            <param name="Year">Numeric Year AD. Won't work as well for years before 1800</param>
            <param name="Hour">Hour in 24 hour time</param>
            <param name="Minute">Minute</param>
            <param name="Second">Seconds</param>
            <param name="OffsetToUniversalTime">Offset to UTC. Positive for west, negative for east. MST is 7.</param>
            <param name="DaylightSavingsTime">True if using DST for current region</param>
            <param name="Latitude">Standard latitude in decimal degrees. West is negative.</param>
            <param name="Longitude">Standard longitude in decimal degrees. South is negative</param>
            <param name="Altitude">Output for solar altitude in degrees clockwise from north</param>
            <param name="Azimuth">Output for solar azimuth in degrees in degrees up from horizon</param>
        </member>
        <member name="M:MapWinGeoProc.TerrainAnalysis.CalculateSunRiseNoonSet(System.Int32,System.Int32,System.Int32,System.Double,System.Boolean,System.Double,System.Double,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
            A function to calculate the sunrise and sunset dates of a given date and lat/lon
            based on the NOAA javascript solar calculations used at
            http://www.srrb.noaa.gov/highlights/sunrise/sunrise.html
            </summary>
            <param name="Month">Month in numeric form January = 1, December = 12</param>
            <param name="Day">Numeric Day of month</param>
            <param name="Year">Numeric Year AD. Won't work as well for years before 1800</param>
            <param name="OffsetToUniversalTime">Offset to UTC. Positive for west, negative for east. MST is 7.</param>
            <param name="DaylightSavingsTime">True if using DST for current region</param>
            <param name="Latitude">Standard latitude in decimal degrees. West is negative.</param>
            <param name="Longitude">Standard longitude in decimal degrees. South is negative</param>
            <param name="Sunrise">Sunrise time. A local time in minutes in format of double. -1.0 if an error occurs. Can be converted to readable format with various timeString functions</param>
            <param name="Noon">Solar noon time. A local time in minutes in format of double. -1.0 if an error occurs or if there is no sunset currently. Can be converted to readable format with various timeString functions</param>
            <param name="Sunset">Sunset time. A local time in format of double. -1.0 if an error occurs. Can be converted to readable format with various timeString functions</param>
            <param name="RiseDate">Will be -1.0 normally, but in northern and southern regions, there isn't a daily sunrise and sunset and so this date will be set to show the last day a sunrise occurred. In Julian day format.</param>
            <param name="SetDate">Will be -1.0 normally, but in northern and southern regions, there isn't a daily sunrise and sunset and so this date will be set to show the next day a sunset occurred. In Julian day format.</param>
        </member>
        <member name="M:MapWinGeoProc.TerrainAnalysis.timeConvert(System.Double,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            A function convert time of day in minutes to hours, minutes, and seconds
            </summary>
            <param name="minutes">time of day in minutes</param>
            <param name="hour">Output integer of hours in military time</param>
            <param name="minute">Output integer of minutes</param>
            <param name="second">Output integer of seconds</param>
        </member>
        <member name="M:MapWinGeoProc.TerrainAnalysis.timeString(System.Double)">
            <summary>
            A function convert time of day in minutes to a zero-padded string
            	suitable for printing to the form text fields
            </summary>
            <param name="minutes">time of day in minutes</param>
            <returns>string of the format HH:MM:SS, minutes and seconds are zero padded</returns>
        </member>
        <member name="M:MapWinGeoProc.TerrainAnalysis.timeStringShortAMPM(System.Double,System.Double)">
            <summary>
            A function to convert time of day in minutes to a zero-padded string
            	suitable for printing to the form text fields.  If time	
            	crosses a day boundary, date is appended.
            </summary>
            <param name="minutes">time of day in minutes</param>
            <param name="JD">julian day</param>
            <returns>string of the format HH:MM[AM/PM] (DDMon)</returns>
        </member>
        <member name="M:MapWinGeoProc.TerrainAnalysis.timeStringAMPMDate(System.Double,System.Double)">
            <summary>
            A function to convert time of day in minutes to a zero-padded string
            	suitable for printing to the form text fields, and appends	
            	the date.
            </summary>
            <param name="minutes">time of day in minutes</param>
            <param name="JD">julian day</param>
            <returns>string of the format HH:MM[AM/PM] DDMon</returns>
        </member>
        <member name="M:MapWinGeoProc.TerrainAnalysis.timeStringDate(System.Double,System.Double)">
            <summary>
            A function to convert time of day in minutes to a zero-padded 24hr time	
            	suitable for printing to the form text fields.  If time	
            	crosses a day boundary, date is appended.
            </summary>
            <param name="minutes">time of day in minutes</param>
            <param name="JD">julian day</param>
            <returns>string of the format HH:MM (DDMon)</returns>
        </member>
        <member name="T:MapWinGeoProc.Transforms.Projective">
            <summary>
            This class contains the functions necessary to project an image.
            If you have a specific desired output cellwidth/height, call Specify_CellSize first
            When you call Derive_Coefficients, send the projected coordinates,
            and the function will set up an output image.  
            The Project_Point_Backward works in pixel coordinates, not in projected coordinates.
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Transforms.Projective.Specify_CellSize(System.Double,System.Double)">
            <summary>
            If this function is called the output image will be sized so that the pixels represent these dimensions.
            If this function is not specified, a cellwidth will be chosen to be as small as possible while retaining data.
            This is done by ensuring that no edge will contain fewer pixels than the edge in the source image.
            </summary>
            <param name="CellHeight">CellHeight is the height in the projected coordinates of each pixel in the output image</param>
            <param name="CellWidth">CellWidth is the width in the projected coordinates of each pixel in the output image</param>
            <remarks>Call this function first if you are going to call functions</remarks>
        </member>
        <member name="M:MapWinGeoProc.Transforms.Projective.Derive_Coefficients(System.Int32,System.Int32,MapWinGIS.Point,MapWinGIS.Point,MapWinGIS.Point,MapWinGIS.Point)">
            <summary>
            Initializes the projective coefficients.  Requires that the input is
            a rectangular image, and the output points are the projected output
            values corresponding to the input image corners in the following positions: 
            pt2 - pt3
             |     |
            pt1 - pt4
            // X' = (aX + bY + c) / (gX + hY + 1)
            // Y' = (dX + eY + f) / (gX + hY + 1)
            </summary>
            <param name="ImageWidth">The width of the entire original image in pixels</param>
            <param name="ImageHeight">The height of the entire original image in pixels</param>
            <param name="ptLowerLeft">The projected location of the lower left corner of the input image</param>
            <param name="ptUpperLeft">The projected location of the upper left corner of the input image</param>
            <param name="ptUpperRight">The projected location of the upper right corner of the input image</param>
            <param name="ptLowerRight">The projected location of the lower right corner of the input image</param>
        </member>
        <member name="M:MapWinGeoProc.Transforms.Projective.Derive_Coefficients(MapWinGIS.Extents,MapWinGIS.Point,MapWinGIS.Point,MapWinGIS.Point,MapWinGIS.Point)">
            <summary>
            This routine is from a vector standpoint and doesn't care about aligning the projected image within a rectangular
            image framework. 
            </summary>
            <param name="OriginalExtents">An Extents object for the original shapefile or shape or vector.</param>
            <param name="ptLowerLeft">The projected location of the lower left corner of the original extents</param>
            <param name="ptUpperLeft">The projected location of the upper left corner of the original extents</param>
            <param name="ptUpperRight">The projected location of the upper right corner of the original extents</param>
            <param name="ptLowerRight">The projected location of the lower right corner of the original extents</param>
        </member>
        <member name="M:MapWinGeoProc.Transforms.Projective.Project_Point_Backward(System.Int32,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Takes output coordinates and determines what input coordinates to use.
            This assumes that you have already solved for the coefficients by 
            </summary>
            <param name="Xproj">Integer representing the X coordinate of the output image to back-project</param>
            <param name="Yproj">Integer representing the Y coordinate of the output image to back-project</param>
            <param name="Xoriginal">Integer representing the back-projected location in the input image</param>
            <param name="Yoriginal">Integer representing the back-projected location of the input image</param>
            <returns>false if the location was outside of the input image dimensions</returns>
        </member>
        <member name="M:MapWinGeoProc.Transforms.Projective.Project_Point_Foreward(MapWinGIS.Point,MapWinGIS.Point@)">
            <summary>
            This is for more of a vector handling of the problem.  Instead of returning an integer,
            this will project an actual point.
             X' = (aX + bY + c) / (gX + hY + 1)
             Y' = (dX + eY + f) / (gX + hY + 1)
            </summary>
            <param name="Original">The starting point</param>
            <param name="Projected">The projected point</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Transforms.Projective.Project_Point_Backward(MapWinGIS.Point,MapWinGIS.Point@)">
            <summary>
            This is for more of a vector handling of the problem.  Instead of returning an integer,
            this will back-project an actual point from the projected image to its source in the original
            </summary>
            <param name="Projected"></param>
            <param name="Original"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Transforms.Projective.ProjectImage(MapWinGIS.Image,System.String,MapWinGIS.ICallback)">
            <summary>
            Reprojects an image using the currently defined projective transform.
            Be sure to call Derive_Coefficients first.  This loops through point by point
            so won't be very fast.
            </summary>
            <param name="SourceImage">A MapWinGIS.Image object to be transformed</param>
            <param name="resultImage">A string representing the destination filename</param>
            <param name="ICallBack">A MapWinGIS.ICallback interface for progress messages</param>
            <remarks>ArgumentExceptions should be trapped for user error, but other types should be reported as bugs</remarks>
        </member>
        <member name="M:MapWinGeoProc.Transforms.Projective.Autosize_Cells(System.Double,System.Double,MapWinGIS.Point,MapWinGIS.Point,MapWinGIS.Point,MapWinGIS.Point)">
            <summary>
            This function will calculate a "scale" factor that should be the output pixel size.  If none is specified,
            this function is called internally.  This should prevent data loss, but may have more data than needed.
            </summary>
            <param name="Width">The width of the source image </param>
            <param name="Height">The height of the source image</param>
            <param name="outLL">The projected location of the lower left point</param>
            <param name="outUL">The projected location of the upper left point</param>
            <param name="outUR">The projected location of the upper right point</param>
            <param name="outLR">The projected location of the lower right point</param>
            <returns>A double value representing the cell-height and cell-width.</returns>
        </member>
        <member name="P:MapWinGeoProc.Transforms.Projective.OutputHeight">
            <summary>
            Gets the integer height in pixels of the projected image.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Transforms.Projective.OutputWidth">
            <summary>
            Gets the integer width in pixels of the projected image
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Transforms.Projective.dX">
            <summary>
            Gets the horizontal size of a pixel in the output image in the projected coordinates
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Transforms.Projective.dY">
            <summary>
            Gets the vertical size of a pixel in the output image in the projected coordinates
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Transforms.Projective.XllCenter">
            <summary>
            Gets a double value representing the horizontal location of the lower left pixel of the 
            output image in projected coordinates.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Transforms.Projective.YLLCenter">
            <summary>
            Gets a double value representing the vertical location of the lower left pixel of the 
            output image in projected coordinates.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Transforms.Projective.AffineWillWork">
            <summary>
            Solving the four points will also check to see if the projection can be solved using
            the Affine transform (only using 3 points).  If it can, it is recommended that you
            call the Project_Affine function.  Otherwise you will still be able to call the 
            Project_Affine function, but it probably won't be a good fit.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Buffer">
            <summary>
            Summary description for BufferPoly.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Buffer.BufferPoint(MapWinGIS.Point@,System.Double,System.Int32,MapWinGIS.Shape@)">
            <summary>
            Creates a circle (buffer) around a point.
            </summary>
            <param name="point">The point to be buffered.</param>
            <param name="radius">The distance (in units) from the point that the circle's boundary should exist at.</param>
            <param name="numQuadrants">The smoothness of the circle. Smaller value = smoother circle.</param>
            <param name="resultShp">The resulting buffer.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Buffer.BufferLine(MapWinGIS.Shape@,System.Double,MapWinGeoProc.Enumerations.Buffer_LineSide,MapWinGeoProc.Enumerations.Buffer_CapStyle,MapWinGeoProc.Enumerations.Buffer_EndCapStyle,System.Int32,MapWinGIS.Shape@)">
            <summary>
            Creates a buffer around a line shape.
            </summary>
            <param name="line">The line to be buffered.</param>
            <param name="distance">Distance (in units) from the line at which the buffer should be created.</param>
            <param name="buffSide">Which side of the line to buffer. 0 = both, 1 = left, 2 = right.</param>
            <param name="capStyle">Edge treatement. 0 = pointed, 1 = rounded.</param>
            <param name="endCapStyle">End treatment. 0 = pointed, 1 = rounded, 2 = closed (for polygons only!)</param>
            <param name="numQuadrants">Smoothness of rounded caps. Smaller value = smoother circle.</param>
            <param name="resultShp">The resulting polygon buffer.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Buffer.BufferPolygon(MapWinGIS.Shape@,System.Double,MapWinGeoProc.Enumerations.Buffer_HoleTreatment,MapWinGeoProc.Enumerations.Buffer_CapStyle,System.Int32,MapWinGIS.Shape@)">
            <summary>
            Creates a buffer shape around the polygon.
            </summary>
            <param name="polygon">The polygon to be buffered.</param>
            <param name="distance">Positive or negative value for buffer distance.</param>
            <param name="holeTreatment">How holes are to be treated. 0 == ignore, 1 == opposite, 2 == same</param>
            <param name="capStyle">Edge treatment. 0 = pointed, 1 = rounded.</param>
            <param name="numQuadrants">Smoothness of curves.</param>
            <param name="resultShp">The resulting buffer shape.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Buffer.BufferSimplePoly(MapWinGIS.Shape@,System.Double,MapWinGeoProc.Enumerations.Buffer_CapStyle,System.Int32,MapWinGIS.Shape@)">
            <summary>
            Creates a buffer around a single-part polygon.
            </summary>
            <param name="polygon">The simple polygon to be buffered.</param>
            <param name="distance">The distance from the polygon's border that the buffer should be created at.</param>
            <param name="capStyle">Edge treatement. 0 = pointed, 1 = rounded.</param>
            <param name="numQuadrants">Smoothness of rounded egdes. Smaller number = smoother circle.</param>
            <param name="resultShp">The resulting buffer.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Buffer.ClosePolyBuffer(MapWinGIS.Shape@,MapWinGIS.Shape@,System.Double,MapWinGeoProc.Enumerations.Buffer_LineSide,MapWinGeoProc.Enumerations.Buffer_CapStyle,System.Int32)">
            <summary>
            Creates an end-cap for a polygon that has been processed through BufferLine() so that
            the first and last points will be connected correctly.
            </summary>
            <param name="lastBuff">The last buffer shape that was created for the polygon line.</param>
            <param name="firstBuff">The first buffer shape that was created for the polygon line.</param>
            <param name="distance">The distance that is being used for buffer creation.</param>
            <param name="buffSide">The side of the line that is being buffered. 0 = both, 1 = left, 2 = right</param>
            <param name="capStyle">Edge treatement. 0 = pointed, 1 = rounded.</param>
            <param name="numQuadrants">Smoothness of rounded edges. Smaller values = smoother circle.</param>
        </member>
        <member name="M:MapWinGeoProc.Buffer.CombineOverlappingParts(MapWinGIS.Shapefile@)">
            <summary>
            This assumes that every shape in the input shapefile are going to be combined later
            as a multiPart shape. It checks to see if any of the parts overlap, if they do, and if
            they have the same orientation (hole or island) then the parts will be combined.
            </summary>
            <param name="shpFile">The shapefile containing the separated parts.</param>
        </member>
        <member name="M:MapWinGeoProc.Buffer.BufferPointSF(System.String@,System.String@,System.Double,System.Boolean,System.Int32)">
            <summary>
            Buffers all points in the point shapefile.
            </summary>
            <param name="pointSFPath">Full path to the shapefile of points.</param>
            <param name="resultSFPath">Full path to where the resulting buffer shapefile should be saved.</param>
            <param name="distance">Distance from point that buffer should be created.</param>
            <param name="uniteOverlaps">True if overlapping buffer shapes should be combined.</param>
            <param name="numQuadrants">Defines the smoothness of the circle.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Buffer.BufferLineSF(System.String@,System.String@,System.Double,System.Boolean,MapWinGeoProc.Enumerations.Buffer_LineSide,MapWinGeoProc.Enumerations.Buffer_CapStyle,MapWinGeoProc.Enumerations.Buffer_EndCapStyle,System.Int32)">
            <summary>
            Buffers all lines in the input line shapefile.
            </summary>
            <param name="lineSFPath">Full path to the line shapefile.</param>
            <param name="resultSFPath">Full path to the resulting buffer shapefile.</param>
            <param name="distance">Distance (in units) from line at which the associated buffer should be created.</param>
            <param name="uniteOverlaps">True if overlapping shapes should be combined.</param>
            <param name="buffSide">Specify which side of the line to buffer. 0 = both, 1 = left, 2 = right</param>
            <param name="capStyle">Edge treatement. 0 = pointed, 1 = rounded.</param>
            <param name="endCapStyle">End treatment. 0 = pointed, 1 = rounded.</param>
            <param name="numQuadrants">Smoothness of rounded caps. Smaller values = smoother circle.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Buffer.BufferPolygonSF(System.String@,System.String@,System.Double,System.Boolean,MapWinGeoProc.Enumerations.Buffer_HoleTreatment,MapWinGeoProc.Enumerations.Buffer_CapStyle,System.Int32)">
            <summary>
            Buffers all polygons in the input polygon shapefile.
            </summary>
            <param name="polySFPath">Full path to the polygon shapefile.</param>
            <param name="resultSFPath">Full path to the resulting buffer shapefile.</param>
            <param name="distance">Distance (in units) from polygon border at which the associated buffer should be created.</param>
            <param name="uniteOverlaps">True if overlapping shapes should be combined.</param>
            <param name="holeTreatment">How holes are to be treated. 0 == ignore, 1 == opposite, 2 == same</param>
            <param name="capStyle">Edge treatment. 0 = pointed, 1 = rounded.</param>
            <param name="numQuadrants">Smoothness of rounded edge. Smaller number = smoother circle.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Buffer.UniteShapes(MapWinGIS.Shapefile@)">
            <summary>
            Combines all overlapping shapes in the shapefile.
            </summary>
            <param name="shpFile">The shapefile to be modified.</param>
        </member>
        <member name="M:MapWinGeoProc.Buffer.InsertFieldIDs(MapWinGIS.Shapefile@)">
            <summary>
            Inserts the 'ID' attribute into the DBF table along 
            with ID values for each shape in the shapefile.
            </summary>
            <param name="resultSF">The shapefile that needs an ID field.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="T:KDTreeDLL.HRect">
            <summary>
            Hyper-Rectangle class supporting KDTree class
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Topology.LineSegment">
            <summary>
            Stores a set of double values that represents a line segment.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.LineSegment.X1">
            <summary>
            The X coordinate of the Start Point of the segment
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.LineSegment.Y1">
            <summary>
            The Y coordinate of the Start Point of the segment
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.LineSegment.Z1">
            <summary>
            The Z coordinate of the Start Point of the segment
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.LineSegment.X2">
            <summary>
            The X coordinate of the End Point of the segment
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.LineSegment.Y2">
            <summary>
            The Y coordinate of the End Point of the segment
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology.LineSegment.Z2">
            <summary>
            The Z coordinate of the End Point of the segment
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.#ctor">
            <summary>
            Creates a new blank instance of the LineSegment class where all the values are 0.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.#ctor(MapWinGeoProc.Topology.Vector)">
            <summary>
            Creates a new segment from the vector, assuming that the startpoint of the segment
            is the origin and the endpoint of the segment is the tail of the vector.
            </summary>
            <param name="V">The Vector to create a segment from.</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.#ctor(MapWinGIS.Point,MapWinGIS.Point)">
            <summary>
            Stores a set of double values that represents a line segment.
            </summary>
            <param name="StartPoint">A MapWinGIS.Point representing the beginning of the line segment</param>
            <param name="EndPoint">A MapWinGIS.Point representing the end of the line segment</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.#ctor(MapWinGeoProc.Topology.Point,MapWinGeoProc.Topology.Point)">
            <summary>
            Stores values representing a line segment
            </summary>
            <param name="StartPoint">A Topology.Point representing the start point of the segment</param>
            <param name="EndPoint">A Topology.Point representing the end point of the segment</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.#ctor(MapWinGeoProc.Topology.Point,MapWinGeoProc.Topology.Vector)">
            <summary>
            Creates a new segment from a point and a vector.  The point represents the start point
            or tail of the vector, and the vector is added to that point to find the second point.
            </summary>
            <param name="StartPoint">Point representing one of the points of the segment</param>
            <param name="StartToEnd">Vector representing the path of the segment</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Stores a set of double values that represents a line segment.
            </summary>
            <param name="x1">A Double representing the X coordinate of the beginning of the line segment</param>
            <param name="y1">A Double representing the Y coordinate of the beginning of the line segment</param>
            <param name="z1">A Double representing the Z coordinate of the beginning of the line segment</param>
            <param name="x2">A Double representing the X coordinate of the end of the line segment</param>
            <param name="y2">A Double representing the Y coordinate of the end of the line segment</param>
            <param name="z2">A Double representing the Z coordinate of the end of the line segment</param>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.LocationByX(System.Double,MapWinGeoProc.Topology.Point@)">
            <summary>
            Given a segment, we try fix the value of one coordinate to solve
            for the other two.
            </summary>
            <param name="Xcoordinate">The value to use as X</param>
            <param name="Intercept">The location of the segment when X = Xcoordinate </param>
            <returns>Boolean.  False if there is no valid intersection.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.LocationByY(System.Double,MapWinGeoProc.Topology.Point@)">
            <summary>
            Given a segment, we try fix the value of one coordinate to solve
            for the other two.
            </summary>
            <param name="Ycoordinate">The value to use as Y</param>
            <param name="Intercept">The location of the segment when Y = Ycoordinate </param>
            <returns>Boolean.  False if there is no valid intersection.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.LocationByZ(System.Double,MapWinGeoProc.Topology.Point@)">
            <summary>
            Given a segment, we try fix the value of one coordinate to solve
            for the other two.
            </summary>
            <param name="Zcoordinate">The value to use as Z</param>
            <param name="Intercept">The location of the segment when Z = Zcoordinate </param>
            <returns>Boolean.  False if there is no valid intersection.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.Crosses(MapWinGeoProc.Topology.LineSegment)">
            <summary>
            Checks to see if two segments cross.  This will not return true if
            the endpoints touch, or the lines are identical.  Specifically the
            middle portions of the lines have to contact each other.
            </summary>
            <param name="Seg">The LineSegment to compare this segment to.</param>
            <returns>True if the lines completely cross each other.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.ClosestPointTo(MapWinGeoProc.Topology.Point)">
            <summary>
            Returns a Point representing the closest point.
            </summary>
            <param name="Point"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.Distance(MapWinGeoProc.Topology.Point)">
            <summary>
            Calculates the shortest distance to this line segment from the specified MapWinGIS.Point
            </summary>
            <param name="Point">A MapWinGIS.Point specifing the location to find the distance to the line</param>
            <returns>A double value that is the shortest distance from the given Point to this line segment</returns>          
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.Distance(MapWinGeoProc.Topology.LineSegment)">
            <summary>
            Determines the shortest distance between two segments
            </summary>
            <param name="LineLineSegment">LineSegment, The line segment to test against this segment</param>
            <returns>Double, the shortest distance between two segments</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.Distance(MapWinGeoProc.Topology.LineString)">
            <summary>
            Determines the shortest distance to any of the lines in the polyline.
            </summary>
            <param name="PolyLn">The polyline to investigate</param>
            <returns>Double, the distance to the closest segment</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.Intersects(MapWinGIS.Point)">
            <summary>
            Determines whether the point falls on a line segment
            </summary>
            <param name="Point">The MapWinGIS.Point to test agianst this segment</param>
            <returns>Boolean, true if the point is on the segment</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.Intersects(MapWinGeoProc.Topology.Point)">
            <summary>
            Determines whether the point falls on a line segment
            </summary>
            <param name="Point">The Point to test agianst this segment</param>
            <returns>Boolean, true if the point is on the segment</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.Intersects(MapWinGeoProc.Topology.LineSegment)">
            <summary>
            Will return true if the segments intersect or are coincidental.
            </summary>
            <param name="LineLineSegment">The line segment to compare with</param>
            <returns>Boolean, true if the line segments touch each other, false otherwise</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.IsCompletelyWithin(MapWinGeoProc.Topology.Polygon)">
            <summary>
            Returns true if the entire segment is within the polygon,
            without touching or crossing any of the edges.
            </summary>
            <param name="Pgn">The polygon to investigate</param>
            <returns>Boolean, true if the segment is completely inside the polygon</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.IsIdenticalTo(MapWinGeoProc.Topology.LineSegment)">
            <summary>
            Checks the points of the segemnts to see if they are the same,
            but is unconcerned with direction.  
            </summary>
            <param name="Seg">The LineSegment to compare against this segment</param>
            <returns>True if the segment points are the same.  Sequence doesn't matter.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.IsParallelTo(MapWinGeoProc.Topology.LineSegment)">
            <summary>
            Returns true if the line segments are parallel
            </summary>
            <param name="LineLineSegment">The Topology.SegementD LineSegment to compare to </param>
            <returns>Boolean, true if the segments are parallel</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.IsPerpendicularTo(MapWinGeoProc.Topology.LineSegment)">
            <summary>
            Returns true if the line segments are perpendicular
            </summary>
            <param name="LineLineSegment">The LineSegment line segment to compare this segment with</param>
            <returns>Boolean, true if the segments are perpendicular</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.IsWithinADistanceOf(MapWinGIS.Point,System.Double)">
            <summary>
            Determines whether the point is within the buffer region of the line segment
            </summary>
            <param name="Point">A MapWinGIS.Point to check agianst this line segment</param>
            <param name="Distance">The double distance the point can be from the line and still be considered contained</param>
            <returns>Boolean, true if the point is within the buffer distance of the line segment</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.IsWithinADistanceOf(MapWinGeoProc.Topology.Point,System.Double)">
            <summary>
            Determines whether the point is within the buffer region of the line segment
            </summary>
            <param name="Point">A Point to check agianst this line segment</param>
            <param name="Dist">The double distance the point can be from the line and still be considered contained</param>
            <returns>Boolean, true if the point is within the buffer distance of the line segment</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.Touches(MapWinGeoProc.Topology.LineSegment)">
            <summary>
            Checks to see if two segments touch.  This is true if a vertex from
            one segment intersects with the other segment.  Does not return true
            if only the line areas touch one another.
            </summary>
            <param name="Seg">A LineSegment to compare to.</param>
            <returns>Boolean, true if an endpoint intersects with a line.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology.LineSegment.ToVector">
            <summary>
            Creates a new vector from this segment where the StartPoint becomes
            the beginning of the vector and the end point is the tip of the vector.
            </summary>
            <returns>A Vector from Point 1 to Point 2 in this segment</returns>
        </member>
        <member name="P:MapWinGeoProc.Topology.LineSegment.mwStartPoint">
            <summary>
            A MapWinGIS.Point representing the beginning of the line segment
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology.LineSegment.StartPoint">
            <summary>
            A Point representing the beginning of the line segment
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology.LineSegment.mwEndPoint">
            <summary>
            A MapWinGIS.Point representing the end of the line segment
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology.LineSegment.EndPoint">
            <summary>
            A MapWinGIS.Point representing the end of the line segment
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology.LineSegment.Length">
            <summary>
            A Double representing the length of the segment
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology.LineSegment.Center">
            <summary>
            The geometric center of the line.  This is simply the average of the
            X, Y and Z coordinates.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Topology2D.GeometryFactory">
            <summary>
            This class enables developers to create the various geometries.
            Accessors for these are generally also provided in the constructors.
            The only references with regards to topology2D are here
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.GeometryFactory.CreateCoordinate(MapWinGIS.Point)">
            <summary>
            MapWinGIS referencing is only done in the geometry factory.
            </summary>
            <param name="mwPoint"></param>
            <returns>A Coordinate created from mwPoint</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.GeometryFactory.CreateCoordinate(System.Object)">
            <summary>
            Creates a point from a MapWinGIS.Point passed as a generic object
            </summary>
            <param name="objPoint">A MapWinGIS.Point</param>
            <returns>A Coordinate generated from the MapWinGIS.Point</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.GeometryFactory.CreatePoint(MapWinGIS.Point)">
            <summary>
            MapWinGIS referencing is only done in the geometry factory.
            </summary>
            <param name="mwPoint"></param>
            <returns>A new Point object</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.GeometryFactory.CreatePoint(System.Object)">
            <summary>
            Creates a point from a MapWinGIS.Point passed as a generic object
            </summary>
            <param name="objPoint">A MapWinGIS.Point</param>
            <returns>A Point generated fromt he MapWinGIS.Point</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.GeometryFactory.CreateLineString(System.Object)">
            <summary>
            Creates a new instance of the polyline class
            </summary>
            <param name="MapWinGIS_Shape">A MapWinGIS.Shape to derive the polyline from</param>
            <remarks>Assumes shape is one part.  To Split Multipart shapes, use Split.</remarks>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.GeometryFactory.CreateMultiLineString(System.Object)">
            <summary>
            Creates a new instance of a MultLineSTring from a Late-Bound object
            </summary>
            <param name="MapWinGIS_Shape">Uses object so we can localized MapWinGIS Dependency</param>
            <returns>A MultLineString</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.GeometryFactory.CreateMultiLineString(MapWinGIS.Shape)">
            <summary>
            Returns a MultiLineString geometry collection derived from the mwShape
            </summary>
            <param name="mwShape">The shape to convert into a multi-line string</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.GeometryFactory.mwPointFromCoord(MapWinGeoProc.Topology2D.Coordinate)">
            <summary>
            This creates a strongly typed MapWinGIS Point from a coordinate
            </summary>
            <param name="Coord">The coordinates to turn into points</param>
            <returns>MapWinGIS.Point</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.GeometryFactory.mwPointFromPoint(MapWinGeoProc.Topology2D.Point)">
            <summary>
            This creates a strongly typed MapWinGIS Point from a Topology.Point
            </summary>
            <param name="Loc">The coordinates to turn into points</param>
            <returns>MapWinGIS.Point</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.GeometryFactory.mwPointFromVector(MapWinGeoProc.Topology2D.Vector)">
            <summary>
            This will return a strongly typed MapWinGIS Vector
            </summary>
            <param name="Vec">Vector</param>
            <returns>MapWinGIS.Point</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.GeometryFactory.mwShapeFromMultiLineString(MapWinGeoProc.Topology2D.MultiLineString)">
            <summary>
            Returns a SHP_POLYLINE type MapWinGIS Multi-part PolyLine representing this multiLineString
            </summary>
            <returns>MapWinGIS Shape</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.GeometryFactory.mwShapeFromMultiLineString(MapWinGeoProc.Topology2D.MultiLineString,MapWinGIS.ShpfileType)">
            <summary>
            Returns a MapWinGIS Multi-part PolyLine representing this multiLineString
            </summary>
            <returns>MapWinGIS Shape</returns>
        </member>
        <member name="T:MapWinGeoProc.Topology2D.Envelope">
            <summary>
            A primitive rectangle class for holding double values
            Since we define it in terms of X, Y and Z, this is an 
            axis-aligned bounding box (AABB). 
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.Envelope.xMin">
            <summary>
            Double, The minimum X value
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.Envelope.xMax">
            <summary>
            Double, The largest X value
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.Envelope.yMin">
            <summary>
            Double, The minimum Y value
            </summary>
        </member>
        <member name="F:MapWinGeoProc.Topology2D.Envelope.yMax">
            <summary>
            Double, the largest Y value
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.#ctor">
            <summary>
            Creates a new, blank extents object with all the extents = 0.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a new instance of Envelope from double values
            </summary>
            <param name="MinX">Double, The minimum X value</param>
            <param name="MaxX">Double, The largest X value</param>
            <param name="MinY">Double, The minimum Y value</param>
            <param name="MaxY">Double, the largest Y value</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.#ctor(MapWinGIS.Extents)">
            <summary>
            Creates a new instance of Envelope from double values in the MapWinGIS.Envelope object
            </summary>
            <param name="Bounds">A MapWinGIS.Extents object to define a rectangle</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.#ctor(MapWinGeoProc.Topology2D.LineSegment)">
            <summary>
            Calculates a new extents object that is just large enough to contain the entire segment.
            </summary>
            <param name="seg">A LineSegment to use as the "diagonal" of this extents object.</param>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.Contains(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Tests to see if the specified geometry.
            To contain, it means that no part of the specified geometry can fall outside
            of the given position.
            </summary>
            <param name="geom">Any geometry to test to see if it is contained in the extents.</param>
            <returns>Boolean, true if the specified geometry is contained in the extents.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.Crosses(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.Disjoint(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.Equals(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.Intersects(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Checks to see if this envelope intersects with the specified object.
            This will be true if the object is inside this envelope or touches etc.
            </summary>
            <param name="geom">THe geometry to test for an intersection.</param>
            <returns>Boolean, true if there is an intersection.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.Overlaps(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.Touches(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.Within(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.AsBinary">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.AsText">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.Boundary">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.Buffer(System.Double)">
            <summary>
            Not Implemented
            </summary>
            <param name="Distance"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.ConvexHull">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.Difference(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.Distance(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.Equals(System.Object)">
            <summary>
            Checks to see if Any object qualifies for geometric equality
            but will return false if the unspecified type is not a geometry.
            </summary>
            <param name="obj">Any object</param>
            <returns>Boolean, true if the specified object is goemetrically equivalent to this one.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.GetHashCode">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.Intersection(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Returns a geometry representing the region where both shapes intersect.
            </summary>
            <param name="geom">Any geometry to intersect with this Envelope.</param>
            <returns>The geometry that best describes the intersection.  Null if they don't intersect.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.Relate(MapWinGeoProc.Topology2D.Geometry,System.String)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <param name="IntersectionPatternMatrix"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.SymDifference(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.ToString">
            <summary>
            Not Implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.Union(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Not Implemented
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.ClosestPointOn(MapWinGeoProc.Topology2D.LineSegment)">
            <summary>
            In the 2D case, the shortest path to the specified segment is on one of the segments here.
            This determines the shortest path and picks shortest distance.  Then it returns the point
            on the specified segment that is closest to this extent.
            </summary>
            <param name="Seg">A LineSegment to find the closest point on.</param>
            <returns>Topology2D.Point specifying the closest point on the specified segment.
            This returns null if there is an intersection.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.ClosestPointOn(MapWinGeoProc.Topology2D.Envelope)">
            <summary>
            If the two extents intersect, this returns null.
            This checks all the possible shortest paths between the 4 Borders of both extents.
            This finds the shortest one and then reutrns the location of the point on the specified
            extents rectangle that is closest to this one.
            </summary>
            <param name="Ext">Envelope to compare to this object.</param>
            <returns>A point representing the closest point on the specified extents.  Returns null
            if the two extents intersect.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.ClosestPointTo(MapWinGeoProc.Topology2D.Point)">
            <summary>
            Finds the shortest pathway between the borders of this extent and the specified point.
            Returns the point on this extents that is closest to the specified point.
            </summary>
            <param name="Pnt">The point to compare against.</param>
            <returns>The Topology2D.Point representing the closest point on this Envelope to the specified point.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.ClosestPointTo(MapWinGeoProc.Topology2D.LineSegment)">
            <summary>
            In the 2D case, the shortest path to the specified segment is on one of the segments here.
            This determines the shortest path and picks shortest distance.  Then it returns the point
            on the this extents that is closest to the specified segment.
            </summary>
            <param name="Seg">A LineSegment to compare to.</param>
            <returns>Topology2D.Point specifying the closest point on this extents to the specified segment.
            This returns null if there is an intersection.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.ClosestPointTo(MapWinGeoProc.Topology2D.Envelope)">
            <summary>
            If the two extents intersect, this returns null.
            This checks all the possible shortest paths between the 4 Borders of both extents.
            This finds the shortest one and then returns the location of the point on this object
            that is closest to the specified extents.
            </summary>
            <param name="Ext">Envelope to compare to this object.</param>
            <returns>A point representing the closest point on this object to the specified extents.
            Returns null if the two extents intersect.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.CompletelyContains(MapWinGeoProc.Topology2D.Point)">
            <summary>
            Ensures that the point is not only within the extents, but also doesn't
            touch any of the borders.
            </summary>
            <param name="Pnt">A Topology2D point to test.</param>
            <returns>Boolean, true if the point is entirely within the extents, without touching the edges.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.CompletelyContains(MapWinGeoProc.Topology2D.LineSegment)">
            <summary>
            Ensures that the segment is completely within the extents without touching the border.
            </summary>
            <param name="Seg">The Topology2D.LineSegment to compare against</param>
            <returns>Boolean, true if both points of the segment are completely within the extents</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.CompletelyContains(MapWinGeoProc.Topology2D.Envelope)">
            <summary>
            checks to ensure that this Envelope completely contains the specified extents.
            </summary>
            <param name="Ext">The extents to compare to this extents</param>
            <returns>Boolean, true if the specified extents is within this extents without touching the borders</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.Copy">
            <summary>
            Returns a new instance of the Envelope class with the same values as this object.
            </summary>
            <returns>Topology2D.Envelope with identical properties.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.GetCorners">
            <summary>
            returns the four corners for this envelope in a list of points.
            We might do geometry collection eventually, but for now a list will do.
            </summary>
            <returns>List of points.  </returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.Distance(MapWinGeoProc.Topology2D.Point)">
            <summary>
            Finds the shortest path to the specified point, and returns the length.
            </summary>
            <param name="Pnt">The Topology2D.Point to test agianst.</param>
            <returns>Double, the length of the shortest path.  0 if intersects.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.Distance(MapWinGeoProc.Topology2D.LineSegment)">
            <summary>
            Finds the path between the two closest points between this object and the segment.
            Returns the length.  Returns 0.0 if the two intersect.
            </summary>
            <param name="Seg">The Topology2D.LineSegment to compare to.</param>
            <returns>Double, the shortest possible distance between this extents and the segment.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.Distance(MapWinGeoProc.Topology2D.Envelope)">
            <summary>
            Finds the shortest path between the two closest points on the two extents objects.
            Returns 0.0 if the two intersect.
            </summary>
            <param name="Ext">The Topology2D.Envelope to compare to.</param>
            <returns>Double, the magnitude of shortest path between the extents.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.Intersects(MapWinGIS.Point)">
            <summary>
            Determines whether a point is inside or on the bounds of the rectangle
            </summary>
            <param name="Point">A MapWinGIS.Point parameter</param>
            <returns>True if the point is inside or on the bounds of the rectangle</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.IntersectionArea(MapWinGeoProc.Topology2D.LineSegment)">
            <summary>
            The purpose of this is to reduce a potentially much larger extents down
            to a more manageable extents by making it just big enough to contain the complete
            intersection with a segment.
            </summary>
            <param name="Seg">LineSegment to look for an intersection with</param>
            <returns>An Envelope object that is the intersection between this extents and the segment.
            This should be smaller than the AOI of the extents and the segment's extents.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.IsCompletelyWithin(MapWinGeoProc.Topology2D.Envelope)">
            <summary>
            For completeness.  Simply tests if the specified extents contain these 
            extents completely so that no borders are touching.
            </summary>
            <param name="Ext">The extents to compare against</param>
            <returns>Boolean, true if all the points of this extents lie within the other extents.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.Within(MapWinGeoProc.Topology2D.Envelope)">
            <summary>
            For completeness.  Simply tests if the Envelope specified contains these extents.
            </summary>
            <param name="Ext">The extents to compare against these extents</param>
            <returns>Boolean, true if every corner of this rectangle intersects with the specified rectangle.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.IsCrossedByTheOutlineOf(MapWinGeoProc.Topology2D.Envelope)">
            <summary>
            This specifically checks the borders to see if any of the segments
            completely cross over each other.  Touching or overlapping won't
            evaluate as true. 
            </summary>
            <param name="Ext">The extents object to compare with.</param>
            <returns>Boolean, true if any of the segments from this </returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.IsIdenticalTo(MapWinGeoProc.Topology2D.Envelope)">
            <summary>
            Checks against another extents to determine if all the extent values are the same
            </summary>
            <param name="Ext">The extent to compare to</param>
            <returns>Boolean, true if all four extents are the same</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.IsWithinADistanceOf(MapWinGeoProc.Topology2D.Point,System.Double)">
            <summary>
            Checks to see if the shortest distance from this extents to the specified
            point is less than or equal to the specified distance.
            </summary>
            <param name="Pnt">A Topology2D.Point object to judge the distance to.</param>
            <param name="Dist">Double, the maximum allowed distance for the shortest path between objects.</param>
            <returns>Boolean, true if the actual distance is less than or equal to the specified value.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.IsWithinADistanceOf(MapWinGeoProc.Topology2D.LineSegment,System.Double)">
            <summary>
            Checks to see if the shortest distance from this extents to the specified
            LineSegment is less than or equal to the specified distance.
            </summary>
            <param name="Seg">A Topology2D.LineSegment object to judge the distance to.</param>
            <param name="Dist">Double, the maximum allowed distance for the shortest path between objects.</param>
            <returns>Boolean, true if the actual distance is less than or equal to the specified value.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.IsWithinADistanceOf(MapWinGeoProc.Topology2D.Envelope,System.Double)">
            <summary>
            Checks to see if the shortest distance from this extents to the specified
            Envelope is less than or equal to the specified distance.
            </summary>
            <param name="Ext">The Envelope object to compare with.</param>
            <param name="Dist">The maximum distance allowed</param>
            <returns>Boolean, true if the actual distance is less than or equal to the specified value.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.ShortestPathTo(MapWinGeoProc.Topology2D.Geometry)">
            <summary>
            Determines the pathway from the border of this extents object to the 
            specified geometry that is the shortest.  The startpoint will be on this extents
            object, while the endpoint will be on the specified point.
            </summary>
            <param name="geom">The geometry to find a path to.</param>
            <returns>Topology2D.LineSegment that is the shortest path between the extent borders and the specified point.
            Returns null if the point intersects with these extents.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.TouchesTheBoundaryOf(MapWinGeoProc.Topology2D.Polygon)">
            <summary>
            checks to see if any of the segments that make either the boundaries of this extents
            or the boundaries of the polygon have an endpoint that intersects with the opposite.
            </summary>
            <param name="Pgn">The polygon to check against.</param>
            <returns>Boolean, true if any segments from either the extent or polygon boundaries has an endpoint that intersects with the other.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.TouchesTheBoundaryOf(MapWinGeoProc.Topology2D.Envelope)">
            <summary>
            Tests to see if any of the boundaries are the same or touch.
            </summary>
            <param name="Ext">The Envelope object to compare with.</param>
            <returns>True if any of the extents are the same.</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.AreIdenticalTo(MapWinGeoProc.Topology2D.Envelope)">
            <summary>
            Checks each value in the point to see if they are the same
            </summary>
            <param name="Ext">The Envelope to compare with this point</param>
            <returns>Boolean, true if the points are the same</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.AreIdenticalTo(MapWinGIS.Extents)">
            <summary>
            Checks each value in the point to see if they are the same
            </summary>
            <param name="Ext">The Envelope to compare with this point</param>
            <returns>Boolean, true if the points are the same</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.ToMapWinEnvelope">
            <summary>
            Converts this rectangleD to a MapWinGIS.Extents object
            </summary>
            <returns>A MapWinGIS.Extents object with the same measurements as Envelope</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.ToLineSegments">
            <summary>
            Creates a list of segments that define the boundaries of the extents.
            </summary>
            <returns>List of LineSegments</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.LineSegmentsWithin(MapWinGeoProc.Topology2D.Envelope)">
            <summary>
            If this extents were a rectangle, this would return the borders of the
            rectangle that fall within the specified extents.
            </summary>
            <param name="Ext">An Envelope object specifying the region to return segments from.</param>
            <returns>A List of LineSegments containing any segments that have any intersection with Ext</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.op_Equality(MapWinGeoProc.Topology2D.Envelope,System.Object)">
            <summary>
            Returns true if X and Y coordinates are equal for extremes of both envelopes
            </summary>
            <param name="U">An Envelope to compare</param>
            <param name="objV">Any object to compare with the Envelope</param>
            <returns>Boolean, true if the object is an equivalent envelope or rectangular polygon</returns>
        </member>
        <member name="M:MapWinGeoProc.Topology2D.Envelope.op_Inequality(MapWinGeoProc.Topology2D.Envelope,System.Object)">
            <summary>
            Returns true if X and Y coordinates are different for extremes of both envelopes
            </summary>
            <param name="U">An Envelope to compare</param>
            <param name="objV">An object to compare</param>
            <returns>Boolean, false if the object is an equivalent envelope or rectangular polygon</returns>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.Envelope.Width">
            <summary>
            Gets or sets the width.  Setting this will keep xMin the same and adjust xMax.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.Envelope.Height">
            <summary>
            Gets or sets the height.  Setting this will keep the yMin the same and adjust yMax.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.Envelope.Center">
            <summary>
            Gets or sets the center.  Setting this will translate the entire box.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.Topology2D.Envelope.Dimension">
            <summary>
            Integer, Specifies the number of spatial dimensions for this object.
            A value of 2 represents 2D space, 3 represents 3D space.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Utilities.UniqueCoordinateArrayFilter">
            <summary>
            A <c>CoordinateFilter</c> that builds a set of <c>Coordinate</c>s.
            The set of coordinates contains no duplicate points.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.UniqueCoordinateArrayFilter.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.UniqueCoordinateArrayFilter.Filter(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="coord"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Utilities.UniqueCoordinateArrayFilter.Coordinates">
            <summary>
            Returns the gathered <c>Coordinate</c>s.
            </summary>
        </member>
        <member name="T:Iesi.Collections.SortedSet">
            <summary>
            Implements a <c>Set</c> based on a sorted tree.  This gives good performance for operations on very
            large data-sets, though not as good - asymptotically - as a <c>HashedSet</c>.  However, iteration
            occurs in order.  Elements that you put into this type of collection must implement <c>IComparable</c>,
            and they must actually be comparable.  You can't mix <c>string</c> and <c>int</c> values, for example.
            </summary>
        </member>
        <member name="M:Iesi.Collections.SortedSet.#ctor">
            <summary>
            Creates a new set instance based on a sorted tree.
            </summary>
        </member>
        <member name="M:Iesi.Collections.SortedSet.#ctor(System.Collections.IComparer)">
            <summary>
            Creates a new set instance based on a sorted tree.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.IComparer"/> to use for sorting.</param>
        </member>
        <member name="M:Iesi.Collections.SortedSet.#ctor(System.Collections.ICollection)">
            <summary>
            Creates a new set instance based on a sorted tree and
            initializes it based on a collection of elements.
            </summary>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
        </member>
        <member name="M:Iesi.Collections.SortedSet.#ctor(System.Collections.ICollection,System.Collections.IComparer)">
            <summary>
            Creates a new set instance based on a sorted tree and
            initializes it based on a collection of elements.
            </summary>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
            <param name="comparer">The <see cref="T:System.Collections.IComparer"/> to use for sorting.</param>
        </member>
        <member name="T:Iesi.Collections.Generic.ListSet`1">
            <summary>
            Implements a <c>Set</c> based on a list.  Performance is much better for very small lists 
            than either <c>HashedSet</c> or <c>SortedSet</c>.  However, performance degrades rapidly as 
            the data-set gets bigger.  Use a <c>HybridSet</c> instead if you are not sure your data-set
            will always remain very small.  Iteration produces elements in the order they were added.
            However, element order is not guaranteed to be maintained by the various <c>Set</c>
            mathematical operators.  
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.ListSet`1.#ctor">
            <summary>
            Creates a new set instance based on a list.
            </summary>
        </member>
        <member name="M:Iesi.Collections.Generic.ListSet`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Creates a new set instance based on a list and
            initializes it based on a collection of elements.
            </summary>
            <param name="initialValues">A collection of elements that defines the initial set contents.</param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Utilities.CoordinateCompare">
            <summary>
            CoordinateCompare is used in the sorting of arrays of Coordinate objects.
            Implements a lexicographic comparison.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.CoordinateCompare.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Utilities.CoordinateCompare.Compare(System.Object,System.Object)">
             <summary>
             Compares two object and returns a value indicating whether one is less than, equal to or greater
             than the other.
             </summary>
             <param name="x">First Coordinate object to compare.</param>
             <param name="y">Second Coordinate object to compare.</param>
             <returns>
            &lt;table cellspacing="0" class="dtTABLE"&gt;
            &lt;TR VALIGN="top"&gt;
            	 &lt;TH width=50%&gt;Value&lt;/TH&gt;
            &lt;TH width=50%&gt;Condition&lt;/TH&gt;
            &lt;/TR&gt;
            &lt;TR VALIGN="top"&gt;
            	 &lt;TD width=50%&gt;Less than zero&lt;/TD&gt;
            &lt;TD width=50%&gt;&lt;I&gt;a&lt;/I&gt; is less than &lt;I&gt;b&lt;/I&gt;.&lt;/TD&gt;
            &lt;/TR&gt;
            &lt;TR VALIGN="top"&gt;
            	 &lt;TD width=50%&gt;Zero&lt;/TD&gt;
            &lt;TD width=50%&gt;&lt;I&gt;a&lt;/I&gt; equals &lt;I&gt;b&lt;/I&gt;.&lt;/TD&gt;
            &lt;/TR&gt;
            &lt;TR VALIGN="top"&gt;
            	 &lt;TD width=50%&gt;Greater than zero&lt;/TD&gt;
            &lt;TD width=50%&gt;&lt;I&gt;a&lt;/I&gt; is greater than &lt;I&gt;b&lt;/I&gt;.&lt;/TD&gt;
            &lt;/TR&gt;
            &lt;/table&gt;
             </returns>
             <remarks>If a implements IComparable, then a. CompareTo (b) is returned; otherwise, if b 
             implements IComparable, then b. CompareTo (a) is returned.
             Comparing a null reference (Nothing in Visual Basic) with any type is allowed and does not
             generate an exception when using IComparable. When sorting, a null reference (Nothing) is 
             considered to be less than any other object.
             </remarks>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineStringSimplifier">
            <summary>
            Simplifies a TaggedLineString, preserving topology
            (in the sense that no new intersections are introduced).
            Uses the recursive D-P algorithm.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineStringSimplifier.#ctor(MapWinGeoProc.NTS.Topology.Simplify.LineSegmentIndex,MapWinGeoProc.NTS.Topology.Simplify.LineSegmentIndex)">
            <summary>
            
            </summary>
            <param name="inputIndex"></param>
            <param name="outputIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineStringSimplifier.Simplify(MapWinGeoProc.NTS.Topology.Simplify.TaggedLineString)">
            <summary>
            
            </summary>
            <param name="line"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineStringSimplifier.SimplifySection(System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <param name="depth"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineStringSimplifier.FindFurthestPoint(MapWindow.Interfaces.Geometries.ICoordinate[],System.Int32,System.Int32,System.Double[])">
            <summary>
            
            </summary>
            <param name="pts"></param>
            <param name="i"></param>
            <param name="j"></param>
            <param name="maxDistance"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineStringSimplifier.Flatten(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineStringSimplifier.HasBadIntersection(MapWinGeoProc.NTS.Topology.Simplify.TaggedLineString,System.Int32[],MapWinGeoProc.NTS.Topology.Geometries.LineSegment)">
            <summary>
            
            </summary>
            <param name="parentLine"></param>
            <param name="sectionIndex"></param>
            <param name="candidateSeg"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineStringSimplifier.HasBadOutputIntersection(MapWinGeoProc.NTS.Topology.Geometries.LineSegment)">
            <summary>
            
            </summary>
            <param name="candidateSeg"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineStringSimplifier.HasBadInputIntersection(MapWinGeoProc.NTS.Topology.Simplify.TaggedLineString,System.Int32[],MapWinGeoProc.NTS.Topology.Geometries.LineSegment)">
            <summary>
            
            </summary>
            <param name="parentLine"></param>
            <param name="sectionIndex"></param>
            <param name="candidateSeg"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineStringSimplifier.IsInLineSection(MapWinGeoProc.NTS.Topology.Simplify.TaggedLineString,System.Int32[],MapWinGeoProc.NTS.Topology.Simplify.TaggedLineSegment)">
            <summary>
            Tests whether a segment is in a section of a TaggedLineString-
            </summary>
            <param name="line"></param>
            <param name="sectionIndex"></param>
            <param name="seg"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineStringSimplifier.HasInteriorIntersection(MapWinGeoProc.NTS.Topology.Geometries.LineSegment,MapWinGeoProc.NTS.Topology.Geometries.LineSegment)">
            <summary>
            
            </summary>
            <param name="seg0"></param>
            <param name="seg1"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineStringSimplifier.Remove(MapWinGeoProc.NTS.Topology.Simplify.TaggedLineString,System.Int32,System.Int32)">
            <summary>
            Remove the segs in the section of the line.
            </summary>
            <param name="line"></param>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Simplify.TaggedLineStringSimplifier.DistanceTolerance">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateOp">
            <summary>
            Implements the <c>Relate()</c> operation on <c>Geometry</c>s.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateOp.Relate(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateOp.#ctor(MapWindow.Interfaces.Geometries.IGeometry,MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            
            </summary>
            <param name="g0"></param>
            <param name="g1"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateOp.IntersectionMatrix">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateNode">
            <summary>
            A RelateNode is a Node that maintains a list of EdgeStubs
            for the edges that are incident on it.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.GeometriesGraph.Node">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.Node.coord">
            <summary>
            Only non-null if this node is precise.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.GeometriesGraph.Node.edges">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Node.#ctor(MapWindow.Interfaces.Geometries.ICoordinate,MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEndStar)">
            <summary>
            
            </summary>
            <param name="coord"></param>
            <param name="edges"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Node.ComputeIM(MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix)">
            <summary>
            Basic nodes do not compute IMs.
            </summary>
            <param name="im"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Node.Add(MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEnd)">
            <summary> 
            Add the edge to the list of edges at this node.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Node.MergeLabel(MapWinGeoProc.NTS.Topology.GeometriesGraph.Node)">
            <summary>
            
            </summary>
            <param name="n"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Node.MergeLabel(MapWinGeoProc.NTS.Topology.GeometriesGraph.Label)">
            <summary>
            To merge labels for two nodes,
            the merged location for each LabelElement is computed.
            The location for the corresponding node LabelElement is set to the result,
            as long as the location is non-null.
            </summary>
            <param name="label2"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Node.SetLabel(System.Int32,MapWindow.Interfaces.Geometries.Locations)">
            <summary>
            
            </summary>
            <param name="argIndex"></param>
            <param name="onLocation"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Node.SetLabelBoundary(System.Int32)">
            <summary> 
            Updates the label of a node to BOUNDARY,
            obeying the mod-2 boundaryDetermination rule.
            </summary>
            <param name="argIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Node.ComputeMergedLocation(MapWinGeoProc.NTS.Topology.GeometriesGraph.Label,System.Int32)">
            <summary> 
            The location for a given eltIndex for a node will be one
            of { Null, Interior, Boundary }.
            A node may be on both the boundary and the interior of a point;
            in this case, the rule is that the node is considered to be in the boundary.
            The merged location is the maximum of the two input values.
            </summary>
            <param name="label2"></param>
            <param name="eltIndex"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Node.Write(System.IO.StreamWriter)">
            <summary>
            
            </summary>
            <param name="outstream"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.GeometriesGraph.Node.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Node.Coordinate">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Node.Edges">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.GeometriesGraph.Node.IsIsolated">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateNode.#ctor(MapWindow.Interfaces.Geometries.ICoordinate,MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeEndStar)">
            <summary>
            
            </summary>
            <param name="coord"></param>
            <param name="edges"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateNode.ComputeIM(MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix)">
            <summary>
            Update the IM with the contribution for this component.
            A component only contributes if it has a labelling for both parent geometries.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Relate.RelateNode.UpdateIMFromEdges(MapWinGeoProc.NTS.Topology.Geometries.IntersectionMatrix)">
            <summary>
            Update the IM with the contribution for the EdgeEnds incident on this node.
            </summary>
            <param name="im"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeDirectedEdge">
            <summary>
            A <c>DirectedEdge</c> of a <c>PolygonizeGraph</c>, which represents
            an edge of a polygon formed by the graph.
            May be logically deleted from the graph by setting the <c>marked</c> flag.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeDirectedEdge.#ctor(MapWinGeoProc.NTS.Topology.Planargraph.Node,MapWinGeoProc.NTS.Topology.Planargraph.Node,MapWindow.Interfaces.Geometries.ICoordinate,System.Boolean)">
            <summary>
            Constructs a directed edge connecting the <c>from</c> node to the
            <c>to</c> node.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <param name="directionPt">
            Specifies this DirectedEdge's direction (given by an imaginary
            line from the <c>from</c> node to <c>directionPt</c>).
            </param>
            <param name="edgeDirection">
            Whether this DirectedEdge's direction is the same as or
            opposite to that of the parent Edge (if any).
            </param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeDirectedEdge.Label">
            <summary> 
            Returns the identifier attached to this directed edge.
            Attaches an identifier to this directed edge.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeDirectedEdge.Next">
            <summary>
            Returns the next directed edge in the EdgeRing that this directed edge is a member of.
            Sets the next directed edge in the EdgeRing that this directed edge is a member of.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeDirectedEdge.IsInRing">
            <summary>
            Returns the ring of directed edges that this directed edge is
            a member of, or null if the ring has not been set.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Operation.Polygonize.PolygonizeDirectedEdge.Ring">
            <summary> 
            Gets/Sets the ring of directed edges that this directed edge is
            a member of.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Operation.Overlay.MinimalEdgeRing">
            <summary>
            A ring of edges with the property that no node
            has degree greater than 2.  These are the form of rings required
            to represent polygons under the OGC SFS spatial data model.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.MinimalEdgeRing.#ctor(MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge,MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            
            </summary>
            <param name="start"></param>
            <param name="geometryFactory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.MinimalEdgeRing.GetNext(MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge)">
            <summary>
            
            </summary>
            <param name="de"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Operation.Overlay.MinimalEdgeRing.SetEdgeRing(MapWinGeoProc.NTS.Topology.GeometriesGraph.DirectedEdge,MapWinGeoProc.NTS.Topology.GeometriesGraph.EdgeRing)">
            <summary>
            
            </summary>
            <param name="de"></param>
            <param name="er"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexSnapRounder">
            <summary>
            Uses Snap Rounding to compute a rounded,
            fully noded arrangement from a set of {@link SegmentString}s.
            Implements the Snap Rounding technique described in Hobby, Guibas and Marimont, and Goodrich et al.
            Snap Rounding assumes that all vertices lie on a uniform grid
            (hence the precision model of the input must be fixed precision,
            and all the input vertices must be rounded to that precision).
            <para>
            This implementation uses a monotone chains and a spatial index to
            speed up the intersection tests.
            This implementation appears to be fully robust using an integer precision model.
            It will function with non-integer precision models, but the
            results are not 100% guaranteed to be correctly noded.
            </para>
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexSnapRounder.#ctor(MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel)">
            <summary>
            Initializes a new instance of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexSnapRounder"/> class.
            </summary>
            <param name="pm">The <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel"/> to use.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexSnapRounder.GetNodedSubstrings">
            <summary>
            Returns a <see cref="T:System.Collections.IList"/> of fully noded <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s.
            The <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s have the same context as their parent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexSnapRounder.ComputeNodes(System.Collections.IList)">
            <summary>
            Computes the noding for a collection of <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s.
            Some Noders may add all these nodes to the input <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s;
            others may only add some or none at all.
            </summary>
            <param name="inputSegmentStrings"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexSnapRounder.CheckCorrectness(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="inputSegmentStrings"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexSnapRounder.SnapRound(System.Collections.IList,MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector)">
            <summary>
            
            </summary>
            <param name="segStrings"></param>
            <param name="li"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexSnapRounder.FindInteriorIntersections(System.Collections.IList,MapWinGeoProc.NTS.Topology.Algorithm.LineIntersector)">
             <summary>
             Computes all interior intersections in the collection of <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s,
             and returns their <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/>s.
            
             Does NOT node the segStrings.
             </summary>
             <param name="segStrings"></param>
             <param name="li"></param>
             <returns>A list of Coordinates for the intersections.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexSnapRounder.ComputeIntersectionSnaps(System.Collections.IList)">
            <summary>
            Computes nodes introduced as a result of snapping segments to snap points (hot pixels).
            </summary>
            <param name="snapPts"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexSnapRounder.ComputeVertexSnaps(System.Collections.IList)">
            <summary>
            Computes nodes introduced as a result of
            snapping segments to vertices of other segments.
            </summary>
            <param name="edges"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.Snapround.MCIndexSnapRounder.ComputeVertexSnaps(MapWinGeoProc.NTS.Topology.Noding.SegmentString)">
            <summary>
            Performs a brute-force comparison of every segment in each <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>.
            This has n^2 performance.
            </summary>
            <param name="e"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Noding.SegmentNode">
            <summary>
            Represents an intersection point between two <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentString"/>s.
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Noding.SegmentNode.Coordinate">
            <summary>
            
            </summary>
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Noding.SegmentNode.SegmentIndex">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentNode.#ctor(MapWinGeoProc.NTS.Topology.Noding.SegmentString,MapWindow.Interfaces.Geometries.ICoordinate,System.Int32,MapWinGeoProc.NTS.Topology.Noding.Octants)">
            <summary>
            Initializes a new instance of the <see cref="T:MapWinGeoProc.NTS.Topology.Noding.SegmentNode"/> class.
            </summary>
            <param name="segString"></param>
            <param name="coord"></param>
            <param name="segmentIndex"></param>
            <param name="segmentOctant"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentNode.IsEndPoint(System.Int32)">
            <summary>
            
            </summary>
            <param name="maxSegmentIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentNode.CompareTo(System.Object)">
            <summary>
            </summary>
            <param name="obj"></param>
            <returns>
            -1 this SegmentNode is located before the argument location, or
             0 this SegmentNode is at the argument location, or
             1 this SegmentNode is located after the argument location.   
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Noding.SegmentNode.Write(System.IO.StreamWriter)">
            <summary>
            
            </summary>
            <param name="outstream"></param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Noding.SegmentNode.IsInterior">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator">
            <summary>
            An iterator over the components and coordinates of a linear geometry
            (<see cref="T:MapWinGeoProc.NTS.Topology.Geometries.LineString"/>s and <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.MultiLineString"/>s.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.SegmentEndVertexIndex(MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation)">
            <summary>
            
            </summary>
            <param name="loc"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.#ctor(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary>
            Creates an iterator initialized to the start of a linear <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>.
            </summary>
            <param name="linear">The linear geometry to iterate over.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.#ctor(MapWindow.Interfaces.Geometries.IGeometry,MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation)">
            <summary>
            Creates an iterator starting at a <see cref="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearLocation"/> on a linear <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>.
            </summary>
            <param name="linear">The linear geometry to iterate over.</param>
            <param name="start">The location to start at.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.#ctor(MapWindow.Interfaces.Geometries.IGeometry,System.Int32,System.Int32)">
            <summary>
            Creates an iterator starting at
            a component and vertex in a linear <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>.
            </summary>
            <param name="linear">The linear geometry to iterate over.</param>
            <param name="componentIndex">The component to start at.</param>
            <param name="vertexIndex">The vertex to start at.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.LoadCurrentLine">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.HasNext">
            <summary>
            Evaluate if the iterator could step over.
            Does not perform the step at all.
            </summary>
            <returns></returns>
            <returns><c>true</c> if there are more vertices to scan.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.Next">
            <summary>
            Jump to the next element of the iteration.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.MoveNext">
            <summary>
            Tests whether there are any vertices left to iterator over.
            If <c>true</c>, then moves the iterator ahead to the next vertex and (possibly) linear component,
            so that <see cref="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.Current"/> exposes the elements.
            </summary>
            <returns><c>true</c> if there are more vertices to scan.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.Reset">
            <summary>
            Sets the enumerator to its initial position, 
            which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            The collection was modified after the enumerator was created. 
            </exception>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, 
            releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.Dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="dispose"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"></see> that can be used 
            to iterate through the collection.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator (of <see cref="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.LinearElement"/>elements) 
            that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"></see> object 
            that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.IsEndOfLine">
            <summary>
            Checks whether the iterator cursor is pointing to the
            endpoint of a linestring.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.ComponentIndex">
            <summary>
            The component index of the vertex the iterator is currently at.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.VertexIndex">
            <summary>
            The vertex index of the vertex the iterator is currently at.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.Line">
            <summary>
            Gets the <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.LineString"/> component the iterator is current at.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.SegmentStart">
            <summary>
            Gets the first <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> of the current segment
            (the coordinate of the current vertex).
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.SegmentEnd">
            <summary>
            Gets the second <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> of the current segment
            (the coordinate of the next vertex).
            If the iterator is at the end of a line, <c>null</c> is returned.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.Current">
            <summary>
            Gets the <see cref="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.LinearElement">element</see> in the collection 
            at the current position of the enumerator.
            </summary>
            <value></value>
            <returns>
            The <see cref="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.LinearElement">element</see> in the collection 
            at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the <see cref="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.LinearElement">element</see> in the collection 
            at the current position of the enumerator.
            </summary>
            <value></value>
            <returns>
            The <see cref="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.LinearElement">element</see> in the collection 
            at the current position of the enumerator.
            </returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.LinearElement">
            <summary>
            A class that exposes <see cref="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator"/> elements.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.LinearElement.#ctor(MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator)">
            <summary>
            Initializes a new instance of the <see cref="T:LinearElement"/> class.
            </summary>
            <param name="iterator">The iterator.</param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.LinearElement.ComponentIndex">
            <summary>
            The component index of the vertex the iterator is currently at.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.LinearElement.VertexIndex">
            <summary>
            The vertex index of the vertex the iterator is currently at.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.LinearElement.Line">
            <summary>
            Gets the <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.LineString"/> component the iterator is current at.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.LinearElement.IsEndOfLine">
            <summary>
            Checks whether the iterator cursor is pointing to the
            endpoint of a linestring.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.LinearElement.SegmentStart">
            <summary>
            Gets the first <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> of the current segment
            (the coordinate of the current vertex).
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.LinearReferencing.LinearIterator.LinearElement.SegmentEnd">
            <summary>
            Gets the second <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> of the current segment
            (the coordinate of the next vertex).
            If the iterator is at the end of a line, <c>null</c> is returned.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexOfPoint">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexOfPoint.IndexOf(MapWinGeoProc.NTS.Topology.Geometries.Geometry,MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            
            </summary>
            <param name="linearGeom"></param>
            <param name="inputPt"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexOfPoint.IndexOfAfter(MapWinGeoProc.NTS.Topology.Geometries.Geometry,MapWinGeoProc.NTS.Topology.Geometries.Coordinate,System.Double)">
            <summary>
            
            </summary>
            <param name="linearGeom"></param>
            <param name="inputPt"></param>
            <param name="minIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexOfPoint.#ctor(MapWinGeoProc.NTS.Topology.Geometries.Geometry)">
            <summary>
            Initializes a new instance of the <see cref="T:LengthIndexOfPoint"/> class.
            </summary>
            <param name="linearGeom">A linear geometry.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexOfPoint.IndexOf(MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            Find the nearest location along a linear {@link Geometry} to a given point.
            </summary>
            <param name="inputPt">The coordinate to locate.</param>
            <returns>The location of the nearest point.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexOfPoint.IndexOfAfter(MapWinGeoProc.NTS.Topology.Geometries.Coordinate,System.Double)">
            <summary>
            Finds the nearest index along the linear <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/>
            to a given <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate"/> after the specified minimum index.
            If possible the location returned will be strictly 
            greater than the <paramref name="minIndex"/>.
            If this is not possible, the value returned 
            will equal <paramref name="minIndex"/>.
            (An example where this is not possible is when
            <paramref name="minIndex"/> = [end of line] ).
            </summary>
            <param name="inputPt">The coordinate to locate.</param>
            <param name="minIndex">The minimum location for the point location.</param>
            <returns>The location of the nearest point.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexOfPoint.IndexOfFromStart(MapWinGeoProc.NTS.Topology.Geometries.Coordinate,System.Double)">
            <summary>
            
            </summary>
            <param name="inputPt"></param>
            <param name="minIndex"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.LinearReferencing.LengthIndexOfPoint.SegmentNearestMeasure(MapWinGeoProc.NTS.Topology.Geometries.LineSegment,MapWinGeoProc.NTS.Topology.Geometries.Coordinate,System.Double)">
            <summary>
            
            </summary>
            <param name="seg"></param>
            <param name="inputPt"></param>
            <param name="segmentStartMeasure"></param>
            <returns></returns>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.WKBReader">
            <summary>
            Converts a Well-Known Binary byte data to a <c>Geometry</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBReader.#ctor">
            <summary>
            Initialize reader with a standard <c>GeometryFactory</c>. 
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBReader.#ctor(MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory)">
            <summary>
            Initialize reader with the given <c>GeometryFactory</c>.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBReader.Read(System.Byte[])">
            <summary>
            
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBReader.Read(System.IO.Stream)">
            <summary>
            
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBReader.Read(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBReader.ReadByteOrder(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBReader.ReadCoordinate(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBReader.ReadRing(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBReader.ReadPoint(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBReader.ReadLineString(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBReader.ReadPolygon(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBReader.ReadMultiPoint(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBReader.ReadMultiLineString(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBReader.ReadMultiPolygon(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.WKBReader.ReadGeometryCollection(System.IO.BinaryReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.WKBReader.Factory">
            <summary>
            <c>Geometry</c> builder.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.IO.ColumnStructure">
            <summary>
            This class is used in conjunction with RowStructure. 
            </summary>
            <remarks>
            For an explaination of PropertyDescriptor see http://www.devx.com/dotnet/Article/7874
            and the remarks for RowStructure. This class inherits from PropertyDescriptor. 
            The PropertyDescriptor describes a property - in this case a dynamically generated property.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ColumnStructure.#ctor(MapWinGeoProc.NTS.Topology.IO.DbaseFieldDescriptor,System.Int32)">
            <summary>
            Initializes a new instance of the ColumnStructure class.
            </summary>
            <param name="dbaseField"></param>
            <param name="index"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ColumnStructure.CanResetValue(System.Object)">
            <summary>
            
            </summary>
            <param name="component"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ColumnStructure.ResetValue(System.Object)">
            <summary>
            
            </summary>
            <param name="component"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ColumnStructure.ShouldSerializeValue(System.Object)">
            <summary>
            
            </summary>
            <param name="component"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ColumnStructure.SetValue(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="component"></param>
            <param name="value"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.IO.ColumnStructure.GetValue(System.Object)">
            <summary>
            
            </summary>
            <param name="component"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ColumnStructure.ComponentType">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ColumnStructure.PropertyType">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ColumnStructure.IsReadOnly">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.IO.ColumnStructure.Length">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.MultiLineString">
            <summary>
            Basic implementation of <c>MultiLineString</c>.
            </summary>    
        </member>
        <member name="F:MapWinGeoProc.NTS.Topology.Geometries.MultiLineString.Empty">
            <summary>
            Represents an empty <c>MultiLineString</c>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.MultiLineString.#ctor(MapWindow.Interfaces.Geometries.ILineStringBase[],MapWindow.Interfaces.Geometries.IGeometryFactory)">
            <summary>
            Constructs a <c>MultiLineString</c>.
            </summary>
            <param name="lineStrings">
            The <c>LineString</c>s for this <c>MultiLineString</c>,
            or <c>null</c> or an empty array to create the empty
            point. Elements may be empty <c>LineString</c>s,
            but not <c>null</c>s.
            </param>
            <param name="factory"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.MultiLineString.#ctor(MapWindow.Interfaces.Geometries.ILineStringBase[])">
            <summary>
            Constructs a <c>MultiLineString</c>.
            </summary>
            <param name="lineStrings">
            The <c>LineString</c>s for this <c>MultiLineString</c>,
            or <c>null</c> or an empty array to create the empty
            point. Elements may be empty <c>LineString</c>s,
            but not <c>null</c>s.
            </param>
            <remarks>
            For create this <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.Geometry"/> is used a standard <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.GeometryFactory"/> 
            with <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.PrecisionModel"/> <c> == </c> <see cref="F:MapWindow.Interfaces.Geometries.PrecisionModels.Floating"/>.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.MultiLineString.Reverse">
            <summary>
            Creates a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.MultiLineString"/> in the reverse order to this object.
            Both the order of the component LineStrings
            and the order of their coordinate sequences are reversed.
            </summary>
            <returns>a <see cref="T:MapWinGeoProc.NTS.Topology.Geometries.MultiLineString"/> in the reverse order.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.MultiLineString.EqualsExact(MapWindow.Interfaces.Geometries.IGeometry,System.Double)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <param name="tolerance"></param>
            <returns></returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.MultiLineString.Dimension">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.MultiLineString.BoundaryDimension">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.MultiLineString.GeometryType">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.MultiLineString.IsClosed">
            <summary>
            Gets a value indicating whether this instance is closed.
            </summary>
            <value><c>true</c> if this instance is closed; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.MultiLineString.IsSimple">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.MultiLineString.Boundary">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.CoordinateSequences">
            <summary>
            Utility functions for manipulating <see cref="T:MapWindow.Interfaces.Geometries.ICoordinateSequence"/>s.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateSequences.Reverse(MapWindow.Interfaces.Geometries.ICoordinateSequence)">
            <summary>
            Reverses the coordinates in a sequence in-place.
            </summary>
            <param name="seq"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateSequences.Swap(MapWindow.Interfaces.Geometries.ICoordinateSequence,System.Int32,System.Int32)">
            <summary>
            Swaps two coordinates in a sequence.
            </summary>
            <param name="seq"></param>
            <param name="i"></param>
            <param name="j"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.CoordinateList">
            <summary>
            A list of Coordinates, which may
            be set to prevent repeated coordinates from occuring in the list.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateList.#ctor">
            <summary>
            Constructs a new list without any coordinates
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateList.#ctor(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[])">
            <summary>
            The basic constructor for a CoordinateArray allows repeated points
            (i.e produces a CoordinateList with exactly the same set of points).
            </summary>
            <param name="coord">Initial coordinates</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateList.#ctor(System.Collections.IList)">
            <summary>
            Constructs a new list from a collection of Coordinates,
            allows repeated points.
            </summary>
            <param name="coordList">Collection of coordinates to load into the list.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateList.#ctor(System.Collections.IList,System.Boolean)">
            <summary>
            Constructs a new list from a collection of Coordinates,
            allowing caller to specify if repeated points are to be removed.
            </summary>
            <param name="coordList">Collection of coordinates to load into the list.</param>
            <param name="allowRepeated">If <c>false</c>, repeated points are removed.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateList.#ctor(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[],System.Boolean)">
            <summary>
            Constructs a new list from an array of Coordinates,
            allowing caller to specify if repeated points are to be removed.
            </summary>
            <param name="coord">Array of coordinates to load into the list.</param>
            <param name="allowRepeated">If <c>false</c>, repeated points are removed.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateList.GetCoordinate(System.Int32)">
            <summary>
            Returns the coordinate at specified index.
            </summary>
            <param name="i">Coordinate index.</param>
            <return>Coordinate specified.</return>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateList.Add(MapWindow.Interfaces.Geometries.ICoordinate[],System.Boolean,System.Boolean)">
            <summary>
            Add an array of coordinates.
            </summary>
            <param name="coord">Coordinates to be inserted.</param>
            <param name="allowRepeated">If set to false, repeated coordinates are collapsed.</param>
            <param name="direction">If false, the array is added in reverse order.</param>
            <returns>Return true.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateList.Add(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[],System.Boolean)">
            <summary>
            Add an array of coordinates.
            </summary>
            <param name="coord">Coordinates to be inserted.</param>
            <param name="allowRepeated">If set to false, repeated coordinates are collapsed.</param>
            <returns>Return true.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateList.Add(System.Object,System.Boolean)">
            <summary>
            Add a coordinate.
            </summary>
            <param name="obj">Coordinate to be inserted, as object.</param>
            <param name="allowRepeated">If set to false, repeated coordinates are collapsed.</param>
            <returns>Return true.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateList.Add(MapWinGeoProc.NTS.Topology.Geometries.Coordinate,System.Boolean)">
            <summary>
            Add a coordinate.
            </summary>
            <param name="coord">Coordinate to be inserted.</param>
            <param name="allowRepeated">If set to false, repeated coordinates are collapsed.</param>
            <returns>Return true if all ok.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateList.AddAll(System.Collections.IList,System.Boolean)">
            <summary>
            Add an array of coordinates.
            </summary>
            <param name="coll">Coordinates collection to be inserted.</param>
            <param name="allowRepeated">If set to false, repeated coordinates are collapsed.</param>
            <returns>Return true if at least one element has added (IList not empty).</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateList.CloseRing">
            <summary>
            Ensure this coordList is a ring, by adding the start point if necessary.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateList.ToCoordinateArray">
            <summary>
            Returns the Coordinates in this collection.
            </summary>
            <returns>Coordinater as <c>Coordinate[]</c> array.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.CoordinateList.Clone">
            <summary>
            Returns a deep copy of this collection.
            </summary>
            <returns>The copied object.</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.CoordinateList.Count">
            <summary>
            Returns the number of elements in CoordinateList collection.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.CoordinateList.Item(System.Int32)">
            <summary>
            Returns the coordinate at specified index.
            </summary>
            <param name="i">Coordinate index.</param>
            <return>Coordinate specified.</return>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Geometries.Coordinate">
            <summary>
            A lightweight class used to store coordinates
            on the 2-dimensional Cartesian plane.
            It is distinct from <c>Point</c>, which is a subclass of <c>Geometry</c>.
            Unlike objects of type <c>Point</c> (which contain additional
            information such as an envelope, a precision model, and spatial reference
            system information), a <c>Coordinate</c> only contains ordinate values
            and accessor methods.
            <c>Coordinate</c>s are two-dimensional points, with an additional
            z-ordinate. NTS does not support any operations on the z-ordinate except
            the basic accessor functions. Constructed coordinates will have a
            z-ordinate of <c>NaN</c>.  The standard comparison functions will ignore
            the z-ordinate.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Constructs a <c>Coordinate</c> at (x,y,z).
            </summary>
            <param name="x">X value.</param>
            <param name="y">Y value.</param>
            <param name="z">Z value.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.#ctor(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Creates a Coordinate from any ICoordinate Interface
            </summary>
            <param name="Icoord">The Vector.IPoint interface to construct a coordinate from</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.#ctor">
            <summary>
             Constructs a <c>Coordinate</c> at (0,0,NaN).
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.#ctor(System.Double,System.Double)">
            <summary>
            Constructs a <c>Coordinate</c> at (x,y,NaN).
            </summary>
            <param name="x">X value.</param>
            <param name="y">Y value.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.Equals2D(MapWindow.Interfaces.Geometries.ICoordinate)">
             <summary>
             Returns whether the planar projections of the two <i>Coordinate</i>s are equal.
            </summary>
             <param name="other"><i>ICoordinate</i> with which to do the 2D comparison.</param>
             <returns>
             <c>true</c> if the x- and y-coordinates are equal;
             the Z coordinates do not have to be equal.
             </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.Equals(System.Object)">
            <summary>
            Returns <c>true</c> if <c>other</c> has the same values for the x and y ordinates.
            Since Coordinates are 2.5D, this routine ignores the z value when making the comparison.
            </summary>
            <param name="other"><c>Coordinate</c> with which to do the comparison.</param>
            <returns><c>true</c> if <c>other</c> is a <c>Coordinate</c> with the same values for the x and y ordinates.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.op_Equality(MapWinGeoProc.NTS.Topology.Geometries.Coordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="obj1"></param>
            <param name="obj2"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.op_Inequality(MapWinGeoProc.NTS.Topology.Geometries.Coordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            
            </summary>
            <param name="obj1"></param>
            <param name="obj2"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.CompareTo(System.Object)">
            <summary>
            Compares this object with the specified object for order.
            Since Coordinates are 2.5D, this routine ignores the z value when making the comparison.
            Returns
               -1 : this.x lowerthan other.x || ((this.x == other.x) AND (this.y lowerthan other.y))
               0  : this.x == other.x AND this.y = other.y 
               1  : this.x greaterthan other.x || ((this.x == other.x) AND (this.y greaterthan other.y)) 
            </summary>
            <param name="o"><c>Coordinate</c> with which this <c>Coordinate</c> is being compared.</param>
            <returns>
            A negative integer, zero, or a positive integer as this <c>Coordinate</c>
                    is less than, equal to, or greater than the specified <c>Coordinate</c>.
            </returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.Equals3D(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Returns true if other has the same values for x, y and z.
            </summary>
            <param name="other"><i>ICoordinate</i> with which to do the 3D comparison.</param>
            <returns><c>true</c> if <c>other</c> is a <c>ICoordinate</c> with the same values for x, y and z.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.ToString">
            <summary>
            Returns a <c>string</c> of the form <I>(x,y,z)</I> .
            </summary>
            <returns><c>string</c> of the form <I>(x,y,z)</I></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.Clone">
            <summary>
            Create a new object as copy of this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.Distance(MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Returns Euclidean 2D distance from ICoordinate p.
            </summary>
            <param name="p"><i>ICoordinate</i> with which to do the distance comparison.</param>
            <returns>Double, the distance between the two locations.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.GetHashCode">
            <summary>
            Return HashCode.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.GetHashCode(System.Double)">
            <summary>
            Return HashCode.
            </summary>
            <param name="x">Value from HashCode computation.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.op_Addition(MapWinGeoProc.NTS.Topology.Geometries.Coordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Overloaded + operator.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.op_Addition(MapWinGeoProc.NTS.Topology.Geometries.Coordinate,System.Double)">
            <summary>
            Overloaded + operator.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.op_Addition(System.Double,MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            Overloaded + operator.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.op_Multiply(MapWinGeoProc.NTS.Topology.Geometries.Coordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Overloaded * operator.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.op_Multiply(MapWinGeoProc.NTS.Topology.Geometries.Coordinate,System.Double)">
            <summary>
            Overloaded * operator.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.op_Multiply(System.Double,MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            Overloaded * operator.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.op_Subtraction(MapWinGeoProc.NTS.Topology.Geometries.Coordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Overloaded - operator.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.op_Subtraction(MapWinGeoProc.NTS.Topology.Geometries.Coordinate,System.Double)">
            <summary>
            Overloaded - operator.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.op_Subtraction(System.Double,MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            Overloaded - operator.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.op_Division(MapWinGeoProc.NTS.Topology.Geometries.Coordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Overloaded / operator.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.op_Division(MapWinGeoProc.NTS.Topology.Geometries.Coordinate,System.Double)">
            <summary>
            Overloaded / operator.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.op_Division(System.Double,MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            Overloaded / operator.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.X">
            <summary>
            X coordinate.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.Y">
            <summary>
            Y coordinate.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.Z">
            <summary>
            Z coordinate.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Geometries.Coordinate.CoordinateValue">
            <summary>
            Gets/Sets <c>Coordinate</c>s (x,y,z) values.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.CoordinateTransformationAuthorityFactory">
            <summary>
            Creates coordinate transformation objects from codes. The codes are maintained by an external authority. A commonly used authority is EPSG, which is also used in the GeoTIFF standard
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.CoordinateTransformation">
            <summary>
            Describes a coordinate transformation. This class only describes a 
            coordinate transformation, it does not actually perform the transform 
            operation on points. To transform points you must use a <see cref="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.CoordinateTransformation.MathTransform"/>.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.CoordinateTransformation.#ctor(MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystem,MapWinGeoProc.NTS.Topology.CoordinateSystems.ICoordinateSystem,MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.TransformType,MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.IMathTransform,System.String,System.String,System.Int64,System.String,System.String)">
            <summary>
            Initializes an instance of a CoordinateTransformation
            </summary>
            <param name="sourceCS">Source coordinate system</param>
            <param name="targetCS">Target coordinate system</param>
            <param name="transformType">Transformation type</param>
            <param name="mathTransform">Math transform</param>
            <param name="name">Name of transform</param>
            <param name="authority">Authority</param>
            <param name="authorityCode">Authority code</param>
            <param name="areaOfUse">Area of use</param>
            <param name="remarks">Remarks</param>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.CoordinateTransformation.AreaOfUse">
            <summary>
            Human readable description of domain in source coordinate system.
            </summary>		
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.CoordinateTransformation.Authority">
            <summary>
            Authority which defined transformation and parameter values.
            </summary>
            <remarks>
            An Authority is an organization that maintains definitions of Authority Codes. For example the European Petroleum Survey Group (EPSG) maintains a database of coordinate systems, and other spatial referencing objects, where each object has a code number ID. For example, the EPSG code for a WGS84 Lat/Lon coordinate system is ‘4326’
            </remarks>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.CoordinateTransformation.AuthorityCode">
            <summary>
            Code used by authority to identify transformation. An empty string is used for no code.
            </summary>
            <remarks>The AuthorityCode is a compact string defined by an Authority to reference a particular spatial reference object. For example, the European Survey Group (EPSG) authority uses 32 bit integers to reference coordinate systems, so all their code strings will consist of a few digits. The EPSG code for WGS84 Lat/Lon is ‘4326’.</remarks>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.CoordinateTransformation.MathTransform">
            <summary>
            Gets math transform.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.CoordinateTransformation.Name">
            <summary>
            Name of transformation.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.CoordinateTransformation.Remarks">
            <summary>
            Gets the provider-supplied remarks.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.CoordinateTransformation.SourceCS">
            <summary>
            Source coordinate system.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.CoordinateTransformation.TargetCS">
            <summary>
            Target coordinate system.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.CoordinateTransformation.TransformType">
            <summary>
            Semantic type of transform. For example, a datum transformation or a coordinate conversion.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.ConcatenatedTransform.Inverse">
            <summary>
            Returns the inverse of this conversion.
            </summary>
            <returns>IMathTransform that is the reverse of the current conversion.</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.Transformations.ConcatenatedTransform.Invert">
            <summary>
            Reverses the transformation
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeographicCoordinateSystem">
            <summary>
            A coordinate system based on latitude and longitude. 
            </summary>
            <remarks>
            Some geographic coordinate systems are Lat/Lon, and some are Lon/Lat. 
            You can find out which this is by examining the axes. You should also 
            check the angular units, since not all geographic coordinate systems 
            use degrees.
            </remarks>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeographicCoordinateSystem.#ctor(MapWinGeoProc.NTS.Topology.CoordinateSystems.IAngularUnit,MapWinGeoProc.NTS.Topology.CoordinateSystems.IHorizontalDatum,MapWinGeoProc.NTS.Topology.CoordinateSystems.IPrimeMeridian,System.Collections.Generic.List{MapWinGeoProc.NTS.Topology.CoordinateSystems.AxisInfo},System.String,System.String,System.Int64,System.String,System.String,System.String)">
            <summary>
            Creates an instance of a Geographic Coordinate System
            </summary>
            <param name="angularUnit">Angular units</param>
            <param name="horizontalDatum">Horizontal datum</param>
            <param name="primeMeridian">Prime meridian</param>
            <param name="axisInfo">Axis info</param>
            <param name="name">Name</param>
            <param name="authority">Authority name</param>
            <param name="authorityCode">Authority-specific identification code.</param>
            <param name="alias">Alias</param>
            <param name="abbreviation">Abbreviation</param>
            <param name="remarks">Provider-supplied remarks</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeographicCoordinateSystem.GetUnits(System.Int32)">
            <summary>
            Gets units for dimension within coordinate system. Each dimension in 
            the coordinate system has corresponding units.
            </summary>
            <param name="dimension">Dimension</param>
            <returns>Unit</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeographicCoordinateSystem.GetWgs84ConversionInfo(System.Int32)">
            <summary>
            Gets details on a conversion to WGS84.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeographicCoordinateSystem.EqualParams(System.Object)">
            <summary>
            Checks whether the values of this instance is equal to the values of another instance.
            Only parameters used for coordinate system are used for comparison.
            Name, abbreviation, authority, alias and remarks are ignored in the comparison.
            </summary>
            <param name="obj"></param>
            <returns>True if equal</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeographicCoordinateSystem.WGS84">
            <summary>
            Creates a decimal degrees geographic coordinate system based on the WGS84 ellipsoid, suitable for GPS measurements
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeographicCoordinateSystem.AngularUnit">
            <summary>
            Gets or sets the angular units of the geographic coordinate system.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeographicCoordinateSystem.PrimeMeridian">
            <summary>
            Gets or sets the prime meridian of the geographic coordinate system.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeographicCoordinateSystem.NumConversionToWGS84">
            <summary>
            Gets the number of available conversions to WGS84 coordinates.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeographicCoordinateSystem.WKT">
            <summary>
            Returns the Well-known text for this object
            as defined in the simple features specification.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeographicCoordinateSystem.XML">
            <summary>
            Gets an XML representation of this object
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeocentricCoordinateSystem">
            <summary>
            A 3D coordinate system, with its origin at the center of the Earth.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeocentricCoordinateSystem.GetUnits(System.Int32)">
            <summary>
            Gets units for dimension within coordinate system. Each dimension in 
            the coordinate system has corresponding units.
            </summary>
            <param name="dimension">Dimension</param>
            <returns>Unit</returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeocentricCoordinateSystem.EqualParams(System.Object)">
            <summary>
            Checks whether the values of this instance is equal to the values of another instance.
            Only parameters used for coordinate system are used for comparison.
            Name, abbreviation, authority, alias and remarks are ignored in the comparison.
            </summary>
            <param name="obj"></param>
            <returns>True if equal</returns>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeocentricCoordinateSystem.WGS84">
            <summary>
            Creates a geocentric coordinate system based on the WGS84 ellipsoid, suitable for GPS measurements
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeocentricCoordinateSystem.HorizontalDatum">
            <summary>
            Returns the HorizontalDatum. The horizontal datum is used to determine where
            the centre of the Earth is considered to be. All coordinate points will be 
            measured from the centre of the Earth, and not the surface.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeocentricCoordinateSystem.LinearUnit">
            <summary>
            Gets the units used along all the axes.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeocentricCoordinateSystem.PrimeMeridian">
            <summary>
            Returns the PrimeMeridian.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeocentricCoordinateSystem.WKT">
            <summary>
            Returns the Well-known text for this object
            as defined in the simple features specification.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.CoordinateSystems.GeocentricCoordinateSystem.XML">
            <summary>
            Gets an XML representation of this object
            </summary>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.SIRtreePointInRing">
            <summary> 
            Implements <c>PointInRing</c> using a <c>SIRtree</c> index to increase performance.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.SIRtreePointInRing.#ctor(MapWinGeoProc.NTS.Topology.Geometries.LinearRing)">
            <summary>
            
            </summary>
            <param name="ring"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.SIRtreePointInRing.BuildIndex">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.SIRtreePointInRing.IsInside(MapWinGeoProc.NTS.Topology.Geometries.Coordinate)">
            <summary>
            
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.SIRtreePointInRing.TestLineSegment(MapWinGeoProc.NTS.Topology.Geometries.Coordinate,MapWinGeoProc.NTS.Topology.Geometries.LineSegment)">
            <summary>
            
            </summary>
            <param name="p"></param>
            <param name="seg"></param>
        </member>
        <member name="T:MapWinGeoProc.NTS.Topology.Algorithm.CentroidArea">
            <summary> 
            Computes the centroid of an area point.
            Algorithm:
            Based on the usual algorithm for calculating
            the centroid as a weighted sum of the centroids
            of a decomposition of the area into (possibly overlapping) triangles.
            The algorithm has been extended to handle holes and multi-polygons.
            See <see href="http://www.faqs.org/faqs/graphics/algorithms-faq"/>
            for further details of the basic approach.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CentroidArea.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CentroidArea.Add(MapWindow.Interfaces.Geometries.IGeometry)">
            <summary> 
            Adds the area defined by a Geometry to the centroid total.
            If the point has no area it does not contribute to the centroid.
            </summary>
            <param name="geom">The point to add.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CentroidArea.Add(MapWinGeoProc.NTS.Topology.Geometries.Coordinate[])">
            <summary> 
            Adds the area defined by an array of
            coordinates.  The array must be a ring;
            i.e. end with the same coordinate as it starts with.
            </summary>
            <param name="ring">An array of Coordinates.</param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CentroidArea.Add(MapWinGeoProc.NTS.Topology.Geometries.Polygon)">
            <summary>
            
            </summary>
            <param name="poly"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CentroidArea.AddShell(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            
            </summary>
            <param name="pts"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CentroidArea.AddHole(MapWindow.Interfaces.Geometries.ICoordinate[])">
            <summary>
            
            </summary>
            <param name="pts"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CentroidArea.AddTriangle(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,System.Boolean)">
            <summary>
            
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="isPositiveArea"></param>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CentroidArea.Centroid3(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate@)">
            <summary> 
            Returns three times the centroid of the triangle p1-p2-p3.
            The factor of 3 is
            left in to permit division to be avoided until later.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.NTS.Topology.Algorithm.CentroidArea.Area2(MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate,MapWindow.Interfaces.Geometries.ICoordinate)">
            <summary>
            Returns twice the signed area of the triangle p1-p2-p3,
            positive if a,b,c are oriented ccw, and negative if cw.
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Algorithm.CentroidArea.Centroid">
            <summary>
            
            </summary>
        </member>
        <member name="P:MapWinGeoProc.NTS.Topology.Algorithm.CentroidArea.BasePoint">
            <summary>
            
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Globals">
            <summary>
            Internal class that provides methods common to several members of MapWinGeoProc.
            </summary>
        </member>
        <member name="M:MapWinGeoProc.Globals.ReverseSimplePoly(MapWinGIS.Shape@)">
            <summary>
            Reverses the orientation of a single-part polgyon.
            </summary>
            <param name="polygon">Single-part polygon.</param>
        </member>
        <member name="M:MapWinGeoProc.Globals.FixMultiPartPoly(MapWinGIS.Shape@)">
            <summary>
            Determines which shapes are holes and which shapes are islands in
            a multi-part polygon and fixes their orientations accordingly.
            </summary>
            <param name="polygon">The multi-part polygon whose parts need to be checked.</param>
        </member>
        <member name="M:MapWinGeoProc.Globals.CombineParts(MapWinGIS.Shape[]@,MapWinGIS.Shape@)">
            <summary>
            Takes an array of simple polygons and combines them into one multi-part shape.
            </summary>
            <param name="parts">The array of polygons.</param>
            <param name="resultShp">The resulting multi-part shape.</param>
        </member>
        <member name="M:MapWinGeoProc.Globals.ExtentsInside(MapWinGIS.Extents,MapWinGIS.Extents)">
            <summary>
            Finds if the testExtents lie completely inside of the 'outerExtents.'
            </summary>
            <param name="outerExtents">The extents belonging to the surrounding shape.</param>
            <param name="testExtents">The extents belonging to the inner shape.</param>
            <returns>True if the test extents are completely inside of the outer extents, false otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Globals.SeparateParts(MapWinGIS.Shape@,MapWinGIS.Shape[]@)">
            <summary>
            Separates all parts of a multi-part polygon.
            </summary>
            <param name="poly">The mulit-part polygon to be separated.</param>
            <param name="polyParts">The array that will hold each separated polygon part.</param>
        </member>
        <member name="M:MapWinGeoProc.Globals.ConvertPolyToVertexArray(MapWinGIS.Shape@,MapWinGeoProc.Globals.Vertex[][]@)">
            <summary>
            Takes a MapWinGIS polygon shape and stores all x/y coordinates into a vertex array.
            </summary>
            <param name="poly">The polygon to be converted.</param>
            <param name="polyVertArray">The array[numParts][] that will contain the polygon vertices.</param>
        </member>
        <member name="M:MapWinGeoProc.Globals.PrepareResultSF(System.String@,MapWinGIS.Shapefile@,MapWinGIS.ShpfileType)">
            <summary>
            Deletes any file located at resultSFPath and creates a new one (resultSF).
            </summary>
            <param name="resultSFPath">Full path to where the result file should be saved.</param>
            <param name="resultSF">The result shapefile.</param>
            <param name="sfType">The MapWinGIS shapefile type.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Globals.PrepareResultSF(System.String@,MapWinGIS.Shapefile@,MapWinGIS.ShpfileType,System.Boolean)">
            <summary>
            Deletes any file located at resultSFPath and creates a new one (resultSF).
            </summary>
            <param name="resultSFPath">Full path to where the result file should be saved.</param>
            <param name="resultSF">The result shapefile.</param>
            <param name="sfType">The MapWinGIS shapefile type.</param>
            <param name="SkipMWShapeIDField">Do not create the MWShapeID field.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Globals.CheckBounds(MapWinGIS.Shape@,MapWinGIS.Shape@)">
            <summary>
            Checks if two shape boundaries overlap.
            </summary>
            <param name="shp1">First shape.</param>
            <param name="shp2">Second shape.</param>
            <returns>True if the boundaries overlap, false otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Globals.CheckBounds(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Checks if two shape boundaries overlap.
            </summary>
            <param name="xMin1">Minimum x-value for bounding box 1.</param>
            <param name="xMax1">Maximum x-value for bounding box 1.</param>
            <param name="yMin1">Minimum y-value for bounding box 1.</param>
            <param name="yMax1">Maximum y-value for bounding box 1.</param>
            <param name="xMin2">Minimum x-value for bounding box 2.</param>
            <param name="xMax2">Maximum x-value for bounding box 2.</param>
            <param name="yMin2">Minimum y-value for bounding box 2.</param>
            <param name="yMax2">Maximum y-value for bounding box 2.</param>
            <returns></returns>
        </member>
        <member name="M:MapWinGeoProc.Globals.SimpleIntersect(MapWinGeoProc.Globals.Line,MapWinGeoProc.Globals.Line,MapWinGIS.Point@)">
            <summary>
            Finds if two INFINITE lines will intersect, and if so, computes the intersect point.
            </summary>
            <param name="line1">The first infinite line</param>
            <param name="line2">The second infinite line</param>
            <param name="intersectPoint">The point of intersection</param>
            <returns>True if one intersect point exists, false otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Globals.LinesIntersect2D(MapWinGeoProc.Globals.Line,System.Boolean,MapWinGeoProc.Globals.Line,System.Boolean,MapWinGIS.Point@)">
            <summary>
            Calculates the intersection point between two lines.
            </summary>
            <param name="S1">First line segment.</param>
            <param name="S1_isRay">True if line 1 is a ray, false if it's a finite segment.</param>
            <param name="S2">Second line segment.</param>
            <param name="S2_isRay">True if line 2 is a ray, false if it's a finite segment.</param>
            <param name="intersectPoint">The intersection point between segments 1 and 2.</param>
            <returns>True if a valid intersect point exists, false if the lines do not cross.</returns>
        </member>
        <member name="M:MapWinGeoProc.Globals.PerpProduct(MapWinGIS.Vector,MapWinGIS.Vector)">
            <summary>
            Computes the perpendicular product of two 2D vectors.
            </summary>
            <param name="v1">vector 1</param>
            <param name="v2">vector 2</param>
            <returns>Perpedicular product; if == 0, v1 and v2 are parallel.</returns>
        </member>
        <member name="M:MapWinGeoProc.Globals.CalcSiDeterm(MapWinGIS.Shapefile@,MapWinGIS.Shape@,System.Int32[]@,MapWinGIS.Point[][]@,System.Int32[][]@)">
            <summary>
            Calculates the determinants for line segments with a polygon
            to see if any intersections will occur. -- Angela Hillier 10/05
            </summary>
            <param name="lineSF">A line shapefile of 2pt segments.</param>
            <param name="polygon">The polygon to test for intersections with.</param>
            <param name="intersectsPerLineSeg">Out parameter: an array of numbers representing how many
            intersections will occur for each line segment.</param>
            <param name="intersectionPts">Out parameter: an array of points, if the point is != (0,0) then
            it represents a valid intersection point at the corresponding location in the polygon.</param>
            <param name="polyIntersectLocs">Out paramter: an array of indicies corresponding to where in the polygon
            an intersection point is found.</param>
            <returns>The total number of intersections found for the line shapefile.</returns>
        </member>
        <member name="M:MapWinGeoProc.Globals.TurboDeterm(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            http://www.codeproject.com/cpp/2dpolyclip.asp
             <summary>
             Calculates the determinant of a 3X3 matrix, where the first two rows
             represent the x,y values of two lines, and the third row is (1 1 1).
             </summary>
             <param name="Elem11">The first element of the first row in the matrix.</param>
             <param name="Elem12">The second element of the first row in the matrix.</param>
             <param name="Elem13">The third element of the first row in the matrix.</param>
             <param name="Elem21">The first element of the second row in the matrix.</param>
             <param name="Elem22">The second element of the second row in the matrix.</param>
             <param name="Elem23">The third element of the second row in the matrix.</param>
             <returns>The determinant of the matrix.</returns>
        </member>
        <member name="M:MapWinGeoProc.Globals.SortPointsArray(MapWinGIS.Point@,MapWinGIS.Point[]@)">
            <summary>
            Given a reference point to the line, and an array of points that
            lie along the line, this method sorts the array of points from the point
            closest to the reference pt to the pt farthest away.
            </summary>
            <param name="startPt">Point in line segment used as reference.</param>
            <param name="intersectPts">Array of points that lie on the same line as startPt.</param>
        </member>
        <member name="M:MapWinGeoProc.Globals.SortIntersectAndLocationArrays(MapWinGIS.Point@,MapWinGIS.Point[]@,System.Int32[]@)">
            <summary>
            Given a reference point to the line, and an array of points that
            lie along the line, this method sorts the array of points from the point
            closest to the reference pt to the pt farthest away. It also sorts the corresponding
            polygon location array so that the indicies refer to the correct intersection point.
            </summary>
            <param name="startPt">Point in line segment used as reference.</param>
            <param name="intersectPts">Array of points that lie on the same line as startPt.</param>
            <param name="polyLoc">Array indexing where in polygon an intersect occurs.</param>
        </member>
        <member name="M:MapWinGeoProc.Globals.FindAndSortValidIntersects(System.Int32,MapWinGIS.Point[]@,MapWinGIS.Point[]@,MapWinGIS.Point@)">
            <summary>
            Sorts all valid intersects in the array intersectPts.
            </summary>
            <param name="numIntersects">Expected number of valid intersects.</param>
            <param name="intersectPts">Array of all possible intersect points.</param>
            <param name="validIntersects">Array that will contain only the valid intersect points in sorted order.</param>
            <param name="startPt">The reference point to sort the valid intersect points by.</param>
        </member>
        <member name="M:MapWinGeoProc.Globals.FindAndSortValidIntersects(System.Int32,MapWinGIS.Point[]@,MapWinGIS.Point[]@,MapWinGIS.Point@,System.Int32[]@)">
            <summary>
            Sorts all valid intersects in the array intersectPts, along with corresponding polygon locations in array polyLoc.
            </summary>
            <param name="numIntersects">Expected number of valid intersects.</param>
            <param name="intersectPts">Array of all possible intersect points.</param>
            <param name="validIntersects">Array that will contain only the valid intersect points in sorted order.</param>
            <param name="startPt">The reference point to sort the valid intersect points by.</param>
            <param name="polyLoc">Array with corresponding indicies to where an intersect pt occurs in polygon.</param>
        </member>
        <member name="M:MapWinGeoProc.Globals.PtDistance(MapWinGIS.Point@,MapWinGIS.Point@)">
            <summary>
            Calculates the distance between two points.
            </summary>
            <param name="pt0">The first point.</param>
            <param name="pt1">The second point.</param>
            <returns>The distance between pt0 and pt1.</returns>
        </member>
        <member name="M:MapWinGeoProc.Globals.DetermineRowClearCount(System.Int32,System.Int32)">
            <summary>
            Determines how many rows can be filled before unmanaged resources should
            be released.
            </summary>
            <param name="newNumRows">The total number of rows in the grid that's being filled.</param>
            <param name="newNumCols">The total number of cols in the grid that's being filled.</param>
            <returns>The number of rows that can be filled before COM objects need to be released.</returns>
        </member>
        <member name="M:MapWinGeoProc.Globals.TrimGrid(System.String@,System.String@)">
            <summary>
            Removes rows and columns that contain only NoData values from the edges of the grid.
            </summary>
            <param name="inputGFPath">The full path to the input grid.</param>
            <param name="resultGFPath">The full path to where the result grid should be saved.</param>
            <returns>False if an error occurs, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Globals.TrimGrid(MapWinGIS.Grid@)">
            <summary>
            Removes excess rows and columns contianing only "NoData" values from the grid's edges.
            </summary>
            <param name="grid">Grid in need of trimming.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Globals.ProjToCell(System.Double,System.Double,System.Int32@,System.Int32@,System.Double,System.Double,System.Double,System.Double,System.Int32)">
            <summary>
            Takes an x/y coordinate and finds what row/col the point exists in within the grid.
            </summary>
            <param name="x">X value of the coordinate point.</param>
            <param name="y">Y value of the coordinate point.</param>
            <param name="col">The resulting column.</param>
            <param name="row">The resulting row.</param>
            <param name="XllCenter">The X value of the center point of the lower-left corner of the grid.</param>
            <param name="YllCenter">The Y value of the center point of the lower-left corner of the grid.</param>
            <param name="dX">The width of a cell in the grid.</param>
            <param name="dY">The height of a cell in the grid.</param>
            <param name="numRows">The total number of rows in the grid.</param>
        </member>
        <member name="M:MapWinGeoProc.Globals.CellToProj(System.Int32,System.Int32,System.Double@,System.Double@,System.Double,System.Double,System.Double,System.Double,System.Int32)">
            <summary>
            Finds the center point of a grid cell that corresponds to the row/col provided.
            </summary>
            <param name="col">The column to be considered.</param>
            <param name="row">The row to be considered.</param>
            <param name="x">The resulting X value of the point that is in the center of the grid's cell.</param>
            <param name="y">The resulting Y value of the point that is in the center of the grid's cell.</param>
            <param name="XllCenter">The X value of the center point of the lower-left corner of the grid.</param>
            <param name="YllCenter">The Y value of the center point of the lower-left corner of the grid.</param>
            <param name="dX">The width of a cell in the grid.</param>
            <param name="dY">The height of a cell in the grid.</param>
            <param name="numRows">The total number of rows in the grid.</param>
        </member>
        <member name="M:MapWinGeoProc.Globals.IsClockwise(MapWinGIS.Shape@)">
            <summary>
            Calculates the Area to find if a simple convex or
            concave polyon is ordered clockwise or counter-clockwise.
            </summary>
            <param name="poly">Polygon to check for clockwiseness.</param>
            <returns>True if polygon is clockwise, false otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Globals.IsClockwise(MapWinGeoProc.Globals.Vertex[]@)">
            <summary>
            Calculates the Area to find if a simple convex or
            concave polyon is ordered clockwise or counter-clockwise.
            </summary>
            <param name="V">Array of vertices from the polygon whose orientation
            is being determined.</param>
            <returns>True if polygon vertices are oriented clockwise about 
            the normal, false otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Globals.CopyFields(MapWinGIS.Shapefile@,MapWinGIS.Shapefile@)">
            <summary>
            Copies all fields from the inputSF .dbf table to the resultSF table.
            </summary>
            <param name="inputSF">The shapefile with fields to be copied.</param>
            <param name="resultSF">The result shapefile that will inherit the fields.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Globals.CopyFields(MapWinGIS.Shapefile@,MapWinGIS.Shapefile@,System.Boolean)">
            <summary>
            Copies all fields from the inputSF .dbf table to the resultSF table.
            </summary>
            <param name="inputSF">The shapefile with fields to be copied.</param>
            <param name="resultSF">The result shapefile that will inherit the fields.</param>
            <param name="renameDuplicates">Instructs function to rename duplicate fields, used when merging two shape files.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.Globals.DoInsertIDs(MapWinGIS.Shapefile@)">
            <summary>
            Inserts the field 'ID' into the .dbf table along with the corresponding
            value for each shape in the input shapefile.
            </summary>
            <param name="sf">The input shapefile.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="T:MapWinGeoProc.Globals.Vertex">
            <summary>
            A coordinate point (x, y)
            </summary>
        </member>
        <member name="T:MapWinGeoProc.Globals.Line">
            <summary>
            Defines a 2pt line segment that begins at point p0 and ends at point p1.
            </summary>
        </member>
        <member name="T:MapWinGeoProc.ClipLineSFWithPoly">
             <summary>
            ClipLines defines internal functions for clipping lines with polygons.
             </summary>
        </member>
        <member name="M:MapWinGeoProc.ClipLineSFWithPoly.ClipLineSFWithMultiPartPolygon(System.String@,MapWinGIS.Shape@,System.String@,System.Boolean,System.Boolean)">
            <summary>
            Clips all lines in the shapefile using a multi-part polygon.
            </summary>
            <param name="lineSFPath">The full path to the line shapefile.</param>
            <param name="polygon">The multi-part polygon used for clipping.</param>
            <param name="resultSFPath">The full path to where the result file should be saved.</param>
            <param name="speedOptimized">True if fast clipping is desired (not advisable).</param>
            <param name="copyAttributes">True if copying Attributes</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.ClipLineSFWithPoly.ClipLineSFWithMultiPartPolygon(System.String@,MapWinGIS.Shape@,System.String@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Clips all lines in the shapefile using a multi-part polygon.
            </summary>
            <param name="lineSFPath">The full path to the line shapefile.</param>
            <param name="polygon">The multi-part polygon used for clipping.</param>
            <param name="resultSFPath">The full path to where the result file should be saved.</param>
            <param name="speedOptimized">True if fast clipping is desired (not advisable).</param>
            <param name="copyAttributes">True if copying Attributes</param>
            <param name="SkipMWShapeID">Indicates whether to skip creating an MWShapeID field in the result.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.ClipLineSFWithPoly.ClipLineSFWithMultiPartPolygon(MapWinGIS.Shapefile@,MapWinGIS.Shape@,MapWinGIS.Shapefile@,System.Boolean,System.Boolean)">
            <summary>
            Clips all lines in the shapefile using a multi-part polygon.
            </summary>
            <param name="lineSF">The line shapefile.</param>
            <param name="polygon">The multi-part polygon used for clipping.</param>
            <param name="resultSF">The result file.</param>
            <param name="speedOptimized">True if fast clipping is desired (not advisable).</param>
            <param name="copyAttributes">True if copying Attributes</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.ClipLineSFWithPoly.ClipLineSFWithMultiPartPolygon(MapWinGIS.Shapefile@,MapWinGIS.Shape@,MapWinGIS.Shapefile@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Clips all lines in the shapefile using a multi-part polygon.
            </summary>
            <param name="lineSF">The line shapefile.</param>
            <param name="polygon">The multi-part polygon used for clipping.</param>
            <param name="resultSF">The result file.</param>
            <param name="speedOptimized">True if fast clipping is desired (not advisable).</param>
            <param name="copyAttributes">True if copying Attributes</param>
            <param name="SkipMWShapeID">Indicates whether to skip creating an MWShapeID field in the result.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.ClipLineSFWithPoly.Fast_ClipLineSFWithPolygon(System.String@,MapWinGIS.Shape@,System.String@,System.Boolean)">
            <summary>
            Finds all portions of the lines that lie within the polygon and returns them in
            the shapefile resultSF.
            </summary>
            <param name="lineSFPath">Full path to the line shapefile.</param>
            <param name="polygon">The polygon that will be checked for intersections.</param>
            <param name="resultSFPath">Full path to the result shapefile.</param>
            <param name="copyAttributes">True if copying Attributes</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.ClipLineSFWithPoly.Fast_ClipLineSFWithPolygon(MapWinGIS.Shapefile@,MapWinGIS.Shape@,MapWinGIS.Shapefile@,System.Boolean)">
            <summary>
            All portions of lineSF within the polygon are found and saved in memory to resultLineSF.
            </summary>
            <param name="lineSF">The shapefile of lines to be tested.</param>
            <param name="polygon">The polygon that may contain none, a portion, or all of the lines.</param>
            <param name="resultLineSF">The resulting line portions found within the polygon's borders.</param>
            <param name="copyAttributes">True if copying Attributes</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.ClipLineSFWithPoly.Fast_ProcessPartInAndOutPoints(System.Boolean[]@,MapWinGIS.Shape@,MapWinGIS.Shape@,MapWinGIS.Shapefile@)">
            <summary>
            Divides a line containing both inside and outside polygon points into multiple 2pt segments.
            Calculates intersecetions and finds the portions of the line that are within the polygon.
            </summary>
            <param name="insidePts">Boolean array signifying which points lie within the polygon (true), or outside of it (false).</param>
            <param name="line">The line that being tested for internal segments.</param>
            <param name="polygon">The polygon that may contain portions of the line.</param>
            <param name="resultSF">The result shapefile that inside line portions will be saved to.</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.ClipLineSFWithPoly.Accurate_ClipLineSFWithPolygon(System.String@,MapWinGIS.Shape@,System.String@,System.Boolean)">
            <summary>
            Given a line shapefile and a polygon, this function will return only the
            portions of the lines that lie within the polygon.
            </summary>
            <param name="lineSFPath">The full path to the shapefile.</param>
            <param name="polygon">The polygon object to be used for clipping.</param>
            <param name="resultSFPath">The full path to the result file where clipped lines will be saved.</param>
            <param name="copyAttributes">True if copying Attributes</param>
            <returns>False if an error occured, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.ClipLineSFWithPoly.Accurate_ClipLineSFWithPolygon(MapWinGIS.Shapefile@,MapWinGIS.Shape@,MapWinGIS.Shapefile@,System.Boolean)">
            <summary>
            Given a line shapefile and a polygon, this function will find the
            portions of each line that lies within the polygon and save it in memory to resultLineSF. 
            </summary>
            <param name="lineSF">The line shapefile to be clipped by the polygon.</param>
            <param name="polygon">The polygon that might contain portions of one or more lines.</param>
            <param name="resultLineSF">The shapefile that will hold the newly clipped lines.</param>
            <param name="copyAttributes">True if copying Attributes</param>
            <returns>False if an error was encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.ClipLineSFWithPoly.ProcessAllInsidePoints(MapWinGIS.Shape@,MapWinGIS.Shape@,MapWinGIS.Shapefile@)">
            <summary>
            For lines where every point lies within the polygon, this function will
            find if a 2pt segment crosses outside of the polygon and then adds only the
            internal segments to the result file.
            </summary>
            <param name="line">The line whose points are all inside the polygon.</param>
            <param name="polygon">The polygon being checked for intersection.</param>
            <param name="resultSF">The file the internal segments should be saved to.</param>
            <returns>False if errors were encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.ClipLineSFWithPoly.ProcessAllOutsidePoints(MapWinGIS.Shape@,MapWinGIS.Shape@,MapWinGIS.Shapefile@)">
            <summary>
            For lines where every point lies outside the polygon, this function will
            find if any 2pt segment crosses within the polygon and then adds the
            internal segments to the result file.
            </summary>
            <param name="line">The line whose points are all outside of the polygon.</param>
            <param name="polygon">The polygon being checked for intersection.</param>
            <param name="resultSF">The file internal segments should be saved to.</param>
            <returns>False if errors were encountered, true otherwise.</returns>
        </member>
        <member name="M:MapWinGeoProc.ClipLineSFWithPoly.ProcessPartInAndOutPoints(System.Boolean[]@,MapWinGIS.Shape@,MapWinGIS.Shape@,MapWinGIS.Shapefile@)">
            <summary>
            For lines where part of the line lies within the polygon
            and part of it lies outside, this function will save only
            the inside portions and intersection points to the result shapefile.
            </summary>
            <param name="insidePts">A boolean array corresponding to each point in
            the line signifying if the point lies within the polygon or not.</param>
            <param name="line">A line that has at least one part of it within the polygon.</param>
            <param name="polygon">The polygon containing a portion of the line.</param>
            <param name="resultSF">The file that will contain the portions of the line that lie within the polygon.</param>
            <returns>False if an error is encountered, true otherwise.</returns>
        </member>
    </members>
</doc>
